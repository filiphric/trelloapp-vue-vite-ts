/*!
  * pinia v2.0.13
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
var Pinia=function(t,e){"use strict";let n;const i=t=>n=t,s=Symbol();function r(t){return t&&"object"==typeof t&&"[object Object]"===Object.prototype.toString.call(t)&&"function"!=typeof t.toJSON}var o;t.MutationType=void 0,(o=t.MutationType||(t.MutationType={})).direct="direct",o.patchObject="patch object",o.patchFunction="patch function";const a="undefined"!=typeof window;const c=()=>{};function u(t,n,i,s=c){t.push(n);const r=()=>{const e=t.indexOf(n);e>-1&&(t.splice(e,1),s())};return!i&&e.getCurrentInstance()&&e.onUnmounted(r),r}function p(t,...e){t.slice().forEach((t=>{t(...e)}))}function f(t,n){for(const i in n){if(!n.hasOwnProperty(i))continue;const s=n[i],o=t[i];t[i]=r(o)&&r(s)&&t.hasOwnProperty(i)&&!e.isRef(s)&&!e.isReactive(s)?f(o,s):s}return t}const d=Symbol(),h=new WeakMap;const{assign:l}=Object;function y(n,s,o={},a,y){let $;const v=o.state,_=l({actions:{}},o),b={deep:!0};let g,j,m,O=e.markRaw([]),R=e.markRaw([]);const P=a.state.value[n];function w(i){let s;g=j=!1,"function"==typeof i?(i(a.state.value[n]),s={type:t.MutationType.patchFunction,storeId:n,events:m}):(f(a.state.value[n],i),s={type:t.MutationType.patchObject,payload:i,storeId:n,events:m}),e.nextTick().then((()=>{g=!0})),j=!0,p(O,s,a.state.value[n])}v||P||(e.isVue2?e.set(a.state.value,n,{}):a.state.value[n]={}),e.ref({});const V=c;function S(t,e){return function(){i(a);const s=Array.from(arguments),r=[],o=[];function c(t){r.push(t)}function u(t){o.push(t)}let f;p(R,{args:s,name:t,store:A,after:c,onError:u});try{f=e.apply(this&&this.$id===n?this:A,s)}catch(t){throw p(o,t),t}return f instanceof Promise?f.then((t=>(p(r,t),t))).catch((t=>(p(o,t),Promise.reject(t)))):(p(r,f),f)}}const k={_p:a,$id:n,$onAction:u.bind(null,R),$patch:w,$reset:V,$subscribe(i,s={}){const r=u(O,i,s.detached,(()=>o())),o=$.run((()=>e.watch((()=>a.state.value[n]),(e=>{("sync"===s.flush?j:g)&&i({storeId:n,type:t.MutationType.direct,events:m},e)}),l({},b,s))));return r},$dispose:function(){$.stop(),O=[],R=[],a._s.delete(n)}};e.isVue2&&(k._r=!1);const A=e.reactive(l({},k));a._s.set(n,A);const M=a._e.run((()=>($=e.effectScope(),$.run((()=>s())))));for(const t in M){const i=M[t];if(e.isRef(i)&&(!e.isRef(I=i)||!I.effect)||e.isReactive(i))v||(!P||(T=i,e.isVue2?h.has(T):r(T)&&T.hasOwnProperty(d))||(e.isRef(i)?i.value=P[t]:f(i,P[t])),e.isVue2?e.set(a.state.value[n],t,i):a.state.value[n][t]=i);else if("function"==typeof i){const n=S(t,i);e.isVue2?e.set(M,t,n):M[t]=n,_.actions[t]=i}}var T,I;return e.isVue2?Object.keys(M).forEach((t=>{e.set(A,t,M[t])})):(l(A,M),l(e.toRaw(A),M)),Object.defineProperty(A,"$state",{get:()=>a.state.value[n],set:t=>{w((e=>{l(e,t)}))}}),e.isVue2&&(A._r=!0),a._p.forEach((t=>{l(A,$.run((()=>t({store:A,app:a._a,pinia:a,options:_}))))})),P&&v&&o.hydrate&&o.hydrate(A.$state,P),g=!0,j=!0,A}let $="Store";function v(t,e){return Array.isArray(e)?e.reduce(((e,n)=>(e[n]=function(){return t(this.$pinia)[n]},e)),{}):Object.keys(e).reduce(((n,i)=>(n[i]=function(){const n=t(this.$pinia),s=e[i];return"function"==typeof s?s.call(this,n):n[s]},n)),{})}const _=v;return t.PiniaVuePlugin=function(t){t.mixin({beforeCreate(){const t=this.$options;if(t.pinia){const e=t.pinia;if(!this._provided){const t={};Object.defineProperty(this,"_provided",{get:()=>t,set:e=>Object.assign(t,e)})}this._provided[s]=e,this.$pinia||(this.$pinia=e),e._a=this,a&&i(e)}else!this.$pinia&&t.parent&&t.parent.$pinia&&(this.$pinia=t.parent.$pinia)},destroyed(){delete this._pStores}})},t.acceptHMRUpdate=function(t,e){return n=>{const i=e.data.pinia||t._pinia;if(i){e.data.pinia=i;for(const r in n){const o=n[r];if("function"==typeof(s=o)&&"string"==typeof s.$id&&i._s.has(o.$id)){const n=o.$id;if(n!==t.$id)return console.warn(`The id of the store changed from "${t.$id}" to "${n}". Reloading.`),e.invalidate();const s=i._s.get(n);if(!s)return void console.log("[Pinia]: skipping hmr because store doesn't exist yet");o(i,s)}}var s}}},t.createPinia=function(){const t=e.effectScope(!0),n=t.run((()=>e.ref({})));let r=[],o=[];const a=e.markRaw({install(t){i(a),e.isVue2||(a._a=t,t.provide(s,a),t.config.globalProperties.$pinia=a,o.forEach((t=>r.push(t))),o=[])},use(t){return this._a||e.isVue2?r.push(t):o.push(t),this},_p:r,_a:null,_e:t,_s:new Map,state:n});return a},t.defineStore=function(t,r,o){let a,c;const u="function"==typeof r;function p(t,o){const p=e.getCurrentInstance();(t=t||p&&e.inject(s))&&i(t),(t=n)._s.has(a)||(u?y(a,r,c,t):function(t,n,s,r){const{state:o,actions:a,getters:c}=n,u=s.state.value[t];let p;p=y(t,(function(){u||(e.isVue2?e.set(s.state.value,t,o?o():{}):s.state.value[t]=o?o():{});const n=e.toRefs(s.state.value[t]);return l(n,a,Object.keys(c||{}).reduce(((n,r)=>(n[r]=e.markRaw(e.computed((()=>{i(s);const n=s._s.get(t);if(!e.isVue2||n._r)return c[r].call(n,n)}))),n)),{}))}),n,s),p.$reset=function(){const t=o?o():{};this.$patch((e=>{l(e,t)}))}}(a,c,t));return t._s.get(a)}return"string"==typeof t?(a=t,c=u?o:r):(c=t,a=t.id),p.$id=a,p},t.getActivePinia=()=>e.getCurrentInstance()&&e.inject(s)||n,t.mapActions=function(t,e){return Array.isArray(e)?e.reduce(((e,n)=>(e[n]=function(...e){return t(this.$pinia)[n](...e)},e)),{}):Object.keys(e).reduce(((n,i)=>(n[i]=function(...n){return t(this.$pinia)[e[i]](...n)},n)),{})},t.mapGetters=_,t.mapState=v,t.mapStores=function(...t){return t.reduce(((t,e)=>(t[e.$id+$]=function(){return e(this.$pinia)},t)),{})},t.mapWritableState=function(t,e){return Array.isArray(e)?e.reduce(((e,n)=>(e[n]={get(){return t(this.$pinia)[n]},set(e){return t(this.$pinia)[n]=e}},e)),{}):Object.keys(e).reduce(((n,i)=>(n[i]={get(){return t(this.$pinia)[e[i]]},set(n){return t(this.$pinia)[e[i]]=n}},n)),{})},t.setActivePinia=i,t.setMapStoreSuffix=function(t){$=t},t.skipHydrate=function(t){return e.isVue2?h.set(t,1)&&t:Object.defineProperty(t,d,{})},t.storeToRefs=function(t){if(e.isVue2)return e.toRefs(t);{t=e.toRaw(t);const n={};for(const i in t){const s=t[i];(e.isRef(s)||e.isReactive(s))&&(n[i]=e.toRef(t,i))}return n}},Object.defineProperty(t,"__esModule",{value:!0}),t}({},VueDemi);
