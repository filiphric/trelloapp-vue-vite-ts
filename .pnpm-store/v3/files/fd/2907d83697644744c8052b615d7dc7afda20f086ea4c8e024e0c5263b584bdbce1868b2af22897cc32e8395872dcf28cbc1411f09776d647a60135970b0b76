{"version":3,"file":"index.mjs","sources":["../../../.pnpm/@vue+compiler-sfc@3.0.11/node_modules/@vue/compiler-sfc/dist/compiler-sfc.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar CompilerDOM = require('@vue/compiler-dom');\nvar sourceMap = require('source-map');\nvar hash = require('hash-sum');\nvar path = require('path');\nvar compilerCore = require('@vue/compiler-core');\nvar url = require('url');\nvar shared = require('@vue/shared');\nvar CompilerSSR = require('@vue/compiler-ssr');\nvar postcss = require('postcss');\nvar selectorParser = require('postcss-selector-parser');\nvar merge = require('merge-source-map');\nvar MagicString = require('magic-string');\nvar parser = require('@babel/parser');\nvar estreeWalker = require('estree-walker');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      n[k] = e[k];\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar CompilerDOM__namespace = /*#__PURE__*/_interopNamespace(CompilerDOM);\nvar hash__default = /*#__PURE__*/_interopDefaultLegacy(hash);\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\nvar CompilerSSR__namespace = /*#__PURE__*/_interopNamespace(CompilerSSR);\nvar postcss__default = /*#__PURE__*/_interopDefaultLegacy(postcss);\nvar selectorParser__default = /*#__PURE__*/_interopDefaultLegacy(selectorParser);\nvar merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);\nvar MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);\n\nconst CSS_VARS_HELPER = `useCssVars`;\r\nconst cssVarRE = /\\bv-bind\\(\\s*(?:'([^']+)'|\"([^\"]+)\"|([^'\"][^)]*))\\s*\\)/g;\r\nfunction genCssVarsFromList(vars, id, isProd) {\r\n    return `{\\n  ${vars\r\n        .map(key => `\"${genVarName(id, key, isProd)}\": (${key})`)\r\n        .join(',\\n  ')}\\n}`;\r\n}\r\nfunction genVarName(id, raw, isProd) {\r\n    if (isProd) {\r\n        return hash__default(id + raw);\r\n    }\r\n    else {\r\n        return `${id}-${raw.replace(/([^\\w-])/g, '_')}`;\r\n    }\r\n}\r\nfunction parseCssVars(sfc) {\r\n    const vars = [];\r\n    sfc.styles.forEach(style => {\r\n        let match;\r\n        while ((match = cssVarRE.exec(style.content))) {\r\n            vars.push(match[1] || match[2] || match[3]);\r\n        }\r\n    });\r\n    return vars;\r\n}\r\nconst cssVarsPlugin = opts => {\r\n    const { id, isProd } = opts;\r\n    return {\r\n        postcssPlugin: 'vue-sfc-vars',\r\n        Declaration(decl) {\r\n            // rewrite CSS variables\r\n            if (cssVarRE.test(decl.value)) {\r\n                decl.value = decl.value.replace(cssVarRE, (_, $1, $2, $3) => {\r\n                    return `var(--${genVarName(id, $1 || $2 || $3, isProd)})`;\r\n                });\r\n            }\r\n        }\r\n    };\r\n};\r\ncssVarsPlugin.postcss = true;\r\nfunction genCssVarsCode(vars, bindings, id, isProd) {\r\n    const varsExp = genCssVarsFromList(vars, id, isProd);\r\n    const exp = CompilerDOM.createSimpleExpression(varsExp, false);\r\n    const context = CompilerDOM.createTransformContext(CompilerDOM.createRoot([]), {\r\n        prefixIdentifiers: true,\r\n        inline: true,\r\n        bindingMetadata: bindings\r\n    });\r\n    const transformed = CompilerDOM.processExpression(exp, context);\r\n    const transformedString = transformed.type === 4 /* SIMPLE_EXPRESSION */\r\n        ? transformed.content\r\n        : transformed.children\r\n            .map(c => {\r\n            return typeof c === 'string'\r\n                ? c\r\n                : c.content;\r\n        })\r\n            .join('');\r\n    return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`;\r\n}\r\n// <script setup> already gets the calls injected as part of the transform\r\n// this is only for single normal <script>\r\nfunction genNormalScriptCssVarsCode(cssVars, bindings, id, isProd) {\r\n    return (`\\nimport { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'\\n` +\r\n        `const __injectCSSVars__ = () => {\\n${genCssVarsCode(cssVars, bindings, id, isProd)}}\\n` +\r\n        `const __setup__ = __default__.setup\\n` +\r\n        `__default__.setup = __setup__\\n` +\r\n        `  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }\\n` +\r\n        `  : __injectCSSVars__\\n`);\r\n}\n\nconst hasWarned = {};\r\nfunction warnOnce(msg) {\r\n    const isNodeProd = typeof process !== 'undefined' && process.env.NODE_ENV === 'production';\r\n    if (!isNodeProd && !false && !hasWarned[msg]) {\r\n        hasWarned[msg] = true;\r\n        warn(msg);\r\n    }\r\n}\r\nfunction warn(msg) {\r\n    console.warn(`\\x1b[1m\\x1b[33m[@vue/compiler-sfc]\\x1b[0m\\x1b[33m ${msg}\\x1b[0m\\n`);\r\n}\r\nfunction warnExperimental(feature, rfcId) {\r\n    // eslint-disable-next-line\r\n    if (typeof window !== 'undefined') {\r\n        return;\r\n    }\r\n    warnOnce(`${feature} is still an experimental proposal.\\n` +\r\n        `Follow its status at https://github.com/vuejs/rfcs/pull/${rfcId}.`);\r\n    warnOnce(`When using experimental features,\\n` +\r\n        `it is recommended to pin your vue dependencies to exact versions to avoid breakage.`);\r\n}\n\nconst SFC_CACHE_MAX_SIZE = 500;\r\nconst sourceToSFC = new (require('lru-cache'))(SFC_CACHE_MAX_SIZE);\r\nfunction parse(source, { sourceMap = true, filename = 'anonymous.vue', sourceRoot = '', pad = false, compiler = CompilerDOM__namespace } = {}) {\r\n    const sourceKey = source + sourceMap + filename + sourceRoot + pad + compiler.parse;\r\n    const cache = sourceToSFC.get(sourceKey);\r\n    if (cache) {\r\n        return cache;\r\n    }\r\n    const descriptor = {\r\n        filename,\r\n        source,\r\n        template: null,\r\n        script: null,\r\n        scriptSetup: null,\r\n        styles: [],\r\n        customBlocks: [],\r\n        cssVars: [],\r\n        slotted: false\r\n    };\r\n    const errors = [];\r\n    const ast = compiler.parse(source, {\r\n        // there are no components at SFC parsing level\r\n        isNativeTag: () => true,\r\n        // preserve all whitespaces\r\n        isPreTag: () => true,\r\n        getTextMode: ({ tag, props }, parent) => {\r\n            // all top level elements except <template> are parsed as raw text\r\n            // containers\r\n            if ((!parent && tag !== 'template') ||\r\n                // <template lang=\"xxx\"> should also be treated as raw text\r\n                (tag === 'template' &&\r\n                    props.some(p => p.type === 6 /* ATTRIBUTE */ &&\r\n                        p.name === 'lang' &&\r\n                        p.value &&\r\n                        p.value.content &&\r\n                        p.value.content !== 'html'))) {\r\n                return 2 /* RAWTEXT */;\r\n            }\r\n            else {\r\n                return 0 /* DATA */;\r\n            }\r\n        },\r\n        onError: e => {\r\n            errors.push(e);\r\n        }\r\n    });\r\n    ast.children.forEach(node => {\r\n        if (node.type !== 1 /* ELEMENT */) {\r\n            return;\r\n        }\r\n        if (!node.children.length && !hasSrc(node) && node.tag !== 'template') {\r\n            return;\r\n        }\r\n        switch (node.tag) {\r\n            case 'template':\r\n                if (!descriptor.template) {\r\n                    const templateBlock = (descriptor.template = createBlock(node, source, false));\r\n                    templateBlock.ast = node;\r\n                }\r\n                else {\r\n                    errors.push(createDuplicateBlockError(node));\r\n                }\r\n                break;\r\n            case 'script':\r\n                const scriptBlock = createBlock(node, source, pad);\r\n                const isSetup = !!scriptBlock.attrs.setup;\r\n                if (isSetup && !descriptor.scriptSetup) {\r\n                    descriptor.scriptSetup = scriptBlock;\r\n                    break;\r\n                }\r\n                if (!isSetup && !descriptor.script) {\r\n                    descriptor.script = scriptBlock;\r\n                    break;\r\n                }\r\n                errors.push(createDuplicateBlockError(node, isSetup));\r\n                break;\r\n            case 'style':\r\n                const styleBlock = createBlock(node, source, pad);\r\n                if (styleBlock.attrs.vars) {\r\n                    errors.push(new SyntaxError(`<style vars> has been replaced by a new proposal: ` +\r\n                        `https://github.com/vuejs/rfcs/pull/231`));\r\n                }\r\n                descriptor.styles.push(styleBlock);\r\n                break;\r\n            default:\r\n                descriptor.customBlocks.push(createBlock(node, source, pad));\r\n                break;\r\n        }\r\n    });\r\n    if (descriptor.scriptSetup) {\r\n        if (descriptor.scriptSetup.src) {\r\n            errors.push(new SyntaxError(`<script setup> cannot use the \"src\" attribute because ` +\r\n                `its syntax will be ambiguous outside of the component.`));\r\n            descriptor.scriptSetup = null;\r\n        }\r\n        if (descriptor.script && descriptor.script.src) {\r\n            errors.push(new SyntaxError(`<script> cannot use the \"src\" attribute when <script setup> is ` +\r\n                `also present because they must be processed together.`));\r\n            descriptor.script = null;\r\n        }\r\n    }\r\n    if (sourceMap) {\r\n        const genMap = (block) => {\r\n            if (block && !block.src) {\r\n                block.map = generateSourceMap(filename, source, block.content, sourceRoot, !pad || block.type === 'template' ? block.loc.start.line - 1 : 0);\r\n            }\r\n        };\r\n        genMap(descriptor.template);\r\n        genMap(descriptor.script);\r\n        descriptor.styles.forEach(genMap);\r\n        descriptor.customBlocks.forEach(genMap);\r\n    }\r\n    // parse CSS vars\r\n    descriptor.cssVars = parseCssVars(descriptor);\r\n    if (descriptor.cssVars.length) {\r\n        warnExperimental(`v-bind() CSS variable injection`, 231);\r\n    }\r\n    // check if the SFC uses :slotted\r\n    const slottedRE = /(?:::v-|:)slotted\\(/;\r\n    descriptor.slotted = descriptor.styles.some(s => s.scoped && slottedRE.test(s.content));\r\n    const result = {\r\n        descriptor,\r\n        errors\r\n    };\r\n    sourceToSFC.set(sourceKey, result);\r\n    return result;\r\n}\r\nfunction createDuplicateBlockError(node, isScriptSetup = false) {\r\n    const err = new SyntaxError(`Single file component can contain only one <${node.tag}${isScriptSetup ? ` setup` : ``}> element`);\r\n    err.loc = node.loc;\r\n    return err;\r\n}\r\nfunction createBlock(node, source, pad) {\r\n    const type = node.tag;\r\n    let { start, end } = node.loc;\r\n    let content = '';\r\n    if (node.children.length) {\r\n        start = node.children[0].loc.start;\r\n        end = node.children[node.children.length - 1].loc.end;\r\n        content = source.slice(start.offset, end.offset);\r\n    }\r\n    const loc = {\r\n        source: content,\r\n        start,\r\n        end\r\n    };\r\n    const attrs = {};\r\n    const block = {\r\n        type,\r\n        content,\r\n        loc,\r\n        attrs\r\n    };\r\n    if (pad) {\r\n        block.content = padContent(source, block, pad) + block.content;\r\n    }\r\n    node.props.forEach(p => {\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            attrs[p.name] = p.value ? p.value.content || true : true;\r\n            if (p.name === 'lang') {\r\n                block.lang = p.value && p.value.content;\r\n            }\r\n            else if (p.name === 'src') {\r\n                block.src = p.value && p.value.content;\r\n            }\r\n            else if (type === 'style') {\r\n                if (p.name === 'scoped') {\r\n                    block.scoped = true;\r\n                }\r\n                else if (p.name === 'module') {\r\n                    block.module = attrs[p.name];\r\n                }\r\n            }\r\n            else if (type === 'script' && p.name === 'setup') {\r\n                block.setup = attrs.setup;\r\n            }\r\n        }\r\n    });\r\n    return block;\r\n}\r\nconst splitRE = /\\r?\\n/g;\r\nconst emptyRE = /^(?:\\/\\/)?\\s*$/;\r\nconst replaceRE = /./g;\r\nfunction generateSourceMap(filename, source, generated, sourceRoot, lineOffset) {\r\n    const map = new sourceMap.SourceMapGenerator({\r\n        file: filename.replace(/\\\\/g, '/'),\r\n        sourceRoot: sourceRoot.replace(/\\\\/g, '/')\r\n    });\r\n    map.setSourceContent(filename, source);\r\n    generated.split(splitRE).forEach((line, index) => {\r\n        if (!emptyRE.test(line)) {\r\n            const originalLine = index + 1 + lineOffset;\r\n            const generatedLine = index + 1;\r\n            for (let i = 0; i < line.length; i++) {\r\n                if (!/\\s/.test(line[i])) {\r\n                    map.addMapping({\r\n                        source: filename,\r\n                        original: {\r\n                            line: originalLine,\r\n                            column: i\r\n                        },\r\n                        generated: {\r\n                            line: generatedLine,\r\n                            column: i\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return JSON.parse(map.toString());\r\n}\r\nfunction padContent(content, block, pad) {\r\n    content = content.slice(0, block.loc.start.offset);\r\n    if (pad === 'space') {\r\n        return content.replace(replaceRE, ' ');\r\n    }\r\n    else {\r\n        const offset = content.split(splitRE).length;\r\n        const padChar = block.type === 'script' && !block.lang ? '//\\n' : '\\n';\r\n        return Array(offset).join(padChar);\r\n    }\r\n}\r\nfunction hasSrc(node) {\r\n    return node.props.some(p => {\r\n        if (p.type !== 6 /* ATTRIBUTE */) {\r\n            return false;\r\n        }\r\n        return p.name === 'src';\r\n    });\r\n}\n\nfunction isRelativeUrl(url) {\r\n    const firstChar = url.charAt(0);\r\n    return firstChar === '.' || firstChar === '~' || firstChar === '@';\r\n}\r\nconst externalRE = /^https?:\\/\\//;\r\nfunction isExternalUrl(url) {\r\n    return externalRE.test(url);\r\n}\r\nconst dataUrlRE = /^\\s*data:/i;\r\nfunction isDataUrl(url) {\r\n    return dataUrlRE.test(url);\r\n}\r\n/**\r\n * Parses string url into URL object.\r\n */\r\nfunction parseUrl(url) {\r\n    const firstChar = url.charAt(0);\r\n    if (firstChar === '~') {\r\n        const secondChar = url.charAt(1);\r\n        url = url.slice(secondChar === '/' ? 2 : 1);\r\n    }\r\n    return parseUriParts(url);\r\n}\r\n/**\r\n * vuejs/component-compiler-utils#22 Support uri fragment in transformed require\r\n * @param urlString an url as a string\r\n */\r\nfunction parseUriParts(urlString) {\r\n    // A TypeError is thrown if urlString is not a string\r\n    // @see https://nodejs.org/api/url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost\r\n    return url.parse(shared.isString(urlString) ? urlString : '', false, true);\r\n}\n\nconst defaultAssetUrlOptions = {\r\n    base: null,\r\n    includeAbsolute: false,\r\n    tags: {\r\n        video: ['src', 'poster'],\r\n        source: ['src'],\r\n        img: ['src'],\r\n        image: ['xlink:href', 'href'],\r\n        use: ['xlink:href', 'href']\r\n    }\r\n};\r\nconst normalizeOptions = (options) => {\r\n    if (Object.keys(options).some(key => shared.isArray(options[key]))) {\r\n        // legacy option format which directly passes in tags config\r\n        return {\r\n            ...defaultAssetUrlOptions,\r\n            tags: options\r\n        };\r\n    }\r\n    return {\r\n        ...defaultAssetUrlOptions,\r\n        ...options\r\n    };\r\n};\r\nconst createAssetUrlTransformWithOptions = (options) => {\r\n    return (node, context) => transformAssetUrl(node, context, options);\r\n};\r\n/**\r\n * A `@vue/compiler-core` plugin that transforms relative asset urls into\r\n * either imports or absolute urls.\r\n *\r\n * ``` js\r\n * // Before\r\n * createVNode('img', { src: './logo.png' })\r\n *\r\n * // After\r\n * import _imports_0 from './logo.png'\r\n * createVNode('img', { src: _imports_0 })\r\n * ```\r\n */\r\nconst transformAssetUrl = (node, context, options = defaultAssetUrlOptions) => {\r\n    if (node.type === 1 /* ELEMENT */) {\r\n        if (!node.props.length) {\r\n            return;\r\n        }\r\n        const tags = options.tags || defaultAssetUrlOptions.tags;\r\n        const attrs = tags[node.tag];\r\n        const wildCardAttrs = tags['*'];\r\n        if (!attrs && !wildCardAttrs) {\r\n            return;\r\n        }\r\n        const assetAttrs = (attrs || []).concat(wildCardAttrs || []);\r\n        node.props.forEach((attr, index) => {\r\n            if (attr.type !== 6 /* ATTRIBUTE */ ||\r\n                !assetAttrs.includes(attr.name) ||\r\n                !attr.value ||\r\n                isExternalUrl(attr.value.content) ||\r\n                isDataUrl(attr.value.content) ||\r\n                attr.value.content[0] === '#' ||\r\n                (!options.includeAbsolute && !isRelativeUrl(attr.value.content))) {\r\n                return;\r\n            }\r\n            const url = parseUrl(attr.value.content);\r\n            if (options.base && attr.value.content[0] === '.') {\r\n                // explicit base - directly rewrite relative urls into absolute url\r\n                // to avoid generating extra imports\r\n                // Allow for full hostnames provided in options.base\r\n                const base = parseUrl(options.base);\r\n                const protocol = base.protocol || '';\r\n                const host = base.host ? protocol + '//' + base.host : '';\r\n                const basePath = base.path || '/';\r\n                // when packaged in the browser, path will be using the posix-\r\n                // only version provided by rollup-plugin-node-builtins.\r\n                attr.value.content =\r\n                    host +\r\n                        (path__default.posix || path__default).join(basePath, url.path + (url.hash || ''));\r\n                return;\r\n            }\r\n            // otherwise, transform the url into an import.\r\n            // this assumes a bundler will resolve the import into the correct\r\n            // absolute url (e.g. webpack file-loader)\r\n            const exp = getImportsExpressionExp(url.path, url.hash, attr.loc, context);\r\n            node.props[index] = {\r\n                type: 7 /* DIRECTIVE */,\r\n                name: 'bind',\r\n                arg: compilerCore.createSimpleExpression(attr.name, true, attr.loc),\r\n                exp,\r\n                modifiers: [],\r\n                loc: attr.loc\r\n            };\r\n        });\r\n    }\r\n};\r\nfunction getImportsExpressionExp(path, hash, loc, context) {\r\n    if (path) {\r\n        const existing = context.imports.find(i => i.path === path);\r\n        if (existing) {\r\n            return existing.exp;\r\n        }\r\n        const name = `_imports_${context.imports.length}`;\r\n        const exp = compilerCore.createSimpleExpression(name, false, loc, 2 /* CAN_HOIST */);\r\n        context.imports.push({ exp, path });\r\n        if (hash && path) {\r\n            return context.hoist(compilerCore.createSimpleExpression(`${name} + '${hash}'`, false, loc, 2 /* CAN_HOIST */));\r\n        }\r\n        else {\r\n            return exp;\r\n        }\r\n    }\r\n    else {\r\n        return compilerCore.createSimpleExpression(`''`, false, loc, 2 /* CAN_HOIST */);\r\n    }\r\n}\n\nconst srcsetTags = ['img', 'source'];\r\n// http://w3c.github.io/html/semantics-embedded-content.html#ref-for-image-candidate-string-5\r\nconst escapedSpaceCharacters = /( |\\\\t|\\\\n|\\\\f|\\\\r)+/g;\r\nconst createSrcsetTransformWithOptions = (options) => {\r\n    return (node, context) => transformSrcset(node, context, options);\r\n};\r\nconst transformSrcset = (node, context, options = defaultAssetUrlOptions) => {\r\n    if (node.type === 1 /* ELEMENT */) {\r\n        if (srcsetTags.includes(node.tag) && node.props.length) {\r\n            node.props.forEach((attr, index) => {\r\n                if (attr.name === 'srcset' && attr.type === 6 /* ATTRIBUTE */) {\r\n                    if (!attr.value)\r\n                        return;\r\n                    const value = attr.value.content;\r\n                    if (!value)\r\n                        return;\r\n                    const imageCandidates = value.split(',').map(s => {\r\n                        // The attribute value arrives here with all whitespace, except\r\n                        // normal spaces, represented by escape sequences\r\n                        const [url, descriptor] = s\r\n                            .replace(escapedSpaceCharacters, ' ')\r\n                            .trim()\r\n                            .split(' ', 2);\r\n                        return { url, descriptor };\r\n                    });\r\n                    // data urls contains comma after the ecoding so we need to re-merge\r\n                    // them\r\n                    for (let i = 0; i < imageCandidates.length; i++) {\r\n                        const { url } = imageCandidates[i];\r\n                        if (isDataUrl(url)) {\r\n                            imageCandidates[i + 1].url =\r\n                                url + ',' + imageCandidates[i + 1].url;\r\n                            imageCandidates.splice(i, 1);\r\n                        }\r\n                    }\r\n                    const hasQualifiedUrl = imageCandidates.some(({ url }) => {\r\n                        return (!isExternalUrl(url) &&\r\n                            !isDataUrl(url) &&\r\n                            (options.includeAbsolute || isRelativeUrl(url)));\r\n                    });\r\n                    // When srcset does not contain any qualified URLs, skip transforming\r\n                    if (!hasQualifiedUrl) {\r\n                        return;\r\n                    }\r\n                    if (options.base) {\r\n                        const base = options.base;\r\n                        const set = [];\r\n                        imageCandidates.forEach(({ url, descriptor }) => {\r\n                            descriptor = descriptor ? ` ${descriptor}` : ``;\r\n                            if (isRelativeUrl(url)) {\r\n                                set.push((path__default.posix || path__default).join(base, url) + descriptor);\r\n                            }\r\n                            else {\r\n                                set.push(url + descriptor);\r\n                            }\r\n                        });\r\n                        attr.value.content = set.join(', ');\r\n                        return;\r\n                    }\r\n                    const compoundExpression = compilerCore.createCompoundExpression([], attr.loc);\r\n                    imageCandidates.forEach(({ url, descriptor }, index) => {\r\n                        if (!isExternalUrl(url) &&\r\n                            !isDataUrl(url) &&\r\n                            (options.includeAbsolute || isRelativeUrl(url))) {\r\n                            const { path } = parseUrl(url);\r\n                            let exp;\r\n                            if (path) {\r\n                                const existingImportsIndex = context.imports.findIndex(i => i.path === path);\r\n                                if (existingImportsIndex > -1) {\r\n                                    exp = compilerCore.createSimpleExpression(`_imports_${existingImportsIndex}`, false, attr.loc, 2 /* CAN_HOIST */);\r\n                                }\r\n                                else {\r\n                                    exp = compilerCore.createSimpleExpression(`_imports_${context.imports.length}`, false, attr.loc, 2 /* CAN_HOIST */);\r\n                                    context.imports.push({ exp, path });\r\n                                }\r\n                                compoundExpression.children.push(exp);\r\n                            }\r\n                        }\r\n                        else {\r\n                            const exp = compilerCore.createSimpleExpression(`\"${url}\"`, false, attr.loc, 2 /* CAN_HOIST */);\r\n                            compoundExpression.children.push(exp);\r\n                        }\r\n                        const isNotLast = imageCandidates.length - 1 > index;\r\n                        if (descriptor && isNotLast) {\r\n                            compoundExpression.children.push(` + ' ${descriptor}, ' + `);\r\n                        }\r\n                        else if (descriptor) {\r\n                            compoundExpression.children.push(` + ' ${descriptor}'`);\r\n                        }\r\n                        else if (isNotLast) {\r\n                            compoundExpression.children.push(` + ', ' + `);\r\n                        }\r\n                    });\r\n                    const hoisted = context.hoist(compoundExpression);\r\n                    hoisted.constType = 2 /* CAN_HOIST */;\r\n                    node.props[index] = {\r\n                        type: 7 /* DIRECTIVE */,\r\n                        name: 'bind',\r\n                        arg: compilerCore.createSimpleExpression('srcset', true, attr.loc),\r\n                        exp: hoisted,\r\n                        modifiers: [],\r\n                        loc: attr.loc\r\n                    };\r\n                }\r\n            });\r\n        }\r\n    }\r\n};\n\nfunction preprocess({ source, filename, preprocessOptions }, preprocessor) {\r\n    // Consolidate exposes a callback based API, but the callback is in fact\r\n    // called synchronously for most templating engines. In our case, we have to\r\n    // expose a synchronous API so that it is usable in Jest transforms (which\r\n    // have to be sync because they are applied via Node.js require hooks)\r\n    let res = '';\r\n    let err = null;\r\n    preprocessor.render(source, { filename, ...preprocessOptions }, (_err, _res) => {\r\n        if (_err)\r\n            err = _err;\r\n        res = _res;\r\n    });\r\n    if (err)\r\n        throw err;\r\n    return res;\r\n}\r\nfunction compileTemplate(options) {\r\n    const { preprocessLang, preprocessCustomRequire } = options;\r\n    const preprocessor = preprocessLang\r\n        ? preprocessCustomRequire\r\n            ? preprocessCustomRequire(preprocessLang)\r\n            : require('consolidate')[preprocessLang]\r\n        : false;\r\n    if (preprocessor) {\r\n        try {\r\n            return doCompileTemplate({\r\n                ...options,\r\n                source: preprocess(options, preprocessor)\r\n            });\r\n        }\r\n        catch (e) {\r\n            return {\r\n                code: `export default function render() {}`,\r\n                source: options.source,\r\n                tips: [],\r\n                errors: [e]\r\n            };\r\n        }\r\n    }\r\n    else if (preprocessLang) {\r\n        return {\r\n            code: `export default function render() {}`,\r\n            source: options.source,\r\n            tips: [\r\n                `Component ${options.filename} uses lang ${preprocessLang} for template. Please install the language preprocessor.`\r\n            ],\r\n            errors: [\r\n                `Component ${options.filename} uses lang ${preprocessLang} for template, however it is not installed.`\r\n            ]\r\n        };\r\n    }\r\n    else {\r\n        return doCompileTemplate(options);\r\n    }\r\n}\r\nfunction doCompileTemplate({ filename, id, scoped, slotted, inMap, source, ssr = false, ssrCssVars, isProd = false, compiler = ssr ? CompilerSSR__namespace : CompilerDOM__namespace, compilerOptions = {}, transformAssetUrls }) {\r\n    const errors = [];\r\n    let nodeTransforms = [];\r\n    if (shared.isObject(transformAssetUrls)) {\r\n        const assetOptions = normalizeOptions(transformAssetUrls);\r\n        nodeTransforms = [\r\n            createAssetUrlTransformWithOptions(assetOptions),\r\n            createSrcsetTransformWithOptions(assetOptions)\r\n        ];\r\n    }\r\n    else if (transformAssetUrls !== false) {\r\n        nodeTransforms = [transformAssetUrl, transformSrcset];\r\n    }\r\n    if (ssr && !ssrCssVars) {\r\n        warnOnce(`compileTemplate is called with \\`ssr: true\\` but no ` +\r\n            `corresponding \\`cssVars\\` option.\\`.`);\r\n    }\r\n    if (!id) {\r\n        warnOnce(`compileTemplate now requires the \\`id\\` option.\\`.`);\r\n        id = '';\r\n    }\r\n    const shortId = id.replace(/^data-v-/, '');\r\n    const longId = `data-v-${shortId}`;\r\n    let { code, ast, preamble, map } = compiler.compile(source, {\r\n        mode: 'module',\r\n        prefixIdentifiers: true,\r\n        hoistStatic: true,\r\n        cacheHandlers: true,\r\n        ssrCssVars: ssr && ssrCssVars && ssrCssVars.length\r\n            ? genCssVarsFromList(ssrCssVars, shortId, isProd)\r\n            : '',\r\n        scopeId: scoped ? longId : undefined,\r\n        slotted,\r\n        ...compilerOptions,\r\n        nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),\r\n        filename,\r\n        sourceMap: true,\r\n        onError: e => errors.push(e)\r\n    });\r\n    // inMap should be the map produced by ./parse.ts which is a simple line-only\r\n    // mapping. If it is present, we need to adjust the final map and errors to\r\n    // reflect the original line numbers.\r\n    if (inMap) {\r\n        if (map) {\r\n            map = mapLines(inMap, map);\r\n        }\r\n        if (errors.length) {\r\n            patchErrors(errors, source, inMap);\r\n        }\r\n    }\r\n    return { code, ast, preamble, source, errors, tips: [], map };\r\n}\r\nfunction mapLines(oldMap, newMap) {\r\n    if (!oldMap)\r\n        return newMap;\r\n    if (!newMap)\r\n        return oldMap;\r\n    const oldMapConsumer = new sourceMap.SourceMapConsumer(oldMap);\r\n    const newMapConsumer = new sourceMap.SourceMapConsumer(newMap);\r\n    const mergedMapGenerator = new sourceMap.SourceMapGenerator();\r\n    newMapConsumer.eachMapping(m => {\r\n        if (m.originalLine == null) {\r\n            return;\r\n        }\r\n        const origPosInOldMap = oldMapConsumer.originalPositionFor({\r\n            line: m.originalLine,\r\n            column: m.originalColumn\r\n        });\r\n        if (origPosInOldMap.source == null) {\r\n            return;\r\n        }\r\n        mergedMapGenerator.addMapping({\r\n            generated: {\r\n                line: m.generatedLine,\r\n                column: m.generatedColumn\r\n            },\r\n            original: {\r\n                line: origPosInOldMap.line,\r\n                // use current column, since the oldMap produced by @vue/compiler-sfc\r\n                // does not\r\n                column: m.originalColumn\r\n            },\r\n            source: origPosInOldMap.source,\r\n            name: origPosInOldMap.name\r\n        });\r\n    });\r\n    // source-map's type definition is incomplete\r\n    const generator = mergedMapGenerator;\r\n    oldMapConsumer.sources.forEach((sourceFile) => {\r\n        generator._sources.add(sourceFile);\r\n        const sourceContent = oldMapConsumer.sourceContentFor(sourceFile);\r\n        if (sourceContent != null) {\r\n            mergedMapGenerator.setSourceContent(sourceFile, sourceContent);\r\n        }\r\n    });\r\n    generator._sourceRoot = oldMap.sourceRoot;\r\n    generator._file = oldMap.file;\r\n    return generator.toJSON();\r\n}\r\nfunction patchErrors(errors, source, inMap) {\r\n    const originalSource = inMap.sourcesContent[0];\r\n    const offset = originalSource.indexOf(source);\r\n    const lineOffset = originalSource.slice(0, offset).split(/\\r?\\n/).length - 1;\r\n    errors.forEach(err => {\r\n        if (err.loc) {\r\n            err.loc.start.line += lineOffset;\r\n            err.loc.start.offset += offset;\r\n            if (err.loc.end !== err.loc.start) {\r\n                err.loc.end.line += lineOffset;\r\n                err.loc.end.offset += offset;\r\n            }\r\n        }\r\n    });\r\n}\n\nconst trimPlugin = () => {\r\n    return {\r\n        postcssPlugin: 'vue-sfc-trim',\r\n        Once(root) {\r\n            root.walk(({ type, raws }) => {\r\n                if (type === 'rule' || type === 'atrule') {\r\n                    if (raws.before)\r\n                        raws.before = '\\n';\r\n                    if ('after' in raws && raws.after)\r\n                        raws.after = '\\n';\r\n                }\r\n            });\r\n        }\r\n    };\r\n};\r\ntrimPlugin.postcss = true;\n\nconst animationNameRE = /^(-\\w+-)?animation-name$/;\r\nconst animationRE = /^(-\\w+-)?animation$/;\r\nconst scopedPlugin = (id = '') => {\r\n    const keyframes = Object.create(null);\r\n    const shortId = id.replace(/^data-v-/, '');\r\n    return {\r\n        postcssPlugin: 'vue-sfc-scoped',\r\n        Rule(rule) {\r\n            processRule(id, rule);\r\n        },\r\n        AtRule(node) {\r\n            if (/-?keyframes$/.test(node.name) &&\r\n                !node.params.endsWith(`-${shortId}`)) {\r\n                // register keyframes\r\n                keyframes[node.params] = node.params = node.params + '-' + shortId;\r\n            }\r\n        },\r\n        OnceExit(root) {\r\n            if (Object.keys(keyframes).length) {\r\n                // If keyframes are found in this <style>, find and rewrite animation names\r\n                // in declarations.\r\n                // Caveat: this only works for keyframes and animation rules in the same\r\n                // <style> element.\r\n                // individual animation-name declaration\r\n                root.walkDecls(decl => {\r\n                    if (animationNameRE.test(decl.prop)) {\r\n                        decl.value = decl.value\r\n                            .split(',')\r\n                            .map(v => keyframes[v.trim()] || v.trim())\r\n                            .join(',');\r\n                    }\r\n                    // shorthand\r\n                    if (animationRE.test(decl.prop)) {\r\n                        decl.value = decl.value\r\n                            .split(',')\r\n                            .map(v => {\r\n                            const vals = v.trim().split(/\\s+/);\r\n                            const i = vals.findIndex(val => keyframes[val]);\r\n                            if (i !== -1) {\r\n                                vals.splice(i, 1, keyframes[vals[i]]);\r\n                                return vals.join(' ');\r\n                            }\r\n                            else {\r\n                                return v;\r\n                            }\r\n                        })\r\n                            .join(',');\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n};\r\nconst processedRules = new WeakSet();\r\nfunction processRule(id, rule) {\r\n    if (processedRules.has(rule) ||\r\n        (rule.parent &&\r\n            rule.parent.type === 'atrule' &&\r\n            /-?keyframes$/.test(rule.parent.name))) {\r\n        return;\r\n    }\r\n    processedRules.add(rule);\r\n    rule.selector = selectorParser__default(selectorRoot => {\r\n        selectorRoot.each(selector => {\r\n            rewriteSelector(id, selector, selectorRoot);\r\n        });\r\n    }).processSync(rule.selector);\r\n}\r\nfunction rewriteSelector(id, selector, selectorRoot, slotted = false) {\r\n    let node = null;\r\n    let shouldInject = true;\r\n    // find the last child node to insert attribute selector\r\n    selector.each(n => {\r\n        // DEPRECATED \">>>\" and \"/deep/\" combinator\r\n        if (n.type === 'combinator' &&\r\n            (n.value === '>>>' || n.value === '/deep/')) {\r\n            n.value = ' ';\r\n            n.spaces.before = n.spaces.after = '';\r\n            warn(`the >>> and /deep/ combinators have been deprecated. ` +\r\n                `Use :deep() instead.`);\r\n            return false;\r\n        }\r\n        if (n.type === 'pseudo') {\r\n            const { value } = n;\r\n            // deep: inject [id] attribute at the node before the ::v-deep\r\n            // combinator.\r\n            if (value === ':deep' || value === '::v-deep') {\r\n                if (n.nodes.length) {\r\n                    // .foo ::v-deep(.bar) -> .foo[xxxxxxx] .bar\r\n                    // replace the current node with ::v-deep's inner selector\r\n                    let last = n;\r\n                    n.nodes[0].each(ss => {\r\n                        selector.insertAfter(last, ss);\r\n                        last = ss;\r\n                    });\r\n                    // insert a space combinator before if it doesn't already have one\r\n                    const prev = selector.at(selector.index(n) - 1);\r\n                    if (!prev || !isSpaceCombinator(prev)) {\r\n                        selector.insertAfter(n, selectorParser__default.combinator({\r\n                            value: ' '\r\n                        }));\r\n                    }\r\n                    selector.removeChild(n);\r\n                }\r\n                else {\r\n                    // DEPRECATED usage\r\n                    // .foo ::v-deep .bar -> .foo[xxxxxxx] .bar\r\n                    warn(`::v-deep usage as a combinator has ` +\r\n                        `been deprecated. Use :deep(<inner-selector>) instead.`);\r\n                    const prev = selector.at(selector.index(n) - 1);\r\n                    if (prev && isSpaceCombinator(prev)) {\r\n                        selector.removeChild(prev);\r\n                    }\r\n                    selector.removeChild(n);\r\n                }\r\n                return false;\r\n            }\r\n            // slot: use selector inside `::v-slotted` and inject [id + '-s']\r\n            // instead.\r\n            // ::v-slotted(.foo) -> .foo[xxxxxxx-s]\r\n            if (value === ':slotted' || value === '::v-slotted') {\r\n                rewriteSelector(id, n.nodes[0], selectorRoot, true /* slotted */);\r\n                let last = n;\r\n                n.nodes[0].each(ss => {\r\n                    selector.insertAfter(last, ss);\r\n                    last = ss;\r\n                });\r\n                // selector.insertAfter(n, n.nodes[0])\r\n                selector.removeChild(n);\r\n                // since slotted attribute already scopes the selector there's no\r\n                // need for the non-slot attribute.\r\n                shouldInject = false;\r\n                return false;\r\n            }\r\n            // global: replace with inner selector and do not inject [id].\r\n            // ::v-global(.foo) -> .foo\r\n            if (value === ':global' || value === '::v-global') {\r\n                selectorRoot.insertAfter(selector, n.nodes[0]);\r\n                selectorRoot.removeChild(selector);\r\n                return false;\r\n            }\r\n        }\r\n        if (n.type !== 'pseudo' && n.type !== 'combinator') {\r\n            node = n;\r\n        }\r\n    });\r\n    if (node) {\r\n        node.spaces.after = '';\r\n    }\r\n    else {\r\n        // For deep selectors & standalone pseudo selectors,\r\n        // the attribute selectors are prepended rather than appended.\r\n        // So all leading spaces must be eliminated to avoid problems.\r\n        selector.first.spaces.before = '';\r\n    }\r\n    if (shouldInject) {\r\n        const idToAdd = slotted ? id + '-s' : id;\r\n        selector.insertAfter(\r\n        // If node is null it means we need to inject [id] at the start\r\n        // insertAfter can handle `null` here\r\n        node, selectorParser__default.attribute({\r\n            attribute: idToAdd,\r\n            value: idToAdd,\r\n            raws: {},\r\n            quoteMark: `\"`\r\n        }));\r\n    }\r\n}\r\nfunction isSpaceCombinator(node) {\r\n    return node.type === 'combinator' && /^\\s+$/.test(node.value);\r\n}\r\nscopedPlugin.postcss = true;\n\n// .scss/.sass processor\r\nconst scss = (source, map, options, load = require) => {\r\n    const nodeSass = load('sass');\r\n    const finalOptions = {\r\n        ...options,\r\n        data: getSource(source, options.filename, options.additionalData),\r\n        file: options.filename,\r\n        outFile: options.filename,\r\n        sourceMap: !!map\r\n    };\r\n    try {\r\n        const result = nodeSass.renderSync(finalOptions);\r\n        const dependencies = result.stats.includedFiles;\r\n        if (map) {\r\n            return {\r\n                code: result.css.toString(),\r\n                map: merge__default(map, JSON.parse(result.map.toString())),\r\n                errors: [],\r\n                dependencies\r\n            };\r\n        }\r\n        return { code: result.css.toString(), errors: [], dependencies };\r\n    }\r\n    catch (e) {\r\n        return { code: '', errors: [e], dependencies: [] };\r\n    }\r\n};\r\nconst sass = (source, map, options, load) => scss(source, map, {\r\n    ...options,\r\n    indentedSyntax: true\r\n}, load);\r\n// .less\r\nconst less = (source, map, options, load = require) => {\r\n    const nodeLess = load('less');\r\n    let result;\r\n    let error = null;\r\n    nodeLess.render(getSource(source, options.filename, options.additionalData), { ...options, syncImport: true }, (err, output) => {\r\n        error = err;\r\n        result = output;\r\n    });\r\n    if (error)\r\n        return { code: '', errors: [error], dependencies: [] };\r\n    const dependencies = result.imports;\r\n    if (map) {\r\n        return {\r\n            code: result.css.toString(),\r\n            map: merge__default(map, result.map),\r\n            errors: [],\r\n            dependencies: dependencies\r\n        };\r\n    }\r\n    return {\r\n        code: result.css.toString(),\r\n        errors: [],\r\n        dependencies: dependencies\r\n    };\r\n};\r\n// .styl\r\nconst styl = (source, map, options, load = require) => {\r\n    const nodeStylus = load('stylus');\r\n    try {\r\n        const ref = nodeStylus(source);\r\n        Object.keys(options).forEach(key => ref.set(key, options[key]));\r\n        if (map)\r\n            ref.set('sourcemap', { inline: false, comment: false });\r\n        const result = ref.render();\r\n        const dependencies = ref.deps();\r\n        if (map) {\r\n            return {\r\n                code: result,\r\n                map: merge__default(map, ref.sourcemap),\r\n                errors: [],\r\n                dependencies\r\n            };\r\n        }\r\n        return { code: result, errors: [], dependencies };\r\n    }\r\n    catch (e) {\r\n        return { code: '', errors: [e], dependencies: [] };\r\n    }\r\n};\r\nfunction getSource(source, filename, additionalData) {\r\n    if (!additionalData)\r\n        return source;\r\n    if (shared.isFunction(additionalData)) {\r\n        return additionalData(source, filename);\r\n    }\r\n    return additionalData + source;\r\n}\r\nconst processors = {\r\n    less,\r\n    sass,\r\n    scss,\r\n    styl,\r\n    stylus: styl\r\n};\n\nfunction compileStyle(options) {\r\n    return doCompileStyle({\r\n        ...options,\r\n        isAsync: false\r\n    });\r\n}\r\nfunction compileStyleAsync(options) {\r\n    return doCompileStyle({ ...options, isAsync: true });\r\n}\r\nfunction doCompileStyle(options) {\r\n    const { filename, id, scoped = false, trim = true, isProd = false, modules = false, modulesOptions = {}, preprocessLang, postcssOptions, postcssPlugins } = options;\r\n    const preprocessor = preprocessLang && processors[preprocessLang];\r\n    const preProcessedSource = preprocessor && preprocess$1(options, preprocessor);\r\n    const map = preProcessedSource\r\n        ? preProcessedSource.map\r\n        : options.inMap || options.map;\r\n    const source = preProcessedSource ? preProcessedSource.code : options.source;\r\n    const shortId = id.replace(/^data-v-/, '');\r\n    const longId = `data-v-${shortId}`;\r\n    const plugins = (postcssPlugins || []).slice();\r\n    plugins.unshift(cssVarsPlugin({ id: shortId, isProd }));\r\n    if (trim) {\r\n        plugins.push(trimPlugin());\r\n    }\r\n    if (scoped) {\r\n        plugins.push(scopedPlugin(longId));\r\n    }\r\n    let cssModules;\r\n    if (modules) {\r\n        if (!options.isAsync) {\r\n            throw new Error('[@vue/compiler-sfc] `modules` option can only be used with compileStyleAsync().');\r\n        }\r\n        plugins.push(require('postcss-modules')({\r\n            ...modulesOptions,\r\n            getJSON: (_cssFileName, json) => {\r\n                cssModules = json;\r\n            }\r\n        }));\r\n    }\r\n    const postCSSOptions = {\r\n        ...postcssOptions,\r\n        to: filename,\r\n        from: filename\r\n    };\r\n    if (map) {\r\n        postCSSOptions.map = {\r\n            inline: false,\r\n            annotation: false,\r\n            prev: map\r\n        };\r\n    }\r\n    let result;\r\n    let code;\r\n    let outMap;\r\n    // stylus output include plain css. so need remove the repeat item\r\n    const dependencies = new Set(preProcessedSource ? preProcessedSource.dependencies : []);\r\n    // sass has filename self when provided filename option\r\n    dependencies.delete(filename);\r\n    const errors = [];\r\n    if (preProcessedSource && preProcessedSource.errors.length) {\r\n        errors.push(...preProcessedSource.errors);\r\n    }\r\n    const recordPlainCssDependencies = (messages) => {\r\n        messages.forEach(msg => {\r\n            if (msg.type === 'dependency') {\r\n                // postcss output path is absolute position path\r\n                dependencies.add(msg.file);\r\n            }\r\n        });\r\n        return dependencies;\r\n    };\r\n    try {\r\n        result = postcss__default(plugins).process(source, postCSSOptions);\r\n        // In async mode, return a promise.\r\n        if (options.isAsync) {\r\n            return result\r\n                .then(result => ({\r\n                code: result.css || '',\r\n                map: result.map && result.map.toJSON(),\r\n                errors,\r\n                modules: cssModules,\r\n                rawResult: result,\r\n                dependencies: recordPlainCssDependencies(result.messages)\r\n            }))\r\n                .catch(error => ({\r\n                code: '',\r\n                map: undefined,\r\n                errors: [...errors, error],\r\n                rawResult: undefined,\r\n                dependencies\r\n            }));\r\n        }\r\n        recordPlainCssDependencies(result.messages);\r\n        // force synchronous transform (we know we only have sync plugins)\r\n        code = result.css;\r\n        outMap = result.map;\r\n    }\r\n    catch (e) {\r\n        errors.push(e);\r\n    }\r\n    return {\r\n        code: code || ``,\r\n        map: outMap && outMap.toJSON(),\r\n        errors,\r\n        rawResult: result,\r\n        dependencies\r\n    };\r\n}\r\nfunction preprocess$1(options, preprocessor) {\r\n    return preprocessor(options.source, options.inMap || options.map, {\r\n        filename: options.filename,\r\n        ...options.preprocessOptions\r\n    }, options.preprocessCustomRequire);\r\n}\n\nconst defaultExportRE = /((?:^|\\n|;)\\s*)export(\\s*)default/;\r\nconst namedDefaultExportRE = /((?:^|\\n|;)\\s*)export(.+)as(\\s*)default/;\r\nconst exportDefaultClassRE = /((?:^|\\n|;)\\s*)export\\s+default\\s+class\\s+([\\w$]+)/;\r\n/**\r\n * Utility for rewriting `export default` in a script block into a variable\r\n * declaration so that we can inject things into it\r\n */\r\nfunction rewriteDefault(input, as, parserPlugins) {\r\n    if (!hasDefaultExport(input)) {\r\n        return input + `\\nconst ${as} = {}`;\r\n    }\r\n    let replaced;\r\n    const classMatch = input.match(exportDefaultClassRE);\r\n    if (classMatch) {\r\n        replaced =\r\n            input.replace(exportDefaultClassRE, '$1class $2') +\r\n                `\\nconst ${as} = ${classMatch[2]}`;\r\n    }\r\n    else {\r\n        replaced = input.replace(defaultExportRE, `$1const ${as} =`);\r\n    }\r\n    if (!hasDefaultExport(replaced)) {\r\n        return replaced;\r\n    }\r\n    // if the script somehow still contains `default export`, it probably has\r\n    // multi-line comments or template strings. fallback to a full parse.\r\n    const s = new MagicString__default(input);\r\n    const ast = parser.parse(input, {\r\n        sourceType: 'module',\r\n        plugins: parserPlugins\r\n    }).program.body;\r\n    ast.forEach(node => {\r\n        if (node.type === 'ExportDefaultDeclaration') {\r\n            s.overwrite(node.start, node.declaration.start, `const ${as} = `);\r\n        }\r\n        if (node.type === 'ExportNamedDeclaration') {\r\n            node.specifiers.forEach(specifier => {\r\n                if (specifier.type === 'ExportSpecifier' &&\r\n                    specifier.exported.type === 'Identifier' &&\r\n                    specifier.exported.name === 'default') {\r\n                    const end = specifier.end;\r\n                    s.overwrite(specifier.start, input.charAt(end) === ',' ? end + 1 : end, ``);\r\n                    s.append(`\\nconst ${as} = ${specifier.local.name}`);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return s.toString();\r\n}\r\nfunction hasDefaultExport(input) {\r\n    return defaultExportRE.test(input) || namedDefaultExportRE.test(input);\r\n}\n\nconst DEFINE_PROPS = 'defineProps';\r\nconst DEFINE_EMIT = 'defineEmit';\r\n/**\r\n * Compile `<script setup>`\r\n * It requires the whole SFC descriptor because we need to handle and merge\r\n * normal `<script>` + `<script setup>` if both are present.\r\n */\r\nfunction compileScript(sfc, options) {\r\n    const { script, scriptSetup, source, filename } = sfc;\r\n    if (scriptSetup) {\r\n        warnExperimental(`<script setup>`, 227);\r\n    }\r\n    // for backwards compat\r\n    if (!options) {\r\n        options = { id: '' };\r\n    }\r\n    if (!options.id) {\r\n        warnOnce(`compileScript now requires passing the \\`id\\` option.\\n` +\r\n            `Upgrade your vite or vue-loader version for compatibility with ` +\r\n            `the latest experimental proposals.`);\r\n    }\r\n    const scopeId = options.id ? options.id.replace(/^data-v-/, '') : '';\r\n    const cssVars = sfc.cssVars;\r\n    const hasInheritAttrsFlag = sfc.template && sfc.template.attrs['inherit-attrs'] === 'false';\r\n    const scriptLang = script && script.lang;\r\n    const scriptSetupLang = scriptSetup && scriptSetup.lang;\r\n    const isTS = scriptLang === 'ts' || scriptSetupLang === 'ts';\r\n    const plugins = [...shared.babelParserDefaultPlugins, 'jsx'];\r\n    if (options.babelParserPlugins)\r\n        plugins.push(...options.babelParserPlugins);\r\n    if (isTS)\r\n        plugins.push('typescript', 'decorators-legacy');\r\n    if (!scriptSetup) {\r\n        if (!script) {\r\n            throw new Error(`[@vue/compiler-sfc] SFC contains no <script> tags.`);\r\n        }\r\n        if (scriptLang && scriptLang !== 'ts') {\r\n            // do not process non js/ts script blocks\r\n            return script;\r\n        }\r\n        try {\r\n            const scriptAst = parser.parse(script.content, {\r\n                plugins,\r\n                sourceType: 'module'\r\n            }).program.body;\r\n            const bindings = analyzeScriptBindings(scriptAst);\r\n            const needRewrite = cssVars.length || hasInheritAttrsFlag;\r\n            let content = script.content;\r\n            if (needRewrite) {\r\n                content = rewriteDefault(content, `__default__`, plugins);\r\n                if (cssVars.length) {\r\n                    content += genNormalScriptCssVarsCode(cssVars, bindings, scopeId, !!options.isProd);\r\n                }\r\n                if (hasInheritAttrsFlag) {\r\n                    content += `__default__.inheritAttrs = false`;\r\n                }\r\n                content += `\\nexport default __default__`;\r\n            }\r\n            return {\r\n                ...script,\r\n                content,\r\n                bindings,\r\n                scriptAst\r\n            };\r\n        }\r\n        catch (e) {\r\n            // silently fallback if parse fails since user may be using custom\r\n            // babel syntax\r\n            return script;\r\n        }\r\n    }\r\n    if (script && scriptLang !== scriptSetupLang) {\r\n        throw new Error(`[@vue/compiler-sfc] <script> and <script setup> must have the same language type.`);\r\n    }\r\n    if (scriptSetupLang && scriptSetupLang !== 'ts') {\r\n        // do not process non js/ts script blocks\r\n        return scriptSetup;\r\n    }\r\n    const defaultTempVar = `__default__`;\r\n    const bindingMetadata = {};\r\n    const helperImports = new Set();\r\n    const userImports = Object.create(null);\r\n    const userImportAlias = Object.create(null);\r\n    const setupBindings = Object.create(null);\r\n    const refBindings = Object.create(null);\r\n    const refIdentifiers = new Set();\r\n    const enableRefSugar = options.refSugar !== false;\r\n    let defaultExport;\r\n    let hasDefinePropsCall = false;\r\n    let hasDefineEmitCall = false;\r\n    let propsRuntimeDecl;\r\n    let propsTypeDecl;\r\n    let propsIdentifier;\r\n    let emitRuntimeDecl;\r\n    let emitTypeDecl;\r\n    let emitIdentifier;\r\n    let hasAwait = false;\r\n    let hasInlinedSsrRenderFn = false;\r\n    // props/emits declared via types\r\n    const typeDeclaredProps = {};\r\n    const typeDeclaredEmits = new Set();\r\n    // record declared types for runtime props type generation\r\n    const declaredTypes = {};\r\n    // magic-string state\r\n    const s = new MagicString__default(source);\r\n    const startOffset = scriptSetup.loc.start.offset;\r\n    const endOffset = scriptSetup.loc.end.offset;\r\n    const scriptStartOffset = script && script.loc.start.offset;\r\n    const scriptEndOffset = script && script.loc.end.offset;\r\n    function helper(key) {\r\n        helperImports.add(key);\r\n        return `_${key}`;\r\n    }\r\n    function parse(input, options, offset) {\r\n        try {\r\n            return parser.parse(input, options).program.body;\r\n        }\r\n        catch (e) {\r\n            e.message = `[@vue/compiler-sfc] ${e.message}\\n\\n${sfc.filename}\\n${shared.generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`;\r\n            throw e;\r\n        }\r\n    }\r\n    function error(msg, node, end = node.end + startOffset) {\r\n        throw new Error(`[@vue/compiler-sfc] ${msg}\\n\\n${sfc.filename}\\n${shared.generateCodeFrame(source, node.start + startOffset, end)}`);\r\n    }\r\n    function registerUserImport(source, local, imported, isType) {\r\n        if (source === 'vue' && imported) {\r\n            userImportAlias[imported] = local;\r\n        }\r\n        userImports[local] = {\r\n            isType,\r\n            imported: imported || 'default',\r\n            source\r\n        };\r\n    }\r\n    function processDefineProps(node) {\r\n        if (isCallOf(node, DEFINE_PROPS)) {\r\n            if (hasDefinePropsCall) {\r\n                error(`duplicate ${DEFINE_PROPS}() call`, node);\r\n            }\r\n            hasDefinePropsCall = true;\r\n            propsRuntimeDecl = node.arguments[0];\r\n            // context call has type parameters - infer runtime types from it\r\n            if (node.typeParameters) {\r\n                if (propsRuntimeDecl) {\r\n                    error(`${DEFINE_PROPS}() cannot accept both type and non-type arguments ` +\r\n                        `at the same time. Use one or the other.`, node);\r\n                }\r\n                const typeArg = node.typeParameters.params[0];\r\n                if (typeArg.type === 'TSTypeLiteral') {\r\n                    propsTypeDecl = typeArg;\r\n                }\r\n                else {\r\n                    error(`type argument passed to ${DEFINE_PROPS}() must be a literal type.`, typeArg);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function processDefineEmit(node) {\r\n        if (isCallOf(node, DEFINE_EMIT)) {\r\n            if (hasDefineEmitCall) {\r\n                error(`duplicate ${DEFINE_EMIT}() call`, node);\r\n            }\r\n            hasDefineEmitCall = true;\r\n            emitRuntimeDecl = node.arguments[0];\r\n            if (node.typeParameters) {\r\n                if (emitRuntimeDecl) {\r\n                    error(`${DEFINE_EMIT}() cannot accept both type and non-type arguments ` +\r\n                        `at the same time. Use one or the other.`, node);\r\n                }\r\n                const typeArg = node.typeParameters.params[0];\r\n                if (typeArg.type === 'TSFunctionType' ||\r\n                    typeArg.type === 'TSTypeLiteral') {\r\n                    emitTypeDecl = typeArg;\r\n                }\r\n                else {\r\n                    error(`type argument passed to ${DEFINE_EMIT}() must be a function type ` +\r\n                        `or a literal type with call signatures.`, typeArg);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function checkInvalidScopeReference(node, method) {\r\n        if (!node)\r\n            return;\r\n        walkIdentifiers(node, id => {\r\n            if (setupBindings[id.name]) {\r\n                error(`\\`${method}()\\` in <script setup> cannot reference locally ` +\r\n                    `declared variables because it will be hoisted outside of the ` +\r\n                    `setup() function. If your component options requires initialization ` +\r\n                    `in the module scope, use a separate normal <script> to export ` +\r\n                    `the options instead.`, id);\r\n            }\r\n        });\r\n    }\r\n    function processRefExpression(exp, statement) {\r\n        if (exp.type === 'AssignmentExpression') {\r\n            const { left, right } = exp;\r\n            if (left.type === 'Identifier') {\r\n                registerRefBinding(left);\r\n                s.prependRight(right.start + startOffset, `${helper('ref')}(`);\r\n                s.appendLeft(right.end + startOffset, ')');\r\n            }\r\n            else if (left.type === 'ObjectPattern') {\r\n                // remove wrapping parens\r\n                for (let i = left.start; i > 0; i--) {\r\n                    const char = source[i + startOffset];\r\n                    if (char === '(') {\r\n                        s.remove(i + startOffset, i + startOffset + 1);\r\n                        break;\r\n                    }\r\n                }\r\n                for (let i = left.end; i > 0; i++) {\r\n                    const char = source[i + startOffset];\r\n                    if (char === ')') {\r\n                        s.remove(i + startOffset, i + startOffset + 1);\r\n                        break;\r\n                    }\r\n                }\r\n                processRefObjectPattern(left, statement);\r\n            }\r\n            else if (left.type === 'ArrayPattern') {\r\n                processRefArrayPattern(left, statement);\r\n            }\r\n        }\r\n        else if (exp.type === 'SequenceExpression') {\r\n            // possible multiple declarations\r\n            // ref: x = 1, y = 2\r\n            exp.expressions.forEach(e => processRefExpression(e, statement));\r\n        }\r\n        else if (exp.type === 'Identifier') {\r\n            registerRefBinding(exp);\r\n            s.appendLeft(exp.end + startOffset, ` = ${helper('ref')}()`);\r\n        }\r\n        else {\r\n            error(`ref: statements can only contain assignment expressions.`, exp);\r\n        }\r\n    }\r\n    function registerRefBinding(id) {\r\n        if (id.name[0] === '$') {\r\n            error(`ref variable identifiers cannot start with $.`, id);\r\n        }\r\n        refBindings[id.name] = setupBindings[id.name] = \"setup-ref\" /* SETUP_REF */;\r\n        refIdentifiers.add(id);\r\n    }\r\n    function processRefObjectPattern(pattern, statement) {\r\n        for (const p of pattern.properties) {\r\n            let nameId;\r\n            if (p.type === 'ObjectProperty') {\r\n                if (p.key.start === p.value.start) {\r\n                    // shorthand { foo } --> { foo: __foo }\r\n                    nameId = p.key;\r\n                    s.appendLeft(nameId.end + startOffset, `: __${nameId.name}`);\r\n                    if (p.value.type === 'AssignmentPattern') {\r\n                        // { foo = 1 }\r\n                        refIdentifiers.add(p.value.left);\r\n                    }\r\n                }\r\n                else {\r\n                    if (p.value.type === 'Identifier') {\r\n                        // { foo: bar } --> { foo: __bar }\r\n                        nameId = p.value;\r\n                        s.prependRight(nameId.start + startOffset, `__`);\r\n                    }\r\n                    else if (p.value.type === 'ObjectPattern') {\r\n                        processRefObjectPattern(p.value, statement);\r\n                    }\r\n                    else if (p.value.type === 'ArrayPattern') {\r\n                        processRefArrayPattern(p.value, statement);\r\n                    }\r\n                    else if (p.value.type === 'AssignmentPattern') {\r\n                        // { foo: bar = 1 } --> { foo: __bar = 1 }\r\n                        nameId = p.value.left;\r\n                        s.prependRight(nameId.start + startOffset, `__`);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // rest element { ...foo } --> { ...__foo }\r\n                nameId = p.argument;\r\n                s.prependRight(nameId.start + startOffset, `__`);\r\n            }\r\n            if (nameId) {\r\n                registerRefBinding(nameId);\r\n                // append binding declarations after the parent statement\r\n                s.appendLeft(statement.end + startOffset, `\\nconst ${nameId.name} = ${helper('ref')}(__${nameId.name});`);\r\n            }\r\n        }\r\n    }\r\n    function processRefArrayPattern(pattern, statement) {\r\n        for (const e of pattern.elements) {\r\n            if (!e)\r\n                continue;\r\n            let nameId;\r\n            if (e.type === 'Identifier') {\r\n                // [a] --> [__a]\r\n                nameId = e;\r\n            }\r\n            else if (e.type === 'AssignmentPattern') {\r\n                // [a = 1] --> [__a = 1]\r\n                nameId = e.left;\r\n            }\r\n            else if (e.type === 'RestElement') {\r\n                // [...a] --> [...__a]\r\n                nameId = e.argument;\r\n            }\r\n            else if (e.type === 'ObjectPattern') {\r\n                processRefObjectPattern(e, statement);\r\n            }\r\n            else if (e.type === 'ArrayPattern') {\r\n                processRefArrayPattern(e, statement);\r\n            }\r\n            if (nameId) {\r\n                registerRefBinding(nameId);\r\n                // prefix original\r\n                s.prependRight(nameId.start + startOffset, `__`);\r\n                // append binding declarations after the parent statement\r\n                s.appendLeft(statement.end + startOffset, `\\nconst ${nameId.name} = ${helper('ref')}(__${nameId.name});`);\r\n            }\r\n        }\r\n    }\r\n    // 1. process normal <script> first if it exists\r\n    let scriptAst;\r\n    if (script) {\r\n        // import dedupe between <script> and <script setup>\r\n        scriptAst = parse(script.content, {\r\n            plugins,\r\n            sourceType: 'module'\r\n        }, scriptStartOffset);\r\n        for (const node of scriptAst) {\r\n            if (node.type === 'ImportDeclaration') {\r\n                // record imports for dedupe\r\n                for (const specifier of node.specifiers) {\r\n                    const imported = specifier.type === 'ImportSpecifier' &&\r\n                        specifier.imported.type === 'Identifier' &&\r\n                        specifier.imported.name;\r\n                    registerUserImport(node.source.value, specifier.local.name, imported, node.importKind === 'type');\r\n                }\r\n            }\r\n            else if (node.type === 'ExportDefaultDeclaration') {\r\n                // export default\r\n                defaultExport = node;\r\n                const start = node.start + scriptStartOffset;\r\n                s.overwrite(start, start + `export default`.length, `const ${defaultTempVar} =`);\r\n            }\r\n            else if (node.type === 'ExportNamedDeclaration' && node.specifiers) {\r\n                const defaultSpecifier = node.specifiers.find(s => s.exported.type === 'Identifier' && s.exported.name === 'default');\r\n                if (defaultSpecifier) {\r\n                    defaultExport = node;\r\n                    // 1. remove specifier\r\n                    if (node.specifiers.length > 1) {\r\n                        s.remove(defaultSpecifier.start + scriptStartOffset, defaultSpecifier.end + scriptStartOffset);\r\n                    }\r\n                    else {\r\n                        s.remove(node.start + scriptStartOffset, node.end + scriptStartOffset);\r\n                    }\r\n                    if (node.source) {\r\n                        // export { x as default } from './x'\r\n                        // rewrite to `import { x as __default__ } from './x'` and\r\n                        // add to top\r\n                        s.prepend(`import { ${defaultSpecifier.local.name} as ${defaultTempVar} } from '${node.source.value}'\\n`);\r\n                    }\r\n                    else {\r\n                        // export { x as default }\r\n                        // rewrite to `const __default__ = x` and move to end\r\n                        s.append(`\\nconst ${defaultTempVar} = ${defaultSpecifier.local.name}\\n`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 2. parse <script setup> and  walk over top level statements\r\n    const scriptSetupAst = parse(scriptSetup.content, {\r\n        plugins: [\r\n            ...plugins,\r\n            // allow top level await but only inside <script setup>\r\n            'topLevelAwait'\r\n        ],\r\n        sourceType: 'module'\r\n    }, startOffset);\r\n    for (const node of scriptSetupAst) {\r\n        const start = node.start + startOffset;\r\n        let end = node.end + startOffset;\r\n        // import or type declarations: move to top\r\n        // locate comment\r\n        if (node.trailingComments && node.trailingComments.length > 0) {\r\n            const lastCommentNode = node.trailingComments[node.trailingComments.length - 1];\r\n            end = lastCommentNode.end + startOffset;\r\n        }\r\n        // locate the end of whitespace between this statement and the next\r\n        while (end <= source.length) {\r\n            if (!/\\s/.test(source.charAt(end))) {\r\n                break;\r\n            }\r\n            end++;\r\n        }\r\n        // process `ref: x` bindings (convert to refs)\r\n        if (node.type === 'LabeledStatement' &&\r\n            node.label.name === 'ref' &&\r\n            node.body.type === 'ExpressionStatement') {\r\n            if (enableRefSugar) {\r\n                warnExperimental(`ref: sugar`, 228);\r\n                s.overwrite(node.label.start + startOffset, node.body.start + startOffset, 'const ');\r\n                processRefExpression(node.body.expression, node);\r\n            }\r\n            else {\r\n                // TODO if we end up shipping ref: sugar as an opt-in feature,\r\n                // need to proxy the option in vite, vue-loader and rollup-plugin-vue.\r\n                error(`ref: sugar needs to be explicitly enabled via vite or vue-loader options.`, node);\r\n            }\r\n        }\r\n        if (node.type === 'ImportDeclaration') {\r\n            // import declarations are moved to top\r\n            s.move(start, end, 0);\r\n            // dedupe imports\r\n            let removed = 0;\r\n            const removeSpecifier = (i) => {\r\n                const removeLeft = i > removed;\r\n                removed++;\r\n                const current = node.specifiers[i];\r\n                const next = node.specifiers[i + 1];\r\n                s.remove(removeLeft\r\n                    ? node.specifiers[i - 1].end + startOffset\r\n                    : current.start + startOffset, next && !removeLeft\r\n                    ? next.start + startOffset\r\n                    : current.end + startOffset);\r\n            };\r\n            for (let i = 0; i < node.specifiers.length; i++) {\r\n                const specifier = node.specifiers[i];\r\n                const local = specifier.local.name;\r\n                const imported = specifier.type === 'ImportSpecifier' &&\r\n                    specifier.imported.type === 'Identifier' &&\r\n                    specifier.imported.name;\r\n                const source = node.source.value;\r\n                const existing = userImports[local];\r\n                if (source === 'vue' &&\r\n                    (imported === DEFINE_PROPS || imported === DEFINE_EMIT)) {\r\n                    removeSpecifier(i);\r\n                }\r\n                else if (existing) {\r\n                    if (existing.source === source && existing.imported === imported) {\r\n                        // already imported in <script setup>, dedupe\r\n                        removeSpecifier(i);\r\n                    }\r\n                    else {\r\n                        error(`different imports aliased to same local name.`, specifier);\r\n                    }\r\n                }\r\n                else {\r\n                    registerUserImport(source, local, imported, node.importKind === 'type');\r\n                }\r\n            }\r\n            if (node.specifiers.length && removed === node.specifiers.length) {\r\n                s.remove(node.start + startOffset, node.end + startOffset);\r\n            }\r\n        }\r\n        // process `defineProps` and `defineEmit` calls\r\n        if (node.type === 'ExpressionStatement' &&\r\n            (processDefineProps(node.expression) ||\r\n                processDefineEmit(node.expression))) {\r\n            s.remove(node.start + startOffset, node.end + startOffset);\r\n        }\r\n        if (node.type === 'VariableDeclaration' && !node.declare) {\r\n            for (const decl of node.declarations) {\r\n                if (decl.init) {\r\n                    const isDefineProps = processDefineProps(decl.init);\r\n                    if (isDefineProps) {\r\n                        propsIdentifier = scriptSetup.content.slice(decl.id.start, decl.id.end);\r\n                    }\r\n                    const isDefineEmit = processDefineEmit(decl.init);\r\n                    if (isDefineEmit) {\r\n                        emitIdentifier = scriptSetup.content.slice(decl.id.start, decl.id.end);\r\n                    }\r\n                    if (isDefineProps || isDefineEmit)\r\n                        if (node.declarations.length === 1) {\r\n                            s.remove(node.start + startOffset, node.end + startOffset);\r\n                        }\r\n                        else {\r\n                            s.remove(decl.start + startOffset, decl.end + startOffset);\r\n                        }\r\n                }\r\n            }\r\n        }\r\n        // walk decalrations to record declared bindings\r\n        if ((node.type === 'VariableDeclaration' ||\r\n            node.type === 'FunctionDeclaration' ||\r\n            node.type === 'ClassDeclaration') &&\r\n            !node.declare) {\r\n            walkDeclaration(node, setupBindings, userImportAlias);\r\n        }\r\n        // Type declarations\r\n        if (node.type === 'VariableDeclaration' && node.declare) {\r\n            s.remove(start, end);\r\n        }\r\n        // move all type declarations to outer scope\r\n        if (node.type.startsWith('TS') ||\r\n            (node.type === 'ExportNamedDeclaration' && node.exportKind === 'type')) {\r\n            recordType(node, declaredTypes);\r\n            s.move(start, end, 0);\r\n        }\r\n        // walk statements & named exports / variable declarations for top level\r\n        // await\r\n        if ((node.type === 'VariableDeclaration' && !node.declare) ||\r\n            node.type.endsWith('Statement')) {\r\n            estreeWalker.walk(node, {\r\n                enter(node) {\r\n                    if (isFunction(node)) {\r\n                        this.skip();\r\n                    }\r\n                    if (node.type === 'AwaitExpression') {\r\n                        hasAwait = true;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if ((node.type === 'ExportNamedDeclaration' && node.exportKind !== 'type') ||\r\n            node.type === 'ExportAllDeclaration' ||\r\n            node.type === 'ExportDefaultDeclaration') {\r\n            error(`<script setup> cannot contain ES module exports. ` +\r\n                `If you are using a previous version of <script setup>, please ` +\r\n                `consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`, node);\r\n        }\r\n    }\r\n    // 3. Do a full walk to rewrite identifiers referencing let exports with ref\r\n    // value access\r\n    if (enableRefSugar && Object.keys(refBindings).length) {\r\n        for (const node of scriptSetupAst) {\r\n            if (node.type !== 'ImportDeclaration') {\r\n                walkIdentifiers(node, (id, parent, parentStack) => {\r\n                    if (refBindings[id.name] && !refIdentifiers.has(id)) {\r\n                        if (isStaticProperty(parent) && parent.shorthand) {\r\n                            // let binding used in a property shorthand\r\n                            // { foo } -> { foo: foo.value }\r\n                            // skip for destructure patterns\r\n                            if (!parent.inPattern ||\r\n                                isInDestructureAssignment(parent, parentStack)) {\r\n                                s.appendLeft(id.end + startOffset, `: ${id.name}.value`);\r\n                            }\r\n                        }\r\n                        else {\r\n                            s.appendLeft(id.end + startOffset, '.value');\r\n                        }\r\n                    }\r\n                    else if (id.name[0] === '$' && refBindings[id.name.slice(1)]) {\r\n                        // $xxx raw ref access variables, remove the $ prefix\r\n                        s.remove(id.start + startOffset, id.start + startOffset + 1);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // 4. extract runtime props/emits code from setup context type\r\n    if (propsTypeDecl) {\r\n        extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes);\r\n    }\r\n    if (emitTypeDecl) {\r\n        extractRuntimeEmits(emitTypeDecl, typeDeclaredEmits);\r\n    }\r\n    // 5. check useOptions args to make sure it doesn't reference setup scope\r\n    // variables\r\n    checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS);\r\n    checkInvalidScopeReference(emitRuntimeDecl, DEFINE_PROPS);\r\n    // 6. remove non-script content\r\n    if (script) {\r\n        if (startOffset < scriptStartOffset) {\r\n            // <script setup> before <script>\r\n            s.remove(0, startOffset);\r\n            s.remove(endOffset, scriptStartOffset);\r\n            s.remove(scriptEndOffset, source.length);\r\n        }\r\n        else {\r\n            // <script> before <script setup>\r\n            s.remove(0, scriptStartOffset);\r\n            s.remove(scriptEndOffset, startOffset);\r\n            s.remove(endOffset, source.length);\r\n        }\r\n    }\r\n    else {\r\n        // only <script setup>\r\n        s.remove(0, startOffset);\r\n        s.remove(endOffset, source.length);\r\n    }\r\n    // 7. analyze binding metadata\r\n    if (scriptAst) {\r\n        Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst));\r\n    }\r\n    if (propsRuntimeDecl) {\r\n        for (const key of getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {\r\n            bindingMetadata[key] = \"props\" /* PROPS */;\r\n        }\r\n    }\r\n    for (const key in typeDeclaredProps) {\r\n        bindingMetadata[key] = \"props\" /* PROPS */;\r\n    }\r\n    for (const [key, { isType, imported, source }] of Object.entries(userImports)) {\r\n        if (isType)\r\n            continue;\r\n        bindingMetadata[key] =\r\n            (imported === 'default' && source.endsWith('.vue')) || source === 'vue'\r\n                ? \"setup-const\" /* SETUP_CONST */\r\n                : \"setup-maybe-ref\" /* SETUP_MAYBE_REF */;\r\n    }\r\n    for (const key in setupBindings) {\r\n        bindingMetadata[key] = setupBindings[key];\r\n    }\r\n    // 8. inject `useCssVars` calls\r\n    if (cssVars.length) {\r\n        helperImports.add(CSS_VARS_HELPER);\r\n        helperImports.add('unref');\r\n        s.prependRight(startOffset, `\\n${genCssVarsCode(cssVars, bindingMetadata, scopeId, !!options.isProd)}\\n`);\r\n    }\r\n    // 9. finalize setup() argument signature\r\n    let args = `__props`;\r\n    if (propsTypeDecl) {\r\n        args += `: ${scriptSetup.content.slice(propsTypeDecl.start, propsTypeDecl.end)}`;\r\n    }\r\n    // inject user assignment of props\r\n    // we use a default __props so that template expressions referencing props\r\n    // can use it directly\r\n    if (propsIdentifier) {\r\n        s.prependRight(startOffset, `\\nconst ${propsIdentifier} = __props`);\r\n    }\r\n    if (emitIdentifier) {\r\n        args +=\r\n            emitIdentifier === `emit` ? `, { emit }` : `, { emit: ${emitIdentifier} }`;\r\n        if (emitTypeDecl) {\r\n            args += `: {\n        emit: (${scriptSetup.content.slice(emitTypeDecl.start, emitTypeDecl.end)}),\n        slots: any,\n        attrs: any\n      }`;\r\n        }\r\n    }\r\n    // 10. generate return statement\r\n    let returned;\r\n    if (options.inlineTemplate) {\r\n        if (sfc.template && !sfc.template.src) {\r\n            if (options.templateOptions && options.templateOptions.ssr) {\r\n                hasInlinedSsrRenderFn = true;\r\n            }\r\n            // inline render function mode - we are going to compile the template and\r\n            // inline it right here\r\n            const { code, ast, preamble, tips, errors } = compileTemplate({\r\n                filename,\r\n                source: sfc.template.content,\r\n                inMap: sfc.template.map,\r\n                ...options.templateOptions,\r\n                id: scopeId,\r\n                scoped: sfc.styles.some(s => s.scoped),\r\n                isProd: options.isProd,\r\n                ssrCssVars: sfc.cssVars,\r\n                compilerOptions: {\r\n                    ...(options.templateOptions &&\r\n                        options.templateOptions.compilerOptions),\r\n                    inline: true,\r\n                    isTS,\r\n                    bindingMetadata\r\n                }\r\n            });\r\n            if (tips.length) {\r\n                tips.forEach(warnOnce);\r\n            }\r\n            const err = errors[0];\r\n            if (typeof err === 'string') {\r\n                throw new Error(err);\r\n            }\r\n            else if (err) {\r\n                if (err.loc) {\r\n                    err.message +=\r\n                        `\\n\\n` +\r\n                            sfc.filename +\r\n                            '\\n' +\r\n                            shared.generateCodeFrame(source, err.loc.start.offset, err.loc.end.offset) +\r\n                            `\\n`;\r\n                }\r\n                throw err;\r\n            }\r\n            if (preamble) {\r\n                s.prepend(preamble);\r\n            }\r\n            // avoid duplicated unref import\r\n            // as this may get injected by the render function preamble OR the\r\n            // css vars codegen\r\n            if (ast && ast.helpers.includes(compilerCore.UNREF)) {\r\n                helperImports.delete('unref');\r\n            }\r\n            returned = code;\r\n        }\r\n        else {\r\n            returned = `() => {}`;\r\n        }\r\n    }\r\n    else {\r\n        // return bindings from setup\r\n        const allBindings = { ...setupBindings };\r\n        for (const key in userImports) {\r\n            if (!userImports[key].isType) {\r\n                allBindings[key] = true;\r\n            }\r\n        }\r\n        returned = `{ ${Object.keys(allBindings).join(', ')} }`;\r\n    }\r\n    s.appendRight(endOffset, `\\nreturn ${returned}\\n}\\n\\n`);\r\n    // 11. finalize default export\r\n    // expose: [] makes <script setup> components \"closed\" by default.\r\n    let runtimeOptions = `\\n  expose: [],`;\r\n    if (hasInheritAttrsFlag) {\r\n        runtimeOptions += `\\n  inheritAttrs: false,`;\r\n    }\r\n    if (hasInlinedSsrRenderFn) {\r\n        runtimeOptions += `\\n  __ssrInlineRender: true,`;\r\n    }\r\n    if (propsRuntimeDecl) {\r\n        runtimeOptions += `\\n  props: ${scriptSetup.content\r\n            .slice(propsRuntimeDecl.start, propsRuntimeDecl.end)\r\n            .trim()},`;\r\n    }\r\n    else if (propsTypeDecl) {\r\n        runtimeOptions += genRuntimeProps(typeDeclaredProps);\r\n    }\r\n    if (emitRuntimeDecl) {\r\n        runtimeOptions += `\\n  emits: ${scriptSetup.content\r\n            .slice(emitRuntimeDecl.start, emitRuntimeDecl.end)\r\n            .trim()},`;\r\n    }\r\n    else if (emitTypeDecl) {\r\n        runtimeOptions += genRuntimeEmits(typeDeclaredEmits);\r\n    }\r\n    if (isTS) {\r\n        // for TS, make sure the exported type is still valid type with\r\n        // correct props information\r\n        // we have to use object spread for types to be merged properly\r\n        // user's TS setting should compile it down to proper targets\r\n        const def = defaultExport ? `\\n  ...${defaultTempVar},` : ``;\r\n        // wrap setup code with function.\r\n        // export the content of <script setup> as a named export, `setup`.\r\n        // this allows `import { setup } from '*.vue'` for testing purposes.\r\n        s.prependLeft(startOffset, `\\nexport default ${helper(`defineComponent`)}({${def}${runtimeOptions}\\n  ${hasAwait ? `async ` : ``}setup(${args}) {\\n`);\r\n        s.appendRight(endOffset, `})`);\r\n    }\r\n    else {\r\n        if (defaultExport) {\r\n            // can't rely on spread operator in non ts mode\r\n            s.prependLeft(startOffset, `\\n${hasAwait ? `async ` : ``}function setup(${args}) {\\n`);\r\n            s.append(`\\nexport default /*#__PURE__*/ Object.assign(${defaultTempVar}, {${runtimeOptions}\\n  setup\\n})\\n`);\r\n        }\r\n        else {\r\n            s.prependLeft(startOffset, `\\nexport default {${runtimeOptions}\\n  ` +\r\n                `${hasAwait ? `async ` : ``}setup(${args}) {\\n`);\r\n            s.appendRight(endOffset, `}`);\r\n        }\r\n    }\r\n    // 12. finalize Vue helper imports\r\n    if (helperImports.size > 0) {\r\n        s.prepend(`import { ${[...helperImports]\r\n            .map(h => `${h} as _${h}`)\r\n            .join(', ')} } from 'vue'\\n`);\r\n    }\r\n    s.trim();\r\n    return {\r\n        ...scriptSetup,\r\n        bindings: bindingMetadata,\r\n        content: s.toString(),\r\n        map: s.generateMap({\r\n            source: filename,\r\n            hires: true,\r\n            includeContent: true\r\n        }),\r\n        scriptAst,\r\n        scriptSetupAst\r\n    };\r\n}\r\nfunction walkDeclaration(node, bindings, userImportAlias) {\r\n    if (node.type === 'VariableDeclaration') {\r\n        const isConst = node.kind === 'const';\r\n        // export const foo = ...\r\n        for (const { id, init } of node.declarations) {\r\n            const isDefineCall = !!(isConst &&\r\n                (isCallOf(init, DEFINE_PROPS) || isCallOf(init, DEFINE_EMIT)));\r\n            if (id.type === 'Identifier') {\r\n                let bindingType;\r\n                const userReactiveBinding = userImportAlias['reactive'] || 'reactive';\r\n                if (isCallOf(init, userReactiveBinding)) {\r\n                    // treat reactive() calls as let since it's meant to be mutable\r\n                    bindingType = \"setup-let\" /* SETUP_LET */;\r\n                }\r\n                else if (\r\n                // if a declaration is a const literal, we can mark it so that\r\n                // the generated render fn code doesn't need to unref() it\r\n                isDefineCall ||\r\n                    (isConst && canNeverBeRef(init, userReactiveBinding))) {\r\n                    bindingType = \"setup-const\" /* SETUP_CONST */;\r\n                }\r\n                else if (isConst) {\r\n                    if (isCallOf(init, userImportAlias['ref'] || 'ref')) {\r\n                        bindingType = \"setup-ref\" /* SETUP_REF */;\r\n                    }\r\n                    else {\r\n                        bindingType = \"setup-maybe-ref\" /* SETUP_MAYBE_REF */;\r\n                    }\r\n                }\r\n                else {\r\n                    bindingType = \"setup-let\" /* SETUP_LET */;\r\n                }\r\n                bindings[id.name] = bindingType;\r\n            }\r\n            else if (id.type === 'ObjectPattern') {\r\n                walkObjectPattern(id, bindings, isConst, isDefineCall);\r\n            }\r\n            else if (id.type === 'ArrayPattern') {\r\n                walkArrayPattern(id, bindings, isConst, isDefineCall);\r\n            }\r\n        }\r\n    }\r\n    else if (node.type === 'FunctionDeclaration' ||\r\n        node.type === 'ClassDeclaration') {\r\n        // export function foo() {} / export class Foo {}\r\n        // export declarations must be named.\r\n        bindings[node.id.name] = \"setup-const\" /* SETUP_CONST */;\r\n    }\r\n}\r\nfunction walkObjectPattern(node, bindings, isConst, isDefineCall = false) {\r\n    for (const p of node.properties) {\r\n        if (p.type === 'ObjectProperty') {\r\n            // key can only be Identifier in ObjectPattern\r\n            if (p.key.type === 'Identifier') {\r\n                if (p.key === p.value) {\r\n                    // const { x } = ...\r\n                    bindings[p.key.name] = isDefineCall\r\n                        ? \"setup-const\" /* SETUP_CONST */\r\n                        : isConst\r\n                            ? \"setup-maybe-ref\" /* SETUP_MAYBE_REF */\r\n                            : \"setup-let\" /* SETUP_LET */;\r\n                }\r\n                else {\r\n                    walkPattern(p.value, bindings, isConst, isDefineCall);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // ...rest\r\n            // argument can only be identifer when destructuring\r\n            bindings[p.argument.name] = isConst\r\n                ? \"setup-const\" /* SETUP_CONST */\r\n                : \"setup-let\" /* SETUP_LET */;\r\n        }\r\n    }\r\n}\r\nfunction walkArrayPattern(node, bindings, isConst, isDefineCall = false) {\r\n    for (const e of node.elements) {\r\n        e && walkPattern(e, bindings, isConst, isDefineCall);\r\n    }\r\n}\r\nfunction walkPattern(node, bindings, isConst, isDefineCall = false) {\r\n    if (node.type === 'Identifier') {\r\n        bindings[node.name] = isDefineCall\r\n            ? \"setup-const\" /* SETUP_CONST */\r\n            : isConst\r\n                ? \"setup-maybe-ref\" /* SETUP_MAYBE_REF */\r\n                : \"setup-let\" /* SETUP_LET */;\r\n    }\r\n    else if (node.type === 'RestElement') {\r\n        // argument can only be identifer when destructuring\r\n        bindings[node.argument.name] = isConst\r\n            ? \"setup-const\" /* SETUP_CONST */\r\n            : \"setup-let\" /* SETUP_LET */;\r\n    }\r\n    else if (node.type === 'ObjectPattern') {\r\n        walkObjectPattern(node, bindings, isConst);\r\n    }\r\n    else if (node.type === 'ArrayPattern') {\r\n        walkArrayPattern(node, bindings, isConst);\r\n    }\r\n    else if (node.type === 'AssignmentPattern') {\r\n        if (node.left.type === 'Identifier') {\r\n            bindings[node.left.name] = isDefineCall\r\n                ? \"setup-const\" /* SETUP_CONST */\r\n                : isConst\r\n                    ? \"setup-maybe-ref\" /* SETUP_MAYBE_REF */\r\n                    : \"setup-let\" /* SETUP_LET */;\r\n        }\r\n        else {\r\n            walkPattern(node.left, bindings, isConst);\r\n        }\r\n    }\r\n}\r\nfunction recordType(node, declaredTypes) {\r\n    if (node.type === 'TSInterfaceDeclaration') {\r\n        declaredTypes[node.id.name] = [`Object`];\r\n    }\r\n    else if (node.type === 'TSTypeAliasDeclaration') {\r\n        declaredTypes[node.id.name] = inferRuntimeType(node.typeAnnotation, declaredTypes);\r\n    }\r\n    else if (node.type === 'ExportNamedDeclaration' && node.declaration) {\r\n        recordType(node.declaration, declaredTypes);\r\n    }\r\n}\r\nfunction extractRuntimeProps(node, props, declaredTypes) {\r\n    for (const m of node.members) {\r\n        if (m.type === 'TSPropertySignature' && m.key.type === 'Identifier') {\r\n            props[m.key.name] = {\r\n                key: m.key.name,\r\n                required: !m.optional,\r\n                type: m.typeAnnotation\r\n                    ? inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes)\r\n                    : [`null`]\r\n            };\r\n        }\r\n    }\r\n}\r\nfunction inferRuntimeType(node, declaredTypes) {\r\n    switch (node.type) {\r\n        case 'TSStringKeyword':\r\n            return ['String'];\r\n        case 'TSNumberKeyword':\r\n            return ['Number'];\r\n        case 'TSBooleanKeyword':\r\n            return ['Boolean'];\r\n        case 'TSObjectKeyword':\r\n            return ['Object'];\r\n        case 'TSTypeLiteral':\r\n            // TODO (nice to have) generate runtime property validation\r\n            return ['Object'];\r\n        case 'TSFunctionType':\r\n            return ['Function'];\r\n        case 'TSArrayType':\r\n        case 'TSTupleType':\r\n            // TODO (nice to have) generate runtime element type/length checks\r\n            return ['Array'];\r\n        case 'TSLiteralType':\r\n            switch (node.literal.type) {\r\n                case 'StringLiteral':\r\n                    return ['String'];\r\n                case 'BooleanLiteral':\r\n                    return ['Boolean'];\r\n                case 'NumericLiteral':\r\n                case 'BigIntLiteral':\r\n                    return ['Number'];\r\n                default:\r\n                    return [`null`];\r\n            }\r\n        case 'TSTypeReference':\r\n            if (node.typeName.type === 'Identifier') {\r\n                if (declaredTypes[node.typeName.name]) {\r\n                    return declaredTypes[node.typeName.name];\r\n                }\r\n                switch (node.typeName.name) {\r\n                    case 'Array':\r\n                    case 'Function':\r\n                    case 'Object':\r\n                    case 'Set':\r\n                    case 'Map':\r\n                    case 'WeakSet':\r\n                    case 'WeakMap':\r\n                        return [node.typeName.name];\r\n                    case 'Record':\r\n                    case 'Partial':\r\n                    case 'Readonly':\r\n                    case 'Pick':\r\n                    case 'Omit':\r\n                    case 'Exclude':\r\n                    case 'Extract':\r\n                    case 'Required':\r\n                    case 'InstanceType':\r\n                        return ['Object'];\r\n                }\r\n            }\r\n            return [`null`];\r\n        case 'TSUnionType':\r\n            return [\r\n                ...new Set([].concat(node.types.map(t => inferRuntimeType(t, declaredTypes))))\r\n            ];\r\n        case 'TSIntersectionType':\r\n            return ['Object'];\r\n        default:\r\n            return [`null`]; // no runtime check\r\n    }\r\n}\r\nfunction genRuntimeProps(props) {\r\n    const keys = Object.keys(props);\r\n    if (!keys.length) {\r\n        return ``;\r\n    }\r\n    return `\\n  props: {\\n    ${keys\r\n        .map(key => {\r\n        const { type, required } = props[key];\r\n        return `${key}: { type: ${toRuntimeTypeString(type)}, required: ${required} }`;\r\n    })\r\n        .join(',\\n    ')}\\n  } as unknown as undefined,`;\r\n}\r\nfunction toRuntimeTypeString(types) {\r\n    return types.some(t => t === 'null')\r\n        ? `null`\r\n        : types.length > 1\r\n            ? `[${types.join(', ')}]`\r\n            : types[0];\r\n}\r\nfunction extractRuntimeEmits(node, emits) {\r\n    if (node.type === 'TSTypeLiteral') {\r\n        for (let t of node.members) {\r\n            if (t.type === 'TSCallSignatureDeclaration') {\r\n                extractEventNames(t.parameters[0], emits);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    else {\r\n        extractEventNames(node.parameters[0], emits);\r\n    }\r\n}\r\nfunction extractEventNames(eventName, emits) {\r\n    if (eventName.type === 'Identifier' &&\r\n        eventName.typeAnnotation &&\r\n        eventName.typeAnnotation.type === 'TSTypeAnnotation') {\r\n        const typeNode = eventName.typeAnnotation.typeAnnotation;\r\n        if (typeNode.type === 'TSLiteralType') {\r\n            emits.add(String(typeNode.literal.value));\r\n        }\r\n        else if (typeNode.type === 'TSUnionType') {\r\n            for (const t of typeNode.types) {\r\n                if (t.type === 'TSLiteralType') {\r\n                    emits.add(String(t.literal.value));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction genRuntimeEmits(emits) {\r\n    return emits.size\r\n        ? `\\n  emits: [${Array.from(emits)\r\n            .map(p => JSON.stringify(p))\r\n            .join(', ')}] as unknown as undefined,`\r\n        : ``;\r\n}\r\nfunction markScopeIdentifier(node, child, knownIds) {\r\n    const { name } = child;\r\n    if (node.scopeIds && node.scopeIds.has(name)) {\r\n        return;\r\n    }\r\n    if (name in knownIds) {\r\n        knownIds[name]++;\r\n    }\r\n    else {\r\n        knownIds[name] = 1;\r\n    }\r\n    (node.scopeIds || (node.scopeIds = new Set())).add(name);\r\n}\r\n/**\r\n * Walk an AST and find identifiers that are variable references.\r\n * This is largely the same logic with `transformExpressions` in compiler-core\r\n * but with some subtle differences as this needs to handle a wider range of\r\n * possible syntax.\r\n */\r\nfunction walkIdentifiers(root, onIdentifier) {\r\n    const parentStack = [];\r\n    const knownIds = Object.create(null);\r\n    estreeWalker.walk(root, {\r\n        enter(node, parent) {\r\n            parent && parentStack.push(parent);\r\n            if (node.type === 'Identifier') {\r\n                if (!knownIds[node.name] &&\r\n                    isRefIdentifier(node, parent, parentStack)) {\r\n                    onIdentifier(node, parent, parentStack);\r\n                }\r\n            }\r\n            else if (isFunction(node)) {\r\n                // #3445\r\n                // should not rewrite local variables sharing a name with a top-level ref\r\n                if (node.body.type === 'BlockStatement') {\r\n                    node.body.body.forEach(p => {\r\n                        if (p.type === 'VariableDeclaration') {\r\n                            for (const decl of p.declarations) {\r\n                                extractIdentifiers(decl.id).forEach(id => {\r\n                                    markScopeIdentifier(node, id, knownIds);\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                // walk function expressions and add its arguments to known identifiers\r\n                // so that we don't prefix them\r\n                node.params.forEach(p => estreeWalker.walk(p, {\r\n                    enter(child, parent) {\r\n                        if (child.type === 'Identifier' &&\r\n                            // do not record as scope variable if is a destructured key\r\n                            !isStaticPropertyKey(child, parent) &&\r\n                            // do not record if this is a default value\r\n                            // assignment of a destructured variable\r\n                            !(parent &&\r\n                                parent.type === 'AssignmentPattern' &&\r\n                                parent.right === child)) {\r\n                            markScopeIdentifier(node, child, knownIds);\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n            else if (node.type === 'ObjectProperty' &&\r\n                parent.type === 'ObjectPattern') {\r\n                node.inPattern = true;\r\n            }\r\n        },\r\n        leave(node, parent) {\r\n            parent && parentStack.pop();\r\n            if (node.scopeIds) {\r\n                node.scopeIds.forEach((id) => {\r\n                    knownIds[id]--;\r\n                    if (knownIds[id] === 0) {\r\n                        delete knownIds[id];\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction isRefIdentifier(id, parent, parentStack) {\r\n    // declaration id\r\n    if ((parent.type === 'VariableDeclarator' ||\r\n        parent.type === 'ClassDeclaration') &&\r\n        parent.id === id) {\r\n        return false;\r\n    }\r\n    if (isFunction(parent)) {\r\n        // function decalration/expression id\r\n        if (parent.id === id) {\r\n            return false;\r\n        }\r\n        // params list\r\n        if (parent.params.includes(id)) {\r\n            return false;\r\n        }\r\n    }\r\n    // property key\r\n    // this also covers object destructure pattern\r\n    if (isStaticPropertyKey(id, parent)) {\r\n        return false;\r\n    }\r\n    // non-assignment array destructure pattern\r\n    if (parent.type === 'ArrayPattern' &&\r\n        !isInDestructureAssignment(parent, parentStack)) {\r\n        return false;\r\n    }\r\n    // member expression property\r\n    if ((parent.type === 'MemberExpression' ||\r\n        parent.type === 'OptionalMemberExpression') &&\r\n        parent.property === id &&\r\n        !parent.computed) {\r\n        return false;\r\n    }\r\n    // is a special keyword but parsed as identifier\r\n    if (id.name === 'arguments') {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nconst isStaticProperty = (node) => node &&\r\n    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\r\n    !node.computed;\r\nconst isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;\r\nfunction isFunction(node) {\r\n    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);\r\n}\r\nfunction isCallOf(node, name) {\r\n    return !!(node &&\r\n        node.type === 'CallExpression' &&\r\n        node.callee.type === 'Identifier' &&\r\n        node.callee.name === name);\r\n}\r\nfunction canNeverBeRef(node, userReactiveImport) {\r\n    if (isCallOf(node, userReactiveImport)) {\r\n        return true;\r\n    }\r\n    switch (node.type) {\r\n        case 'UnaryExpression':\r\n        case 'BinaryExpression':\r\n        case 'ArrayExpression':\r\n        case 'ObjectExpression':\r\n        case 'FunctionExpression':\r\n        case 'ArrowFunctionExpression':\r\n        case 'UpdateExpression':\r\n        case 'ClassExpression':\r\n        case 'TaggedTemplateExpression':\r\n            return true;\r\n        case 'SequenceExpression':\r\n            return canNeverBeRef(node.expressions[node.expressions.length - 1], userReactiveImport);\r\n        default:\r\n            if (node.type.endsWith('Literal')) {\r\n                return true;\r\n            }\r\n            return false;\r\n    }\r\n}\r\nfunction isInDestructureAssignment(parent, parentStack) {\r\n    if (parent &&\r\n        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {\r\n        let i = parentStack.length;\r\n        while (i--) {\r\n            const p = parentStack[i];\r\n            if (p.type === 'AssignmentExpression') {\r\n                const root = parentStack[0];\r\n                // if this is a ref: destructure, it should be treated like a\r\n                // variable decalration!\r\n                return !(root.type === 'LabeledStatement' && root.label.name === 'ref');\r\n            }\r\n            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Analyze bindings in normal `<script>`\r\n * Note that `compileScriptSetup` already analyzes bindings as part of its\r\n * compilation process so this should only be used on single `<script>` SFCs.\r\n */\r\nfunction analyzeScriptBindings(ast) {\r\n    for (const node of ast) {\r\n        if (node.type === 'ExportDefaultDeclaration' &&\r\n            node.declaration.type === 'ObjectExpression') {\r\n            return analyzeBindingsFromOptions(node.declaration);\r\n        }\r\n    }\r\n    return {};\r\n}\r\nfunction analyzeBindingsFromOptions(node) {\r\n    const bindings = {};\r\n    // #3270, #3275\r\n    // mark non-script-setup so we don't resolve components/directives from these\r\n    Object.defineProperty(bindings, '__isScriptSetup', {\r\n        enumerable: false,\r\n        value: false\r\n    });\r\n    for (const property of node.properties) {\r\n        if (property.type === 'ObjectProperty' &&\r\n            !property.computed &&\r\n            property.key.type === 'Identifier') {\r\n            // props\r\n            if (property.key.name === 'props') {\r\n                // props: ['foo']\r\n                // props: { foo: ... }\r\n                for (const key of getObjectOrArrayExpressionKeys(property.value)) {\r\n                    bindings[key] = \"props\" /* PROPS */;\r\n                }\r\n            }\r\n            // inject\r\n            else if (property.key.name === 'inject') {\r\n                // inject: ['foo']\r\n                // inject: { foo: {} }\r\n                for (const key of getObjectOrArrayExpressionKeys(property.value)) {\r\n                    bindings[key] = \"options\" /* OPTIONS */;\r\n                }\r\n            }\r\n            // computed & methods\r\n            else if (property.value.type === 'ObjectExpression' &&\r\n                (property.key.name === 'computed' || property.key.name === 'methods')) {\r\n                // methods: { foo() {} }\r\n                // computed: { foo() {} }\r\n                for (const key of getObjectExpressionKeys(property.value)) {\r\n                    bindings[key] = \"options\" /* OPTIONS */;\r\n                }\r\n            }\r\n        }\r\n        // setup & data\r\n        else if (property.type === 'ObjectMethod' &&\r\n            property.key.type === 'Identifier' &&\r\n            (property.key.name === 'setup' || property.key.name === 'data')) {\r\n            for (const bodyItem of property.body.body) {\r\n                // setup() {\r\n                //   return {\r\n                //     foo: null\r\n                //   }\r\n                // }\r\n                if (bodyItem.type === 'ReturnStatement' &&\r\n                    bodyItem.argument &&\r\n                    bodyItem.argument.type === 'ObjectExpression') {\r\n                    for (const key of getObjectExpressionKeys(bodyItem.argument)) {\r\n                        bindings[key] =\r\n                            property.key.name === 'setup'\r\n                                ? \"setup-maybe-ref\" /* SETUP_MAYBE_REF */\r\n                                : \"data\" /* DATA */;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return bindings;\r\n}\r\nfunction getObjectExpressionKeys(node) {\r\n    const keys = [];\r\n    for (const prop of node.properties) {\r\n        if ((prop.type === 'ObjectProperty' || prop.type === 'ObjectMethod') &&\r\n            !prop.computed) {\r\n            if (prop.key.type === 'Identifier') {\r\n                keys.push(prop.key.name);\r\n            }\r\n            else if (prop.key.type === 'StringLiteral') {\r\n                keys.push(prop.key.value);\r\n            }\r\n        }\r\n    }\r\n    return keys;\r\n}\r\nfunction getArrayExpressionKeys(node) {\r\n    const keys = [];\r\n    for (const element of node.elements) {\r\n        if (element && element.type === 'StringLiteral') {\r\n            keys.push(element.value);\r\n        }\r\n    }\r\n    return keys;\r\n}\r\nfunction getObjectOrArrayExpressionKeys(value) {\r\n    if (value.type === 'ArrayExpression') {\r\n        return getArrayExpressionKeys(value);\r\n    }\r\n    if (value.type === 'ObjectExpression') {\r\n        return getObjectExpressionKeys(value);\r\n    }\r\n    return [];\r\n}\r\nfunction extractIdentifiers(param, nodes = []) {\r\n    switch (param.type) {\r\n        case 'Identifier':\r\n            nodes.push(param);\r\n            break;\r\n        case 'MemberExpression':\r\n            let object = param;\r\n            while (object.type === 'MemberExpression') {\r\n                object = object.object;\r\n            }\r\n            nodes.push(object);\r\n            break;\r\n        case 'ObjectPattern':\r\n            param.properties.forEach(prop => {\r\n                if (prop.type === 'RestElement') {\r\n                    extractIdentifiers(prop.argument, nodes);\r\n                }\r\n                else {\r\n                    extractIdentifiers(prop.value, nodes);\r\n                }\r\n            });\r\n            break;\r\n        case 'ArrayPattern':\r\n            param.elements.forEach(element => {\r\n                if (element)\r\n                    extractIdentifiers(element, nodes);\r\n            });\r\n            break;\r\n        case 'RestElement':\r\n            extractIdentifiers(param.argument, nodes);\r\n            break;\r\n        case 'AssignmentPattern':\r\n            extractIdentifiers(param.left, nodes);\r\n            break;\r\n    }\r\n    return nodes;\r\n}\n\nexports.generateCodeFrame = compilerCore.generateCodeFrame;\nexports.MagicString = MagicString__default;\nexports.babelParse = parser.parse;\nexports.walk = estreeWalker.walk;\nexports.compileScript = compileScript;\nexports.compileStyle = compileStyle;\nexports.compileStyleAsync = compileStyleAsync;\nexports.compileTemplate = compileTemplate;\nexports.parse = parse;\nexports.rewriteDefault = rewriteDefault;\nexports.walkIdentifiers = walkIdentifiers;\n"],"names":[],"mappings":";;;;AA2CA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}