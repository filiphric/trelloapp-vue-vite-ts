import { findDir, isSimpleIdentifier, createCompoundExpression, createSimpleExpression, findProp, RENDER_SLOT, buildSlots, createFunctionExpression, createBlockStatement, WITH_CTX, createStructuralDirectiveTransform, processFor, createCallExpression, RENDER_LIST, createForLoopParams, processIf, baseParse, transform, OPEN_BLOCK, CREATE_BLOCK, CREATE_VNODE, FRAGMENT, generate } from '@vue/compiler-core/dist/compiler-core.cjs.js';
import { flatten, pascalCase, camelCase, isCamelCase, isPascalCase, getComponentName } from '@vuedx/shared';
import { isInterpolationNode, isSimpleExpressionNode, isElementNode, isDirectiveNode, isTextNode, isComponentNode, isAttributeNode, traverse as traverse$1, createSimpleExpression as createSimpleExpression$1, isCommentNode } from '@vuedx/template-ast-types';
import * as Path from 'path';
import { parse as parse$1, parseExpression } from '@babel/parser';
import { traverse, isIdentifier, isFunction, traverseFast, isObjectMember, isAssignmentPattern, isMemberExpression, isOptionalMemberExpression, isArrayPattern, isExpression, isPrivateName, isRestElement, isObjectPattern, isFile, isDeclaration, isVariableDeclaration, isCallExpression, isFunctionDeclaration, isImportDeclaration, isImportSpecifier, isClassDeclaration, isDeclareClass, isDeclareFunction, isDeclareVariable, isEnumDeclaration } from '@babel/types';

const namedCharacterReferences = {
    GT: '>',
    gt: '>',
    LT: '<',
    lt: '<',
    'ac;': '‚àæ',
    'af;': '‚Å°',
    AMP: '&',
    amp: '&',
    'ap;': '‚âà',
    'DD;': '‚ÖÖ',
    'dd;': '‚ÖÜ',
    deg: '¬∞',
    'ee;': '‚Öá',
    'eg;': '‚™ö',
    'el;': '‚™ô',
    ETH: '√ê',
    eth: '√∞',
    'gE;': '‚âß',
    'ge;': '‚â•',
    'Gg;': '‚ãô',
    'gg;': '‚â´',
    'gl;': '‚â∑',
    'GT;': '>',
    'Gt;': '‚â´',
    'gt;': '>',
    'ic;': '‚Å£',
    'ii;': '‚Öà',
    'Im;': '‚Ñë',
    'in;': '‚àà',
    'it;': '‚Å¢',
    'lE;': '‚â¶',
    'le;': '‚â§',
    'lg;': '‚â∂',
    'Ll;': '‚ãò',
    'll;': '‚â™',
    'LT;': '<',
    'Lt;': '‚â™',
    'lt;': '<',
    'mp;': '‚àì',
    'Mu;': 'Œú',
    'mu;': 'Œº',
    'ne;': '‚â†',
    'ni;': '‚àã',
    not: '¬¨',
    'Nu;': 'Œù',
    'nu;': 'ŒΩ',
    'Or;': '‚©î',
    'or;': '‚à®',
    'oS;': '‚ìà',
    'Pi;': 'Œ†',
    'pi;': 'œÄ',
    'pm;': '¬±',
    'Pr;': '‚™ª',
    'pr;': '‚â∫',
    'Re;': '‚Ñú',
    REG: '¬Æ',
    reg: '¬Æ',
    'rx;': '‚Ñû',
    'Sc;': '‚™º',
    'sc;': '‚âª',
    shy: '¬≠',
    uml: '¬®',
    'wp;': '‚Ñò',
    'wr;': '‚âÄ',
    'Xi;': 'Œû',
    'xi;': 'Œæ',
    yen: '¬•',
    'acd;': '‚àø',
    'acE;': '‚àæÃ≥',
    'Acy;': '–ê',
    'acy;': '–∞',
    'Afr;': 'ùîÑ',
    'afr;': 'ùîû',
    'AMP;': '&',
    'amp;': '&',
    'And;': '‚©ì',
    'and;': '‚àß',
    'ang;': '‚à†',
    'apE;': '‚©∞',
    'ape;': '‚âä',
    'ast;': '*',
    Auml: '√Ñ',
    auml: '√§',
    'Bcy;': '–ë',
    'bcy;': '–±',
    'Bfr;': 'ùîÖ',
    'bfr;': 'ùîü',
    'bne;': '=‚É•',
    'bot;': '‚ä•',
    'Cap;': '‚ãí',
    'cap;': '‚à©',
    cent: '¬¢',
    'Cfr;': '‚Ñ≠',
    'cfr;': 'ùî†',
    'Chi;': 'Œß',
    'chi;': 'œá',
    'cir;': '‚óã',
    COPY: '¬©',
    copy: '¬©',
    'Cup;': '‚ãì',
    'cup;': '‚à™',
    'Dcy;': '–î',
    'dcy;': '–¥',
    'deg;': '¬∞',
    'Del;': '‚àá',
    'Dfr;': 'ùîá',
    'dfr;': 'ùî°',
    'die;': '¬®',
    'div;': '√∑',
    'Dot;': '¬®',
    'dot;': 'Àô',
    'Ecy;': '–≠',
    'ecy;': '—ç',
    'Efr;': 'ùîà',
    'efr;': 'ùî¢',
    'egs;': '‚™ñ',
    'ell;': '‚Ñì',
    'els;': '‚™ï',
    'ENG;': '≈ä',
    'eng;': '≈ã',
    'Eta;': 'Œó',
    'eta;': 'Œ∑',
    'ETH;': '√ê',
    'eth;': '√∞',
    Euml: '√ã',
    euml: '√´',
    'Fcy;': '–§',
    'fcy;': '—Ñ',
    'Ffr;': 'ùîâ',
    'ffr;': 'ùî£',
    'gap;': '‚™Ü',
    'Gcy;': '–ì',
    'gcy;': '–≥',
    'gEl;': '‚™å',
    'gel;': '‚ãõ',
    'geq;': '‚â•',
    'ges;': '‚©æ',
    'Gfr;': 'ùîä',
    'gfr;': 'ùî§',
    'ggg;': '‚ãô',
    'gla;': '‚™•',
    'glE;': '‚™í',
    'glj;': '‚™§',
    'gnE;': '‚â©',
    'gne;': '‚™à',
    'Hat;': '^',
    'Hfr;': '‚Ñå',
    'hfr;': 'ùî•',
    'Icy;': '–ò',
    'icy;': '–∏',
    'iff;': '‚áî',
    'Ifr;': '‚Ñë',
    'ifr;': 'ùî¶',
    'Int;': '‚à¨',
    'int;': '‚à´',
    Iuml: '√è',
    iuml: '√Ø',
    'Jcy;': '–ô',
    'jcy;': '–π',
    'Jfr;': 'ùîç',
    'jfr;': 'ùîß',
    'Kcy;': '–ö',
    'kcy;': '–∫',
    'Kfr;': 'ùîé',
    'kfr;': 'ùî®',
    'lap;': '‚™Ö',
    'lat;': '‚™´',
    'Lcy;': '–õ',
    'lcy;': '–ª',
    'lEg;': '‚™ã',
    'leg;': '‚ãö',
    'leq;': '‚â§',
    'les;': '‚©Ω',
    'Lfr;': 'ùîè',
    'lfr;': 'ùî©',
    'lgE;': '‚™ë',
    'lnE;': '‚â®',
    'lne;': '‚™á',
    'loz;': '‚óä',
    'lrm;': '‚Äé',
    'Lsh;': '‚Ü∞',
    'lsh;': '‚Ü∞',
    macr: '¬Ø',
    'Map;': '‚§Ö',
    'map;': '‚Ü¶',
    'Mcy;': '–ú',
    'mcy;': '–º',
    'Mfr;': 'ùîê',
    'mfr;': 'ùî™',
    'mho;': '‚Ñß',
    'mid;': '‚à£',
    'nap;': '‚ââ',
    nbsp: ' ',
    'Ncy;': '–ù',
    'ncy;': '–Ω',
    'Nfr;': 'ùîë',
    'nfr;': 'ùî´',
    'ngE;': '‚âßÃ∏',
    'nge;': '‚â±',
    'nGg;': '‚ãôÃ∏',
    'nGt;': '‚â´‚Éí',
    'ngt;': '‚âØ',
    'nis;': '‚ãº',
    'niv;': '‚àã',
    'nlE;': '‚â¶Ã∏',
    'nle;': '‚â∞',
    'nLl;': '‚ãòÃ∏',
    'nLt;': '‚â™‚Éí',
    'nlt;': '‚âÆ',
    'Not;': '‚´¨',
    'not;': '¬¨',
    'npr;': '‚äÄ',
    'nsc;': '‚äÅ',
    'num;': '#',
    'Ocy;': '–û',
    'ocy;': '–æ',
    'Ofr;': 'ùîí',
    'ofr;': 'ùî¨',
    'ogt;': '‚ßÅ',
    'ohm;': 'Œ©',
    'olt;': '‚ßÄ',
    'ord;': '‚©ù',
    ordf: '¬™',
    ordm: '¬∫',
    'orv;': '‚©õ',
    Ouml: '√ñ',
    ouml: '√∂',
    'par;': '‚à•',
    para: '¬∂',
    'Pcy;': '–ü',
    'pcy;': '–ø',
    'Pfr;': 'ùîì',
    'pfr;': 'ùî≠',
    'Phi;': 'Œ¶',
    'phi;': 'œÜ',
    'piv;': 'œñ',
    'prE;': '‚™≥',
    'pre;': '‚™Ø',
    'Psi;': 'Œ®',
    'psi;': 'œà',
    'Qfr;': 'ùîî',
    'qfr;': 'ùîÆ',
    QUOT: '"',
    quot: '"',
    'Rcy;': '–†',
    'rcy;': '—Ä',
    'REG;': '¬Æ',
    'reg;': '¬Æ',
    'Rfr;': '‚Ñú',
    'rfr;': 'ùîØ',
    'Rho;': 'Œ°',
    'rho;': 'œÅ',
    'rlm;': '‚Äè',
    'Rsh;': '‚Ü±',
    'rsh;': '‚Ü±',
    'scE;': '‚™¥',
    'sce;': '‚™∞',
    'Scy;': '–°',
    'scy;': '—Å',
    sect: '¬ß',
    'Sfr;': 'ùîñ',
    'sfr;': 'ùî∞',
    'shy;': '¬≠',
    'sim;': '‚àº',
    'smt;': '‚™™',
    'sol;': '/',
    'squ;': '‚ñ°',
    'Sub;': '‚ãê',
    'sub;': '‚äÇ',
    'Sum;': '‚àë',
    'sum;': '‚àë',
    'Sup;': '‚ãë',
    'sup;': '‚äÉ',
    sup1: '¬π',
    sup2: '¬≤',
    sup3: '¬≥',
    'Tab;': '\t',
    'Tau;': 'Œ§',
    'tau;': 'œÑ',
    'Tcy;': '–¢',
    'tcy;': '—Ç',
    'Tfr;': 'ùîó',
    'tfr;': 'ùî±',
    'top;': '‚ä§',
    'Ucy;': '–£',
    'ucy;': '—É',
    'Ufr;': 'ùîò',
    'ufr;': 'ùî≤',
    'uml;': '¬®',
    Uuml: '√ú',
    uuml: '√º',
    'Vcy;': '–í',
    'vcy;': '–≤',
    'Vee;': '‚ãÅ',
    'vee;': '‚à®',
    'Vfr;': 'ùîô',
    'vfr;': 'ùî≥',
    'Wfr;': 'ùîö',
    'wfr;': 'ùî¥',
    'Xfr;': 'ùîõ',
    'xfr;': 'ùîµ',
    'Ycy;': '–´',
    'ycy;': '—ã',
    'yen;': '¬•',
    'Yfr;': 'ùîú',
    'yfr;': 'ùî∂',
    yuml: '√ø',
    'Zcy;': '–ó',
    'zcy;': '–∑',
    'Zfr;': '‚Ñ®',
    'zfr;': 'ùî∑',
    'zwj;': '‚Äç',
    Acirc: '√Ç',
    acirc: '√¢',
    acute: '¬¥',
    AElig: '√Ü',
    aelig: '√¶',
    'andd;': '‚©ú',
    'andv;': '‚©ö',
    'ange;': '‚¶§',
    'Aopf;': 'ùî∏',
    'aopf;': 'ùïí',
    'apid;': '‚âã',
    'apos;': "'",
    Aring: '√Ö',
    aring: '√•',
    'Ascr;': 'ùíú',
    'ascr;': 'ùí∂',
    'Auml;': '√Ñ',
    'auml;': '√§',
    'Barv;': '‚´ß',
    'bbrk;': '‚éµ',
    'Beta;': 'Œí',
    'beta;': 'Œ≤',
    'beth;': '‚Ñ∂',
    'bNot;': '‚´≠',
    'bnot;': '‚åê',
    'Bopf;': 'ùîπ',
    'bopf;': 'ùïì',
    'boxH;': '‚ïê',
    'boxh;': '‚îÄ',
    'boxV;': '‚ïë',
    'boxv;': '‚îÇ',
    'Bscr;': '‚Ñ¨',
    'bscr;': 'ùí∑',
    'bsim;': '‚àΩ',
    'bsol;': '\\',
    'bull;': '‚Ä¢',
    'bump;': '‚âé',
    'caps;': '‚à©Ô∏Ä',
    'Cdot;': 'ƒä',
    'cdot;': 'ƒã',
    cedil: '¬∏',
    'cent;': '¬¢',
    'CHcy;': '–ß',
    'chcy;': '—á',
    'circ;': 'ÀÜ',
    'cirE;': '‚ßÉ',
    'cire;': '‚âó',
    'comp;': '‚àÅ',
    'cong;': '‚âÖ',
    'Copf;': '‚ÑÇ',
    'copf;': 'ùïî',
    'COPY;': '¬©',
    'copy;': '¬©',
    'Cscr;': 'ùíû',
    'cscr;': 'ùí∏',
    'csub;': '‚´è',
    'csup;': '‚´ê',
    'cups;': '‚à™Ô∏Ä',
    'Darr;': '‚Ü°',
    'dArr;': '‚áì',
    'darr;': '‚Üì',
    'dash;': '‚Äê',
    'dHar;': '‚••',
    'diam;': '‚ãÑ',
    'DJcy;': '–Ç',
    'djcy;': '—í',
    'Dopf;': 'ùîª',
    'dopf;': 'ùïï',
    'Dscr;': 'ùíü',
    'dscr;': 'ùíπ',
    'DScy;': '–Ö',
    'dscy;': '—ï',
    'dsol;': '‚ß∂',
    'dtri;': '‚ñø',
    'DZcy;': '–è',
    'dzcy;': '—ü',
    'ecir;': '‚âñ',
    Ecirc: '√ä',
    ecirc: '√™',
    'Edot;': 'ƒñ',
    'eDot;': '‚âë',
    'edot;': 'ƒó',
    'emsp;': '‚ÄÉ',
    'ensp;': '‚ÄÇ',
    'Eopf;': 'ùîº',
    'eopf;': 'ùïñ',
    'epar;': '‚ãï',
    'epsi;': 'Œµ',
    'Escr;': '‚Ñ∞',
    'escr;': '‚ÑØ',
    'Esim;': '‚©≥',
    'esim;': '‚âÇ',
    'Euml;': '√ã',
    'euml;': '√´',
    'euro;': '‚Ç¨',
    'excl;': '!',
    'flat;': '‚ô≠',
    'fnof;': '∆í',
    'Fopf;': 'ùîΩ',
    'fopf;': 'ùïó',
    'fork;': '‚ãî',
    'Fscr;': '‚Ñ±',
    'fscr;': 'ùíª',
    'Gdot;': 'ƒ†',
    'gdot;': 'ƒ°',
    'geqq;': '‚âß',
    'gesl;': '‚ãõÔ∏Ä',
    'GJcy;': '–É',
    'gjcy;': '—ì',
    'gnap;': '‚™ä',
    'gneq;': '‚™à',
    'Gopf;': 'ùîæ',
    'gopf;': 'ùïò',
    'Gscr;': 'ùí¢',
    'gscr;': '‚Ñä',
    'gsim;': '‚â≥',
    'gtcc;': '‚™ß',
    'gvnE;': '‚â©Ô∏Ä',
    'half;': '¬Ω',
    'hArr;': '‚áî',
    'harr;': '‚Üî',
    'hbar;': '‚Ñè',
    'Hopf;': '‚Ñç',
    'hopf;': 'ùïô',
    'Hscr;': '‚Ñã',
    'hscr;': 'ùíΩ',
    Icirc: '√é',
    icirc: '√Æ',
    'Idot;': 'ƒ∞',
    'IEcy;': '–ï',
    'iecy;': '–µ',
    iexcl: '¬°',
    'imof;': '‚ä∑',
    'IOcy;': '–Å',
    'iocy;': '—ë',
    'Iopf;': 'ùïÄ',
    'iopf;': 'ùïö',
    'Iota;': 'Œô',
    'iota;': 'Œπ',
    'Iscr;': '‚Ñê',
    'iscr;': 'ùíæ',
    'isin;': '‚àà',
    'Iuml;': '√è',
    'iuml;': '√Ø',
    'Jopf;': 'ùïÅ',
    'jopf;': 'ùïõ',
    'Jscr;': 'ùí•',
    'jscr;': 'ùíø',
    'KHcy;': '–•',
    'khcy;': '—Ö',
    'KJcy;': '–å',
    'kjcy;': '—ú',
    'Kopf;': 'ùïÇ',
    'kopf;': 'ùïú',
    'Kscr;': 'ùí¶',
    'kscr;': 'ùìÄ',
    'Lang;': '‚ü™',
    'lang;': '‚ü®',
    laquo: '¬´',
    'Larr;': '‚Üû',
    'lArr;': '‚áê',
    'larr;': '‚Üê',
    'late;': '‚™≠',
    'lcub;': '{',
    'ldca;': '‚§∂',
    'ldsh;': '‚Ü≤',
    'leqq;': '‚â¶',
    'lesg;': '‚ãöÔ∏Ä',
    'lHar;': '‚•¢',
    'LJcy;': '–â',
    'ljcy;': '—ô',
    'lnap;': '‚™â',
    'lneq;': '‚™á',
    'Lopf;': 'ùïÉ',
    'lopf;': 'ùïù',
    'lozf;': '‚ß´',
    'lpar;': '(',
    'Lscr;': '‚Ñí',
    'lscr;': 'ùìÅ',
    'lsim;': '‚â≤',
    'lsqb;': '[',
    'ltcc;': '‚™¶',
    'ltri;': '‚óÉ',
    'lvnE;': '‚â®Ô∏Ä',
    'macr;': '¬Ø',
    'male;': '‚ôÇ',
    'malt;': '‚ú†',
    micro: '¬µ',
    'mlcp;': '‚´õ',
    'mldr;': '‚Ä¶',
    'Mopf;': 'ùïÑ',
    'mopf;': 'ùïû',
    'Mscr;': '‚Ñ≥',
    'mscr;': 'ùìÇ',
    'nang;': '‚à†‚Éí',
    'napE;': '‚©∞Ã∏',
    'nbsp;': ' ',
    'ncap;': '‚©É',
    'ncup;': '‚©Ç',
    'ngeq;': '‚â±',
    'nges;': '‚©æÃ∏',
    'ngtr;': '‚âØ',
    'nGtv;': '‚â´Ã∏',
    'nisd;': '‚ã∫',
    'NJcy;': '–ä',
    'njcy;': '—ö',
    'nldr;': '‚Ä•',
    'nleq;': '‚â∞',
    'nles;': '‚©ΩÃ∏',
    'nLtv;': '‚â™Ã∏',
    'nmid;': '‚à§',
    'Nopf;': '‚Ñï',
    'nopf;': 'ùïü',
    'npar;': '‚à¶',
    'npre;': '‚™ØÃ∏',
    'nsce;': '‚™∞Ã∏',
    'Nscr;': 'ùí©',
    'nscr;': 'ùìÉ',
    'nsim;': '‚âÅ',
    'nsub;': '‚äÑ',
    'nsup;': '‚äÖ',
    'ntgl;': '‚âπ',
    'ntlg;': '‚â∏',
    'nvap;': '‚âç‚Éí',
    'nvge;': '‚â•‚Éí',
    'nvgt;': '>‚Éí',
    'nvle;': '‚â§‚Éí',
    'nvlt;': '<‚Éí',
    'oast;': '‚äõ',
    'ocir;': '‚äö',
    Ocirc: '√î',
    ocirc: '√¥',
    'odiv;': '‚®∏',
    'odot;': '‚äô',
    'ogon;': 'Àõ',
    'oint;': '‚àÆ',
    'omid;': '‚¶∂',
    'Oopf;': 'ùïÜ',
    'oopf;': 'ùï†',
    'opar;': '‚¶∑',
    'ordf;': '¬™',
    'ordm;': '¬∫',
    'oror;': '‚©ñ',
    'Oscr;': 'ùí™',
    'oscr;': '‚Ñ¥',
    'osol;': '‚äò',
    'Ouml;': '√ñ',
    'ouml;': '√∂',
    'para;': '¬∂',
    'part;': '‚àÇ',
    'perp;': '‚ä•',
    'phiv;': 'œï',
    'plus;': '+',
    'Popf;': '‚Ñô',
    'popf;': 'ùï°',
    pound: '¬£',
    'prap;': '‚™∑',
    'prec;': '‚â∫',
    'prnE;': '‚™µ',
    'prod;': '‚àè',
    'prop;': '‚àù',
    'Pscr;': 'ùí´',
    'pscr;': 'ùìÖ',
    'qint;': '‚®å',
    'Qopf;': '‚Ñö',
    'qopf;': 'ùï¢',
    'Qscr;': 'ùí¨',
    'qscr;': 'ùìÜ',
    'QUOT;': '"',
    'quot;': '"',
    'race;': '‚àΩÃ±',
    'Rang;': '‚ü´',
    'rang;': '‚ü©',
    raquo: '¬ª',
    'Rarr;': '‚Ü†',
    'rArr;': '‚áí',
    'rarr;': '‚Üí',
    'rcub;': '}',
    'rdca;': '‚§∑',
    'rdsh;': '‚Ü≥',
    'real;': '‚Ñú',
    'rect;': '‚ñ≠',
    'rHar;': '‚•§',
    'rhov;': 'œ±',
    'ring;': 'Àö',
    'Ropf;': '‚Ñù',
    'ropf;': 'ùï£',
    'rpar;': ')',
    'Rscr;': '‚Ñõ',
    'rscr;': 'ùìá',
    'rsqb;': ']',
    'rtri;': '‚ñπ',
    'scap;': '‚™∏',
    'scnE;': '‚™∂',
    'sdot;': '‚ãÖ',
    'sect;': '¬ß',
    'semi;': ';',
    'sext;': '‚ú∂',
    'SHcy;': '–®',
    'shcy;': '—à',
    'sime;': '‚âÉ',
    'simg;': '‚™û',
    'siml;': '‚™ù',
    'smid;': '‚à£',
    'smte;': '‚™¨',
    'solb;': '‚ßÑ',
    'Sopf;': 'ùïä',
    'sopf;': 'ùï§',
    'spar;': '‚à•',
    'Sqrt;': '‚àö',
    'squf;': '‚ñ™',
    'Sscr;': 'ùíÆ',
    'sscr;': 'ùìà',
    'Star;': '‚ãÜ',
    'star;': '‚òÜ',
    'subE;': '‚´Ö',
    'sube;': '‚äÜ',
    'succ;': '‚âª',
    'sung;': '‚ô™',
    'sup1;': '¬π',
    'sup2;': '¬≤',
    'sup3;': '¬≥',
    'supE;': '‚´Ü',
    'supe;': '‚äá',
    szlig: '√ü',
    'tbrk;': '‚é¥',
    'tdot;': '‚Éõ',
    THORN: '√û',
    thorn: '√æ',
    times: '√ó',
    'tint;': '‚à≠',
    'toea;': '‚§®',
    'Topf;': 'ùïã',
    'topf;': 'ùï•',
    'tosa;': '‚§©',
    'trie;': '‚âú',
    'Tscr;': 'ùíØ',
    'tscr;': 'ùìâ',
    'TScy;': '–¶',
    'tscy;': '—Ü',
    'Uarr;': '‚Üü',
    'uArr;': '‚áë',
    'uarr;': '‚Üë',
    Ucirc: '√õ',
    ucirc: '√ª',
    'uHar;': '‚•£',
    'Uopf;': 'ùïå',
    'uopf;': 'ùï¶',
    'Upsi;': 'œí',
    'upsi;': 'œÖ',
    'Uscr;': 'ùí∞',
    'uscr;': 'ùìä',
    'utri;': '‚ñµ',
    'Uuml;': '√ú',
    'uuml;': '√º',
    'vArr;': '‚áï',
    'varr;': '‚Üï',
    'Vbar;': '‚´´',
    'vBar;': '‚´®',
    'Vert;': '‚Äñ',
    'vert;': '|',
    'Vopf;': 'ùïç',
    'vopf;': 'ùïß',
    'Vscr;': 'ùí±',
    'vscr;': 'ùìã',
    'Wopf;': 'ùïé',
    'wopf;': 'ùï®',
    'Wscr;': 'ùí≤',
    'wscr;': 'ùìå',
    'xcap;': '‚ãÇ',
    'xcup;': '‚ãÉ',
    'xmap;': '‚üº',
    'xnis;': '‚ãª',
    'Xopf;': 'ùïè',
    'xopf;': 'ùï©',
    'Xscr;': 'ùí≥',
    'xscr;': 'ùìç',
    'xvee;': '‚ãÅ',
    'YAcy;': '–Ø',
    'yacy;': '—è',
    'YIcy;': '–á',
    'yicy;': '—ó',
    'Yopf;': 'ùïê',
    'yopf;': 'ùï™',
    'Yscr;': 'ùí¥',
    'yscr;': 'ùìé',
    'YUcy;': '–Æ',
    'yucy;': '—é',
    'Yuml;': '≈∏',
    'yuml;': '√ø',
    'Zdot;': '≈ª',
    'zdot;': '≈º',
    'Zeta;': 'Œñ',
    'zeta;': 'Œ∂',
    'ZHcy;': '–ñ',
    'zhcy;': '–∂',
    'Zopf;': '‚Ñ§',
    'zopf;': 'ùï´',
    'Zscr;': 'ùíµ',
    'zscr;': 'ùìè',
    'zwnj;': '‚Äå',
    Aacute: '√Å',
    aacute: '√°',
    'Acirc;': '√Ç',
    'acirc;': '√¢',
    'acute;': '¬¥',
    'AElig;': '√Ü',
    'aelig;': '√¶',
    Agrave: '√Ä',
    agrave: '√†',
    'aleph;': '‚Ñµ',
    'Alpha;': 'Œë',
    'alpha;': 'Œ±',
    'Amacr;': 'ƒÄ',
    'amacr;': 'ƒÅ',
    'amalg;': '‚®ø',
    'angle;': '‚à†',
    'angrt;': '‚àü',
    'angst;': '√Ö',
    'Aogon;': 'ƒÑ',
    'aogon;': 'ƒÖ',
    'Aring;': '√Ö',
    'aring;': '√•',
    'asymp;': '‚âà',
    Atilde: '√É',
    atilde: '√£',
    'awint;': '‚®ë',
    'bcong;': '‚âå',
    'bdquo;': '‚Äû',
    'bepsi;': 'œ∂',
    'blank;': '‚ê£',
    'blk12;': '‚ñí',
    'blk14;': '‚ñë',
    'blk34;': '‚ñì',
    'block;': '‚ñà',
    'boxDL;': '‚ïó',
    'boxDl;': '‚ïñ',
    'boxdL;': '‚ïï',
    'boxdl;': '‚îê',
    'boxDR;': '‚ïî',
    'boxDr;': '‚ïì',
    'boxdR;': '‚ïí',
    'boxdr;': '‚îå',
    'boxHD;': '‚ï¶',
    'boxHd;': '‚ï§',
    'boxhD;': '‚ï•',
    'boxhd;': '‚î¨',
    'boxHU;': '‚ï©',
    'boxHu;': '‚ïß',
    'boxhU;': '‚ï®',
    'boxhu;': '‚î¥',
    'boxUL;': '‚ïù',
    'boxUl;': '‚ïú',
    'boxuL;': '‚ïõ',
    'boxul;': '‚îò',
    'boxUR;': '‚ïö',
    'boxUr;': '‚ïô',
    'boxuR;': '‚ïò',
    'boxur;': '‚îî',
    'boxVH;': '‚ï¨',
    'boxVh;': '‚ï´',
    'boxvH;': '‚ï™',
    'boxvh;': '‚îº',
    'boxVL;': '‚ï£',
    'boxVl;': '‚ï¢',
    'boxvL;': '‚ï°',
    'boxvl;': '‚î§',
    'boxVR;': '‚ï†',
    'boxVr;': '‚ïü',
    'boxvR;': '‚ïû',
    'boxvr;': '‚îú',
    'Breve;': 'Àò',
    'breve;': 'Àò',
    brvbar: '¬¶',
    'bsemi;': '‚Åè',
    'bsime;': '‚ãç',
    'bsolb;': '‚ßÖ',
    'bumpE;': '‚™Æ',
    'bumpe;': '‚âè',
    'caret;': '‚ÅÅ',
    'caron;': 'Àá',
    'ccaps;': '‚©ç',
    Ccedil: '√á',
    ccedil: '√ß',
    'Ccirc;': 'ƒà',
    'ccirc;': 'ƒâ',
    'ccups;': '‚©å',
    'cedil;': '¬∏',
    'check;': '‚úì',
    'clubs;': '‚ô£',
    'Colon;': '‚à∑',
    'colon;': ':',
    'comma;': ',',
    'crarr;': '‚Üµ',
    'Cross;': '‚®Ø',
    'cross;': '‚úó',
    'csube;': '‚´ë',
    'csupe;': '‚´í',
    'ctdot;': '‚ãØ',
    'cuepr;': '‚ãû',
    'cuesc;': '‚ãü',
    'cupor;': '‚©Ö',
    curren: '¬§',
    'cuvee;': '‚ãé',
    'cuwed;': '‚ãè',
    'cwint;': '‚à±',
    'Dashv;': '‚´§',
    'dashv;': '‚ä£',
    'dblac;': 'Àù',
    'ddarr;': '‚áä',
    'Delta;': 'Œî',
    'delta;': 'Œ¥',
    'dharl;': '‚áÉ',
    'dharr;': '‚áÇ',
    'diams;': '‚ô¶',
    'disin;': '‚ã≤',
    divide: '√∑',
    'doteq;': '‚âê',
    'dtdot;': '‚ã±',
    'dtrif;': '‚ñæ',
    'duarr;': '‚áµ',
    'duhar;': '‚•Ø',
    Eacute: '√â',
    eacute: '√©',
    'Ecirc;': '√ä',
    'ecirc;': '√™',
    'eDDot;': '‚©∑',
    'efDot;': '‚âí',
    Egrave: '√à',
    egrave: '√®',
    'Emacr;': 'ƒí',
    'emacr;': 'ƒì',
    'empty;': '‚àÖ',
    'Eogon;': 'ƒò',
    'eogon;': 'ƒô',
    'eplus;': '‚©±',
    'epsiv;': 'œµ',
    'eqsim;': '‚âÇ',
    'Equal;': '‚©µ',
    'equiv;': '‚â°',
    'erarr;': '‚•±',
    'erDot;': '‚âì',
    'esdot;': '‚âê',
    'exist;': '‚àÉ',
    'fflig;': 'Ô¨Ä',
    'filig;': 'Ô¨Å',
    'fjlig;': 'fj',
    'fllig;': 'Ô¨Ç',
    'fltns;': '‚ñ±',
    'forkv;': '‚´ô',
    frac12: '¬Ω',
    frac14: '¬º',
    frac34: '¬æ',
    'frasl;': '‚ÅÑ',
    'frown;': '‚å¢',
    'Gamma;': 'Œì',
    'gamma;': 'Œ≥',
    'Gcirc;': 'ƒú',
    'gcirc;': 'ƒù',
    'gescc;': '‚™©',
    'gimel;': '‚Ñ∑',
    'gneqq;': '‚â©',
    'gnsim;': '‚ãß',
    'grave;': '`',
    'gsime;': '‚™é',
    'gsiml;': '‚™ê',
    'gtcir;': '‚©∫',
    'gtdot;': '‚ãó',
    'Hacek;': 'Àá',
    'harrw;': '‚Ü≠',
    'Hcirc;': 'ƒ§',
    'hcirc;': 'ƒ•',
    'hoarr;': '‚áø',
    Iacute: '√ç',
    iacute: '√≠',
    'Icirc;': '√é',
    'icirc;': '√Æ',
    'iexcl;': '¬°',
    Igrave: '√å',
    igrave: '√¨',
    'iiint;': '‚à≠',
    'iiota;': '‚Ñ©',
    'IJlig;': 'ƒ≤',
    'ijlig;': 'ƒ≥',
    'Imacr;': 'ƒ™',
    'imacr;': 'ƒ´',
    'image;': '‚Ñë',
    'imath;': 'ƒ±',
    'imped;': '∆µ',
    'infin;': '‚àû',
    'Iogon;': 'ƒÆ',
    'iogon;': 'ƒØ',
    'iprod;': '‚®º',
    iquest: '¬ø',
    'isinE;': '‚ãπ',
    'isins;': '‚ã¥',
    'isinv;': '‚àà',
    'Iukcy;': '–Ü',
    'iukcy;': '—ñ',
    'Jcirc;': 'ƒ¥',
    'jcirc;': 'ƒµ',
    'jmath;': '»∑',
    'Jukcy;': '–Ñ',
    'jukcy;': '—î',
    'Kappa;': 'Œö',
    'kappa;': 'Œ∫',
    'lAarr;': '‚áö',
    'langd;': '‚¶ë',
    'laquo;': '¬´',
    'larrb;': '‚á§',
    'lates;': '‚™≠Ô∏Ä',
    'lBarr;': '‚§é',
    'lbarr;': '‚§å',
    'lbbrk;': '‚ù≤',
    'lbrke;': '‚¶ã',
    'lceil;': '‚åà',
    'ldquo;': '‚Äú',
    'lescc;': '‚™®',
    'lhard;': '‚ÜΩ',
    'lharu;': '‚Üº',
    'lhblk;': '‚ñÑ',
    'llarr;': '‚áá',
    'lltri;': '‚ó∫',
    'lneqq;': '‚â®',
    'lnsim;': '‚ã¶',
    'loang;': '‚ü¨',
    'loarr;': '‚áΩ',
    'lobrk;': '‚ü¶',
    'lopar;': '‚¶Ö',
    'lrarr;': '‚áÜ',
    'lrhar;': '‚áã',
    'lrtri;': '‚äø',
    'lsime;': '‚™ç',
    'lsimg;': '‚™è',
    'lsquo;': '‚Äò',
    'ltcir;': '‚©π',
    'ltdot;': '‚ãñ',
    'ltrie;': '‚ä¥',
    'ltrif;': '‚óÇ',
    'mdash;': '‚Äî',
    'mDDot;': '‚à∫',
    'micro;': '¬µ',
    middot: '¬∑',
    'minus;': '‚àí',
    'mumap;': '‚ä∏',
    'nabla;': '‚àá',
    'napid;': '‚âãÃ∏',
    'napos;': '≈â',
    'natur;': '‚ôÆ',
    'nbump;': '‚âéÃ∏',
    'ncong;': '‚âá',
    'ndash;': '‚Äì',
    'neArr;': '‚áó',
    'nearr;': '‚Üó',
    'nedot;': '‚âêÃ∏',
    'nesim;': '‚âÇÃ∏',
    'ngeqq;': '‚âßÃ∏',
    'ngsim;': '‚âµ',
    'nhArr;': '‚áé',
    'nharr;': '‚ÜÆ',
    'nhpar;': '‚´≤',
    'nlArr;': '‚áç',
    'nlarr;': '‚Üö',
    'nleqq;': '‚â¶Ã∏',
    'nless;': '‚âÆ',
    'nlsim;': '‚â¥',
    'nltri;': '‚ã™',
    'notin;': '‚àâ',
    'notni;': '‚àå',
    'npart;': '‚àÇÃ∏',
    'nprec;': '‚äÄ',
    'nrArr;': '‚áè',
    'nrarr;': '‚Üõ',
    'nrtri;': '‚ã´',
    'nsime;': '‚âÑ',
    'nsmid;': '‚à§',
    'nspar;': '‚à¶',
    'nsubE;': '‚´ÖÃ∏',
    'nsube;': '‚äà',
    'nsucc;': '‚äÅ',
    'nsupE;': '‚´ÜÃ∏',
    'nsupe;': '‚äâ',
    Ntilde: '√ë',
    ntilde: '√±',
    'numsp;': '‚Äá',
    'nvsim;': '‚àº‚Éí',
    'nwArr;': '‚áñ',
    'nwarr;': '‚Üñ',
    Oacute: '√ì',
    oacute: '√≥',
    'Ocirc;': '√î',
    'ocirc;': '√¥',
    'odash;': '‚äù',
    'OElig;': '≈í',
    'oelig;': '≈ì',
    'ofcir;': '‚¶ø',
    Ograve: '√í',
    ograve: '√≤',
    'ohbar;': '‚¶µ',
    'olarr;': '‚Ü∫',
    'olcir;': '‚¶æ',
    'oline;': '‚Äæ',
    'Omacr;': '≈å',
    'omacr;': '≈ç',
    'Omega;': 'Œ©',
    'omega;': 'œâ',
    'operp;': '‚¶π',
    'oplus;': '‚äï',
    'orarr;': '‚Üª',
    'order;': '‚Ñ¥',
    Oslash: '√ò',
    oslash: '√∏',
    Otilde: '√ï',
    otilde: '√µ',
    'ovbar;': '‚åΩ',
    'parsl;': '‚´Ω',
    'phone;': '‚òé',
    'plusb;': '‚äû',
    'pluse;': '‚©≤',
    plusmn: '¬±',
    'pound;': '¬£',
    'prcue;': '‚âº',
    'Prime;': '‚Ä≥',
    'prime;': '‚Ä≤',
    'prnap;': '‚™π',
    'prsim;': '‚âæ',
    'quest;': '?',
    'rAarr;': '‚áõ',
    'radic;': '‚àö',
    'rangd;': '‚¶í',
    'range;': '‚¶•',
    'raquo;': '¬ª',
    'rarrb;': '‚á•',
    'rarrc;': '‚§≥',
    'rarrw;': '‚Üù',
    'ratio;': '‚à∂',
    'RBarr;': '‚§ê',
    'rBarr;': '‚§è',
    'rbarr;': '‚§ç',
    'rbbrk;': '‚ù≥',
    'rbrke;': '‚¶å',
    'rceil;': '‚åâ',
    'rdquo;': '‚Äù',
    'reals;': '‚Ñù',
    'rhard;': '‚áÅ',
    'rharu;': '‚áÄ',
    'rlarr;': '‚áÑ',
    'rlhar;': '‚áå',
    'rnmid;': '‚´Æ',
    'roang;': '‚ü≠',
    'roarr;': '‚áæ',
    'robrk;': '‚üß',
    'ropar;': '‚¶Ü',
    'rrarr;': '‚áâ',
    'rsquo;': '‚Äô',
    'rtrie;': '‚äµ',
    'rtrif;': '‚ñ∏',
    'sbquo;': '‚Äö',
    'sccue;': '‚âΩ',
    'Scirc;': '≈ú',
    'scirc;': '≈ù',
    'scnap;': '‚™∫',
    'scsim;': '‚âø',
    'sdotb;': '‚ä°',
    'sdote;': '‚©¶',
    'seArr;': '‚áò',
    'searr;': '‚Üò',
    'setmn;': '‚àñ',
    'sharp;': '‚ôØ',
    'Sigma;': 'Œ£',
    'sigma;': 'œÉ',
    'simeq;': '‚âÉ',
    'simgE;': '‚™†',
    'simlE;': '‚™ü',
    'simne;': '‚âÜ',
    'slarr;': '‚Üê',
    'smile;': '‚å£',
    'smtes;': '‚™¨Ô∏Ä',
    'sqcap;': '‚äì',
    'sqcup;': '‚äî',
    'sqsub;': '‚äè',
    'sqsup;': '‚äê',
    'srarr;': '‚Üí',
    'starf;': '‚òÖ',
    'strns;': '¬Ø',
    'subnE;': '‚´ã',
    'subne;': '‚ää',
    'supnE;': '‚´å',
    'supne;': '‚äã',
    'swArr;': '‚áô',
    'swarr;': '‚Üô',
    'szlig;': '√ü',
    'Theta;': 'Œò',
    'theta;': 'Œ∏',
    'thkap;': '‚âà',
    'THORN;': '√û',
    'thorn;': '√æ',
    'Tilde;': '‚àº',
    'tilde;': 'Àú',
    'times;': '√ó',
    'TRADE;': '‚Ñ¢',
    'trade;': '‚Ñ¢',
    'trisb;': '‚ßç',
    'TSHcy;': '–ã',
    'tshcy;': '—õ',
    'twixt;': '‚â¨',
    Uacute: '√ö',
    uacute: '√∫',
    'Ubrcy;': '–é',
    'ubrcy;': '—û',
    'Ucirc;': '√õ',
    'ucirc;': '√ª',
    'udarr;': '‚áÖ',
    'udhar;': '‚•Æ',
    Ugrave: '√ô',
    ugrave: '√π',
    'uharl;': '‚Üø',
    'uharr;': '‚Üæ',
    'uhblk;': '‚ñÄ',
    'ultri;': '‚ó∏',
    'Umacr;': '≈™',
    'umacr;': '≈´',
    'Union;': '‚ãÉ',
    'Uogon;': '≈≤',
    'uogon;': '≈≥',
    'uplus;': '‚äé',
    'upsih;': 'œí',
    'UpTee;': '‚ä•',
    'Uring;': '≈Æ',
    'uring;': '≈Ø',
    'urtri;': '‚óπ',
    'utdot;': '‚ã∞',
    'utrif;': '‚ñ¥',
    'uuarr;': '‚áà',
    'varpi;': 'œñ',
    'vBarv;': '‚´©',
    'VDash;': '‚ä´',
    'Vdash;': '‚ä©',
    'vDash;': '‚ä®',
    'vdash;': '‚ä¢',
    'veeeq;': '‚âö',
    'vltri;': '‚ä≤',
    'vnsub;': '‚äÇ‚Éí',
    'vnsup;': '‚äÉ‚Éí',
    'vprop;': '‚àù',
    'vrtri;': '‚ä≥',
    'Wcirc;': '≈¥',
    'wcirc;': '≈µ',
    'Wedge;': '‚ãÄ',
    'wedge;': '‚àß',
    'xcirc;': '‚óØ',
    'xdtri;': '‚ñΩ',
    'xhArr;': '‚ü∫',
    'xharr;': '‚ü∑',
    'xlArr;': '‚ü∏',
    'xlarr;': '‚üµ',
    'xodot;': '‚®Ä',
    'xrArr;': '‚üπ',
    'xrarr;': '‚ü∂',
    'xutri;': '‚ñ≥',
    Yacute: '√ù',
    yacute: '√Ω',
    'Ycirc;': '≈∂',
    'ycirc;': '≈∑',
    'Aacute;': '√Å',
    'aacute;': '√°',
    'Abreve;': 'ƒÇ',
    'abreve;': 'ƒÉ',
    'Agrave;': '√Ä',
    'agrave;': '√†',
    'andand;': '‚©ï',
    'angmsd;': '‚à°',
    'angsph;': '‚à¢',
    'apacir;': '‚©Ø',
    'approx;': '‚âà',
    'Assign;': '‚âî',
    'Atilde;': '√É',
    'atilde;': '√£',
    'barvee;': '‚äΩ',
    'Barwed;': '‚åÜ',
    'barwed;': '‚åÖ',
    'becaus;': '‚àµ',
    'bernou;': '‚Ñ¨',
    'bigcap;': '‚ãÇ',
    'bigcup;': '‚ãÉ',
    'bigvee;': '‚ãÅ',
    'bkarow;': '‚§ç',
    'bottom;': '‚ä•',
    'bowtie;': '‚ãà',
    'boxbox;': '‚ßâ',
    'bprime;': '‚Äµ',
    'brvbar;': '¬¶',
    'bullet;': '‚Ä¢',
    'Bumpeq;': '‚âé',
    'bumpeq;': '‚âè',
    'Cacute;': 'ƒÜ',
    'cacute;': 'ƒá',
    'capand;': '‚©Ñ',
    'capcap;': '‚©ã',
    'capcup;': '‚©á',
    'capdot;': '‚©Ä',
    'Ccaron;': 'ƒå',
    'ccaron;': 'ƒç',
    'Ccedil;': '√á',
    'ccedil;': '√ß',
    'circeq;': '‚âó',
    'cirmid;': '‚´Ø',
    'Colone;': '‚©¥',
    'colone;': '‚âî',
    'commat;': '@',
    'compfn;': '‚àò',
    'Conint;': '‚àØ',
    'conint;': '‚àÆ',
    'coprod;': '‚àê',
    'copysr;': '‚Ñó',
    'cularr;': '‚Ü∂',
    'CupCap;': '‚âç',
    'cupcap;': '‚©Ü',
    'cupcup;': '‚©ä',
    'cupdot;': '‚äç',
    'curarr;': '‚Ü∑',
    'curren;': '¬§',
    'cylcty;': '‚å≠',
    'Dagger;': '‚Ä°',
    'dagger;': '‚Ä†',
    'daleth;': '‚Ñ∏',
    'Dcaron;': 'ƒé',
    'dcaron;': 'ƒè',
    'dfisht;': '‚•ø',
    'divide;': '√∑',
    'divonx;': '‚ãá',
    'dlcorn;': '‚åû',
    'dlcrop;': '‚åç',
    'dollar;': '$',
    'DotDot;': '‚Éú',
    'drcorn;': '‚åü',
    'drcrop;': '‚åå',
    'Dstrok;': 'ƒê',
    'dstrok;': 'ƒë',
    'Eacute;': '√â',
    'eacute;': '√©',
    'easter;': '‚©Æ',
    'Ecaron;': 'ƒö',
    'ecaron;': 'ƒõ',
    'ecolon;': '‚âï',
    'Egrave;': '√à',
    'egrave;': '√®',
    'egsdot;': '‚™ò',
    'elsdot;': '‚™ó',
    'emptyv;': '‚àÖ',
    'emsp13;': '‚ÄÑ',
    'emsp14;': '‚ÄÖ',
    'eparsl;': '‚ß£',
    'eqcirc;': '‚âñ',
    'equals;': '=',
    'equest;': '‚âü',
    'Exists;': '‚àÉ',
    'female;': '‚ôÄ',
    'ffilig;': 'Ô¨É',
    'ffllig;': 'Ô¨Ñ',
    'ForAll;': '‚àÄ',
    'forall;': '‚àÄ',
    'frac12;': '¬Ω',
    'frac13;': '‚Öì',
    'frac14;': '¬º',
    'frac15;': '‚Öï',
    'frac16;': '‚Öô',
    'frac18;': '‚Öõ',
    'frac23;': '‚Öî',
    'frac25;': '‚Öñ',
    'frac34;': '¬æ',
    'frac35;': '‚Öó',
    'frac38;': '‚Öú',
    'frac45;': '‚Öò',
    'frac56;': '‚Öö',
    'frac58;': '‚Öù',
    'frac78;': '‚Öû',
    'gacute;': '«µ',
    'Gammad;': 'œú',
    'gammad;': 'œù',
    'Gbreve;': 'ƒû',
    'gbreve;': 'ƒü',
    'Gcedil;': 'ƒ¢',
    'gesdot;': '‚™Ä',
    'gesles;': '‚™î',
    'gtlPar;': '‚¶ï',
    'gtrarr;': '‚•∏',
    'gtrdot;': '‚ãó',
    'gtrsim;': '‚â≥',
    'hairsp;': '‚Ää',
    'hamilt;': '‚Ñã',
    'HARDcy;': '–™',
    'hardcy;': '—ä',
    'hearts;': '‚ô•',
    'hellip;': '‚Ä¶',
    'hercon;': '‚äπ',
    'homtht;': '‚àª',
    'horbar;': '‚Äï',
    'hslash;': '‚Ñè',
    'Hstrok;': 'ƒ¶',
    'hstrok;': 'ƒß',
    'hybull;': '‚ÅÉ',
    'hyphen;': '‚Äê',
    'Iacute;': '√ç',
    'iacute;': '√≠',
    'Igrave;': '√å',
    'igrave;': '√¨',
    'iiiint;': '‚®å',
    'iinfin;': '‚ßú',
    'incare;': '‚ÑÖ',
    'inodot;': 'ƒ±',
    'intcal;': '‚ä∫',
    'iquest;': '¬ø',
    'isinsv;': '‚ã≥',
    'Itilde;': 'ƒ®',
    'itilde;': 'ƒ©',
    'Jsercy;': '–à',
    'jsercy;': '—ò',
    'kappav;': 'œ∞',
    'Kcedil;': 'ƒ∂',
    'kcedil;': 'ƒ∑',
    'kgreen;': 'ƒ∏',
    'Lacute;': 'ƒπ',
    'lacute;': 'ƒ∫',
    'lagran;': '‚Ñí',
    'Lambda;': 'Œõ',
    'lambda;': 'Œª',
    'langle;': '‚ü®',
    'larrfs;': '‚§ù',
    'larrhk;': '‚Ü©',
    'larrlp;': '‚Ü´',
    'larrpl;': '‚§π',
    'larrtl;': '‚Ü¢',
    'lAtail;': '‚§õ',
    'latail;': '‚§ô',
    'lbrace;': '{',
    'lbrack;': '[',
    'Lcaron;': 'ƒΩ',
    'lcaron;': 'ƒæ',
    'Lcedil;': 'ƒª',
    'lcedil;': 'ƒº',
    'ldquor;': '‚Äû',
    'lesdot;': '‚©ø',
    'lesges;': '‚™ì',
    'lfisht;': '‚•º',
    'lfloor;': '‚åä',
    'lharul;': '‚•™',
    'llhard;': '‚•´',
    'Lmidot;': 'ƒø',
    'lmidot;': '≈Ä',
    'lmoust;': '‚é∞',
    'loplus;': '‚®≠',
    'lowast;': '‚àó',
    'lowbar;': '_',
    'lparlt;': '‚¶ì',
    'lrhard;': '‚•≠',
    'lsaquo;': '‚Äπ',
    'lsquor;': '‚Äö',
    'Lstrok;': '≈Å',
    'lstrok;': '≈Ç',
    'lthree;': '‚ãã',
    'ltimes;': '‚ãâ',
    'ltlarr;': '‚•∂',
    'ltrPar;': '‚¶ñ',
    'mapsto;': '‚Ü¶',
    'marker;': '‚ñÆ',
    'mcomma;': '‚®©',
    'midast;': '*',
    'midcir;': '‚´∞',
    'middot;': '¬∑',
    'minusb;': '‚äü',
    'minusd;': '‚à∏',
    'mnplus;': '‚àì',
    'models;': '‚äß',
    'mstpos;': '‚àæ',
    'Nacute;': '≈É',
    'nacute;': '≈Ñ',
    'nbumpe;': '‚âèÃ∏',
    'Ncaron;': '≈á',
    'ncaron;': '≈à',
    'Ncedil;': '≈Ö',
    'ncedil;': '≈Ü',
    'nearhk;': '‚§§',
    'nequiv;': '‚â¢',
    'nesear;': '‚§®',
    'nexist;': '‚àÑ',
    'nltrie;': '‚ã¨',
    'notinE;': '‚ãπÃ∏',
    'nparsl;': '‚´Ω‚É•',
    'nprcue;': '‚ã†',
    'nrarrc;': '‚§≥Ã∏',
    'nrarrw;': '‚ÜùÃ∏',
    'nrtrie;': '‚ã≠',
    'nsccue;': '‚ã°',
    'nsimeq;': '‚âÑ',
    'Ntilde;': '√ë',
    'ntilde;': '√±',
    'numero;': '‚Ññ',
    'nVDash;': '‚äØ',
    'nVdash;': '‚äÆ',
    'nvDash;': '‚ä≠',
    'nvdash;': '‚ä¨',
    'nvHarr;': '‚§Ñ',
    'nvlArr;': '‚§Ç',
    'nvrArr;': '‚§É',
    'nwarhk;': '‚§£',
    'nwnear;': '‚§ß',
    'Oacute;': '√ì',
    'oacute;': '√≥',
    'Odblac;': '≈ê',
    'odblac;': '≈ë',
    'odsold;': '‚¶º',
    'Ograve;': '√í',
    'ograve;': '√≤',
    'ominus;': '‚äñ',
    'origof;': '‚ä∂',
    'Oslash;': '√ò',
    'oslash;': '√∏',
    'Otilde;': '√ï',
    'otilde;': '√µ',
    'Otimes;': '‚®∑',
    'otimes;': '‚äó',
    'parsim;': '‚´≥',
    'percnt;': '%',
    'period;': '.',
    'permil;': '‚Ä∞',
    'phmmat;': '‚Ñ≥',
    'planck;': '‚Ñè',
    'plankv;': '‚Ñè',
    'plusdo;': '‚àî',
    'plusdu;': '‚®•',
    'plusmn;': '¬±',
    'preceq;': '‚™Ø',
    'primes;': '‚Ñô',
    'prnsim;': '‚ã®',
    'propto;': '‚àù',
    'prurel;': '‚ä∞',
    'puncsp;': '‚Äà',
    'qprime;': '‚Åó',
    'Racute;': '≈î',
    'racute;': '≈ï',
    'rangle;': '‚ü©',
    'rarrap;': '‚•µ',
    'rarrfs;': '‚§û',
    'rarrhk;': '‚Ü™',
    'rarrlp;': '‚Ü¨',
    'rarrpl;': '‚•Ö',
    'Rarrtl;': '‚§ñ',
    'rarrtl;': '‚Ü£',
    'rAtail;': '‚§ú',
    'ratail;': '‚§ö',
    'rbrace;': '}',
    'rbrack;': ']',
    'Rcaron;': '≈ò',
    'rcaron;': '≈ô',
    'Rcedil;': '≈ñ',
    'rcedil;': '≈ó',
    'rdquor;': '‚Äù',
    'rfisht;': '‚•Ω',
    'rfloor;': '‚åã',
    'rharul;': '‚•¨',
    'rmoust;': '‚é±',
    'roplus;': '‚®Æ',
    'rpargt;': '‚¶î',
    'rsaquo;': '‚Ä∫',
    'rsquor;': '‚Äô',
    'rthree;': '‚ãå',
    'rtimes;': '‚ãä',
    'Sacute;': '≈ö',
    'sacute;': '≈õ',
    'Scaron;': '≈†',
    'scaron;': '≈°',
    'Scedil;': '≈û',
    'scedil;': '≈ü',
    'scnsim;': '‚ã©',
    'searhk;': '‚§•',
    'seswar;': '‚§©',
    'sfrown;': '‚å¢',
    'SHCHcy;': '–©',
    'shchcy;': '—â',
    'sigmaf;': 'œÇ',
    'sigmav;': 'œÇ',
    'simdot;': '‚©™',
    'smashp;': '‚®≥',
    'SOFTcy;': '–¨',
    'softcy;': '—å',
    'solbar;': '‚åø',
    'spades;': '‚ô†',
    'sqcaps;': '‚äìÔ∏Ä',
    'sqcups;': '‚äîÔ∏Ä',
    'sqsube;': '‚äë',
    'sqsupe;': '‚äí',
    'Square;': '‚ñ°',
    'square;': '‚ñ°',
    'squarf;': '‚ñ™',
    'ssetmn;': '‚àñ',
    'ssmile;': '‚å£',
    'sstarf;': '‚ãÜ',
    'subdot;': '‚™Ω',
    'Subset;': '‚ãê',
    'subset;': '‚äÇ',
    'subsim;': '‚´á',
    'subsub;': '‚´ï',
    'subsup;': '‚´ì',
    'succeq;': '‚™∞',
    'supdot;': '‚™æ',
    'Supset;': '‚ãë',
    'supset;': '‚äÉ',
    'supsim;': '‚´à',
    'supsub;': '‚´î',
    'supsup;': '‚´ñ',
    'swarhk;': '‚§¶',
    'swnwar;': '‚§™',
    'target;': '‚åñ',
    'Tcaron;': '≈§',
    'tcaron;': '≈•',
    'Tcedil;': '≈¢',
    'tcedil;': '≈£',
    'telrec;': '‚åï',
    'there4;': '‚à¥',
    'thetav;': 'œë',
    'thinsp;': '‚Äâ',
    'thksim;': '‚àº',
    'timesb;': '‚ä†',
    'timesd;': '‚®∞',
    'topbot;': '‚å∂',
    'topcir;': '‚´±',
    'tprime;': '‚Ä¥',
    'tridot;': '‚ó¨',
    'Tstrok;': '≈¶',
    'tstrok;': '≈ß',
    'Uacute;': '√ö',
    'uacute;': '√∫',
    'Ubreve;': '≈¨',
    'ubreve;': '≈≠',
    'Udblac;': '≈∞',
    'udblac;': '≈±',
    'ufisht;': '‚•æ',
    'Ugrave;': '√ô',
    'ugrave;': '√π',
    'ulcorn;': '‚åú',
    'ulcrop;': '‚åè',
    'urcorn;': '‚åù',
    'urcrop;': '‚åé',
    'Utilde;': '≈®',
    'utilde;': '≈©',
    'vangrt;': '‚¶ú',
    'varphi;': 'œï',
    'varrho;': 'œ±',
    'Vdashl;': '‚´¶',
    'veebar;': '‚äª',
    'vellip;': '‚ãÆ',
    'Verbar;': '‚Äñ',
    'verbar;': '|',
    'vsubnE;': '‚´ãÔ∏Ä',
    'vsubne;': '‚ääÔ∏Ä',
    'vsupnE;': '‚´åÔ∏Ä',
    'vsupne;': '‚äãÔ∏Ä',
    'Vvdash;': '‚ä™',
    'wedbar;': '‚©ü',
    'wedgeq;': '‚âô',
    'weierp;': '‚Ñò',
    'wreath;': '‚âÄ',
    'xoplus;': '‚®Å',
    'xotime;': '‚®Ç',
    'xsqcup;': '‚®Ü',
    'xuplus;': '‚®Ñ',
    'xwedge;': '‚ãÄ',
    'Yacute;': '√ù',
    'yacute;': '√Ω',
    'Zacute;': '≈π',
    'zacute;': '≈∫',
    'Zcaron;': '≈Ω',
    'zcaron;': '≈æ',
    'zeetrf;': '‚Ñ®',
    'alefsym;': '‚Ñµ',
    'angrtvb;': '‚äæ',
    'angzarr;': '‚çº',
    'asympeq;': '‚âç',
    'backsim;': '‚àΩ',
    'Because;': '‚àµ',
    'because;': '‚àµ',
    'bemptyv;': '‚¶∞',
    'between;': '‚â¨',
    'bigcirc;': '‚óØ',
    'bigodot;': '‚®Ä',
    'bigstar;': '‚òÖ',
    'bnequiv;': '‚â°‚É•',
    'boxplus;': '‚äû',
    'Cayleys;': '‚Ñ≠',
    'Cconint;': '‚à∞',
    'ccupssm;': '‚©ê',
    'Cedilla;': '¬∏',
    'cemptyv;': '‚¶≤',
    'cirscir;': '‚ßÇ',
    'coloneq;': '‚âî',
    'congdot;': '‚©≠',
    'cudarrl;': '‚§∏',
    'cudarrr;': '‚§µ',
    'cularrp;': '‚§Ω',
    'curarrm;': '‚§º',
    'dbkarow;': '‚§è',
    'ddagger;': '‚Ä°',
    'ddotseq;': '‚©∑',
    'demptyv;': '‚¶±',
    'Diamond;': '‚ãÑ',
    'diamond;': '‚ãÑ',
    'digamma;': 'œù',
    'dotplus;': '‚àî',
    'DownTee;': '‚ä§',
    'dwangle;': '‚¶¶',
    'Element;': '‚àà',
    'Epsilon;': 'Œï',
    'epsilon;': 'Œµ',
    'eqcolon;': '‚âï',
    'equivDD;': '‚©∏',
    'gesdoto;': '‚™Ç',
    'gtquest;': '‚©º',
    'gtrless;': '‚â∑',
    'harrcir;': '‚•à',
    'Implies;': '‚áí',
    'intprod;': '‚®º',
    'isindot;': '‚ãµ',
    'larrbfs;': '‚§ü',
    'larrsim;': '‚•≥',
    'lbrksld;': '‚¶è',
    'lbrkslu;': '‚¶ç',
    'ldrdhar;': '‚•ß',
    'LeftTee;': '‚ä£',
    'lesdoto;': '‚™Å',
    'lessdot;': '‚ãñ',
    'lessgtr;': '‚â∂',
    'lesssim;': '‚â≤',
    'lotimes;': '‚®¥',
    'lozenge;': '‚óä',
    'ltquest;': '‚©ª',
    'luruhar;': '‚•¶',
    'maltese;': '‚ú†',
    'minusdu;': '‚®™',
    'napprox;': '‚ââ',
    'natural;': '‚ôÆ',
    'nearrow;': '‚Üó',
    'NewLine;': '\n',
    'nexists;': '‚àÑ',
    'NoBreak;': '‚Å†',
    'notinva;': '‚àâ',
    'notinvb;': '‚ã∑',
    'notinvc;': '‚ã∂',
    'NotLess;': '‚âÆ',
    'notniva;': '‚àå',
    'notnivb;': '‚ãæ',
    'notnivc;': '‚ãΩ',
    'npolint;': '‚®î',
    'npreceq;': '‚™ØÃ∏',
    'nsqsube;': '‚ã¢',
    'nsqsupe;': '‚ã£',
    'nsubset;': '‚äÇ‚Éí',
    'nsucceq;': '‚™∞Ã∏',
    'nsupset;': '‚äÉ‚Éí',
    'nvinfin;': '‚ßû',
    'nvltrie;': '‚ä¥‚Éí',
    'nvrtrie;': '‚äµ‚Éí',
    'nwarrow;': '‚Üñ',
    'olcross;': '‚¶ª',
    'Omicron;': 'Œü',
    'omicron;': 'Œø',
    'orderof;': '‚Ñ¥',
    'orslope;': '‚©ó',
    'OverBar;': '‚Äæ',
    'pertenk;': '‚Ä±',
    'planckh;': '‚Ñé',
    'pluscir;': '‚®¢',
    'plussim;': '‚®¶',
    'plustwo;': '‚®ß',
    'precsim;': '‚âæ',
    'Product;': '‚àè',
    'quatint;': '‚®ñ',
    'questeq;': '‚âü',
    'rarrbfs;': '‚§†',
    'rarrsim;': '‚•¥',
    'rbrksld;': '‚¶é',
    'rbrkslu;': '‚¶ê',
    'rdldhar;': '‚•©',
    'realine;': '‚Ñõ',
    'rotimes;': '‚®µ',
    'ruluhar;': '‚•®',
    'searrow;': '‚Üò',
    'simplus;': '‚®§',
    'simrarr;': '‚•≤',
    'subedot;': '‚´É',
    'submult;': '‚´Å',
    'subplus;': '‚™ø',
    'subrarr;': '‚•π',
    'succsim;': '‚âø',
    'supdsub;': '‚´ò',
    'supedot;': '‚´Ñ',
    'suphsol;': '‚üâ',
    'suphsub;': '‚´ó',
    'suplarr;': '‚•ª',
    'supmult;': '‚´Ç',
    'supplus;': '‚´Ä',
    'swarrow;': '‚Üô',
    'topfork;': '‚´ö',
    'triplus;': '‚®π',
    'tritime;': '‚®ª',
    'UpArrow;': '‚Üë',
    'Uparrow;': '‚áë',
    'uparrow;': '‚Üë',
    'Upsilon;': 'Œ•',
    'upsilon;': 'œÖ',
    'uwangle;': '‚¶ß',
    'vzigzag;': '‚¶ö',
    'zigrarr;': '‚áù',
    'andslope;': '‚©ò',
    'angmsdaa;': '‚¶®',
    'angmsdab;': '‚¶©',
    'angmsdac;': '‚¶™',
    'angmsdad;': '‚¶´',
    'angmsdae;': '‚¶¨',
    'angmsdaf;': '‚¶≠',
    'angmsdag;': '‚¶Æ',
    'angmsdah;': '‚¶Ø',
    'angrtvbd;': '‚¶ù',
    'approxeq;': '‚âä',
    'awconint;': '‚à≥',
    'backcong;': '‚âå',
    'barwedge;': '‚åÖ',
    'bbrktbrk;': '‚é∂',
    'bigoplus;': '‚®Å',
    'bigsqcup;': '‚®Ü',
    'biguplus;': '‚®Ñ',
    'bigwedge;': '‚ãÄ',
    'boxminus;': '‚äü',
    'boxtimes;': '‚ä†',
    'bsolhsub;': '‚üà',
    'capbrcup;': '‚©â',
    'circledR;': '¬Æ',
    'circledS;': '‚ìà',
    'cirfnint;': '‚®ê',
    'clubsuit;': '‚ô£',
    'cupbrcap;': '‚©à',
    'curlyvee;': '‚ãé',
    'cwconint;': '‚à≤',
    'DDotrahd;': '‚§ë',
    'doteqdot;': '‚âë',
    'DotEqual;': '‚âê',
    'dotminus;': '‚à∏',
    'drbkarow;': '‚§ê',
    'dzigrarr;': '‚üø',
    'elinters;': '‚èß',
    'emptyset;': '‚àÖ',
    'eqvparsl;': '‚ß•',
    'fpartint;': '‚®ç',
    'geqslant;': '‚©æ',
    'gesdotol;': '‚™Ñ',
    'gnapprox;': '‚™ä',
    'hksearow;': '‚§•',
    'hkswarow;': '‚§¶',
    'imagline;': '‚Ñê',
    'imagpart;': '‚Ñë',
    'infintie;': '‚ßù',
    'integers;': '‚Ñ§',
    'Integral;': '‚à´',
    'intercal;': '‚ä∫',
    'intlarhk;': '‚®ó',
    'laemptyv;': '‚¶¥',
    'ldrushar;': '‚•ã',
    'leqslant;': '‚©Ω',
    'lesdotor;': '‚™É',
    'LessLess;': '‚™°',
    'llcorner;': '‚åû',
    'lnapprox;': '‚™â',
    'lrcorner;': '‚åü',
    'lurdshar;': '‚•ä',
    'mapstoup;': '‚Ü•',
    'multimap;': '‚ä∏',
    'naturals;': '‚Ñï',
    'ncongdot;': '‚©≠Ã∏',
    'NotEqual;': '‚â†',
    'notindot;': '‚ãµÃ∏',
    'NotTilde;': '‚âÅ',
    'otimesas;': '‚®∂',
    'parallel;': '‚à•',
    'PartialD;': '‚àÇ',
    'plusacir;': '‚®£',
    'pointint;': '‚®ï',
    'Precedes;': '‚â∫',
    'precneqq;': '‚™µ',
    'precnsim;': '‚ã®',
    'profalar;': '‚åÆ',
    'profline;': '‚åí',
    'profsurf;': '‚åì',
    'raemptyv;': '‚¶≥',
    'realpart;': '‚Ñú',
    'RightTee;': '‚ä¢',
    'rppolint;': '‚®í',
    'rtriltri;': '‚ßé',
    'scpolint;': '‚®ì',
    'setminus;': '‚àñ',
    'shortmid;': '‚à£',
    'smeparsl;': '‚ß§',
    'sqsubset;': '‚äè',
    'sqsupset;': '‚äê',
    'subseteq;': '‚äÜ',
    'Succeeds;': '‚âª',
    'succneqq;': '‚™∂',
    'succnsim;': '‚ã©',
    'SuchThat;': '‚àã',
    'Superset;': '‚äÉ',
    'supseteq;': '‚äá',
    'thetasym;': 'œë',
    'thicksim;': '‚àº',
    'timesbar;': '‚®±',
    'triangle;': '‚ñµ',
    'triminus;': '‚®∫',
    'trpezium;': '‚è¢',
    'Uarrocir;': '‚•â',
    'ulcorner;': '‚åú',
    'UnderBar;': '_',
    'urcorner;': '‚åù',
    'varkappa;': 'œ∞',
    'varsigma;': 'œÇ',
    'vartheta;': 'œë',
    'backprime;': '‚Äµ',
    'backsimeq;': '‚ãç',
    'Backslash;': '‚àñ',
    'bigotimes;': '‚®Ç',
    'CenterDot;': '¬∑',
    'centerdot;': '¬∑',
    'checkmark;': '‚úì',
    'CircleDot;': '‚äô',
    'complexes;': '‚ÑÇ',
    'Congruent;': '‚â°',
    'Coproduct;': '‚àê',
    'dotsquare;': '‚ä°',
    'DoubleDot;': '¬®',
    'DownArrow;': '‚Üì',
    'Downarrow;': '‚áì',
    'downarrow;': '‚Üì',
    'DownBreve;': 'Ãë',
    'gtrapprox;': '‚™Ü',
    'gtreqless;': '‚ãõ',
    'gvertneqq;': '‚â©Ô∏Ä',
    'heartsuit;': '‚ô•',
    'HumpEqual;': '‚âè',
    'LeftArrow;': '‚Üê',
    'Leftarrow;': '‚áê',
    'leftarrow;': '‚Üê',
    'LeftFloor;': '‚åä',
    'lesseqgtr;': '‚ãö',
    'LessTilde;': '‚â≤',
    'lvertneqq;': '‚â®Ô∏Ä',
    'Mellintrf;': '‚Ñ≥',
    'MinusPlus;': '‚àì',
    'ngeqslant;': '‚©æÃ∏',
    'nleqslant;': '‚©ΩÃ∏',
    'NotCupCap;': '‚â≠',
    'NotExists;': '‚àÑ',
    'NotSubset;': '‚äÇ‚Éí',
    'nparallel;': '‚à¶',
    'nshortmid;': '‚à§',
    'nsubseteq;': '‚äà',
    'nsupseteq;': '‚äâ',
    'OverBrace;': '‚èû',
    'pitchfork;': '‚ãî',
    'PlusMinus;': '¬±',
    'rationals;': '‚Ñö',
    'spadesuit;': '‚ô†',
    'subseteqq;': '‚´Ö',
    'subsetneq;': '‚ää',
    'supseteqq;': '‚´Ü',
    'supsetneq;': '‚äã',
    'Therefore;': '‚à¥',
    'therefore;': '‚à¥',
    'ThinSpace;': '‚Äâ',
    'triangleq;': '‚âú',
    'TripleDot;': '‚Éõ',
    'UnionPlus;': '‚äé',
    'varpropto;': '‚àù',
    'Bernoullis;': '‚Ñ¨',
    'circledast;': '‚äõ',
    'CirclePlus;': '‚äï',
    'complement;': '‚àÅ',
    'curlywedge;': '‚ãè',
    'eqslantgtr;': '‚™ñ',
    'EqualTilde;': '‚âÇ',
    'Fouriertrf;': '‚Ñ±',
    'gtreqqless;': '‚™å',
    'ImaginaryI;': '‚Öà',
    'Laplacetrf;': '‚Ñí',
    'LeftVector;': '‚Üº',
    'lessapprox;': '‚™Ö',
    'lesseqqgtr;': '‚™ã',
    'Lleftarrow;': '‚áö',
    'lmoustache;': '‚é∞',
    'longmapsto;': '‚üº',
    'mapstodown;': '‚Üß',
    'mapstoleft;': '‚Ü§',
    'nLeftarrow;': '‚áç',
    'nleftarrow;': '‚Üö',
    'NotElement;': '‚àâ',
    'NotGreater;': '‚âØ',
    'nsubseteqq;': '‚´ÖÃ∏',
    'nsupseteqq;': '‚´ÜÃ∏',
    'precapprox;': '‚™∑',
    'Proportion;': '‚à∑',
    'RightArrow;': '‚Üí',
    'Rightarrow;': '‚áí',
    'rightarrow;': '‚Üí',
    'RightFloor;': '‚åã',
    'rmoustache;': '‚é±',
    'sqsubseteq;': '‚äë',
    'sqsupseteq;': '‚äí',
    'subsetneqq;': '‚´ã',
    'succapprox;': '‚™∏',
    'supsetneqq;': '‚´å',
    'ThickSpace;': '‚Åü‚Ää',
    'TildeEqual;': '‚âÉ',
    'TildeTilde;': '‚âà',
    'UnderBrace;': '‚èü',
    'UpArrowBar;': '‚§í',
    'UpTeeArrow;': '‚Ü•',
    'upuparrows;': '‚áà',
    'varepsilon;': 'œµ',
    'varnothing;': '‚àÖ',
    'backepsilon;': 'œ∂',
    'blacksquare;': '‚ñ™',
    'circledcirc;': '‚äö',
    'circleddash;': '‚äù',
    'CircleMinus;': '‚äñ',
    'CircleTimes;': '‚äó',
    'curlyeqprec;': '‚ãû',
    'curlyeqsucc;': '‚ãü',
    'diamondsuit;': '‚ô¶',
    'eqslantless;': '‚™ï',
    'Equilibrium;': '‚áå',
    'expectation;': '‚Ñ∞',
    'GreaterLess;': '‚â∑',
    'LeftCeiling;': '‚åà',
    'LessGreater;': '‚â∂',
    'MediumSpace;': '‚Åü',
    'NotLessLess;': '‚â™Ã∏',
    'NotPrecedes;': '‚äÄ',
    'NotSucceeds;': '‚äÅ',
    'NotSuperset;': '‚äÉ‚Éí',
    'nRightarrow;': '‚áè',
    'nrightarrow;': '‚Üõ',
    'OverBracket;': '‚é¥',
    'preccurlyeq;': '‚âº',
    'precnapprox;': '‚™π',
    'quaternions;': '‚Ñç',
    'RightVector;': '‚áÄ',
    'Rrightarrow;': '‚áõ',
    'RuleDelayed;': '‚ß¥',
    'SmallCircle;': '‚àò',
    'SquareUnion;': '‚äî',
    'straightphi;': 'œï',
    'SubsetEqual;': '‚äÜ',
    'succcurlyeq;': '‚âΩ',
    'succnapprox;': '‚™∫',
    'thickapprox;': '‚âà',
    'UpDownArrow;': '‚Üï',
    'Updownarrow;': '‚áï',
    'updownarrow;': '‚Üï',
    'VerticalBar;': '‚à£',
    'blacklozenge;': '‚ß´',
    'DownArrowBar;': '‚§ì',
    'DownTeeArrow;': '‚Üß',
    'ExponentialE;': '‚Öá',
    'exponentiale;': '‚Öá',
    'GreaterEqual;': '‚â•',
    'GreaterTilde;': '‚â≥',
    'HilbertSpace;': '‚Ñã',
    'HumpDownHump;': '‚âé',
    'Intersection;': '‚ãÇ',
    'LeftArrowBar;': '‚á§',
    'LeftTeeArrow;': '‚Ü§',
    'LeftTriangle;': '‚ä≤',
    'LeftUpVector;': '‚Üø',
    'NotCongruent;': '‚â¢',
    'NotHumpEqual;': '‚âèÃ∏',
    'NotLessEqual;': '‚â∞',
    'NotLessTilde;': '‚â¥',
    'Proportional;': '‚àù',
    'RightCeiling;': '‚åâ',
    'risingdotseq;': '‚âì',
    'RoundImplies;': '‚•∞',
    'ShortUpArrow;': '‚Üë',
    'SquareSubset;': '‚äè',
    'triangledown;': '‚ñø',
    'triangleleft;': '‚óÉ',
    'UnderBracket;': '‚éµ',
    'varsubsetneq;': '‚ääÔ∏Ä',
    'varsupsetneq;': '‚äãÔ∏Ä',
    'VerticalLine;': '|',
    'ApplyFunction;': '‚Å°',
    'bigtriangleup;': '‚ñ≥',
    'blacktriangle;': '‚ñ¥',
    'DifferentialD;': '‚ÖÜ',
    'divideontimes;': '‚ãá',
    'DoubleLeftTee;': '‚´§',
    'DoubleUpArrow;': '‚áë',
    'fallingdotseq;': '‚âí',
    'hookleftarrow;': '‚Ü©',
    'leftarrowtail;': '‚Ü¢',
    'leftharpoonup;': '‚Üº',
    'LeftTeeVector;': '‚•ö',
    'LeftVectorBar;': '‚•í',
    'LessFullEqual;': '‚â¶',
    'LongLeftArrow;': '‚üµ',
    'Longleftarrow;': '‚ü∏',
    'longleftarrow;': '‚üµ',
    'looparrowleft;': '‚Ü´',
    'measuredangle;': '‚à°',
    'NotEqualTilde;': '‚âÇÃ∏',
    'NotTildeEqual;': '‚âÑ',
    'NotTildeTilde;': '‚ââ',
    'ntriangleleft;': '‚ã™',
    'Poincareplane;': '‚Ñå',
    'PrecedesEqual;': '‚™Ø',
    'PrecedesTilde;': '‚âæ',
    'RightArrowBar;': '‚á•',
    'RightTeeArrow;': '‚Ü¶',
    'RightTriangle;': '‚ä≥',
    'RightUpVector;': '‚Üæ',
    'shortparallel;': '‚à•',
    'smallsetminus;': '‚àñ',
    'SucceedsEqual;': '‚™∞',
    'SucceedsTilde;': '‚âø',
    'SupersetEqual;': '‚äá',
    'triangleright;': '‚ñπ',
    'UpEquilibrium;': '‚•Æ',
    'upharpoonleft;': '‚Üø',
    'varsubsetneqq;': '‚´ãÔ∏Ä',
    'varsupsetneqq;': '‚´åÔ∏Ä',
    'VerticalTilde;': '‚âÄ',
    'VeryThinSpace;': '‚Ää',
    'curvearrowleft;': '‚Ü∂',
    'DiacriticalDot;': 'Àô',
    'doublebarwedge;': '‚åÜ',
    'DoubleRightTee;': '‚ä®',
    'downdownarrows;': '‚áä',
    'DownLeftVector;': '‚ÜΩ',
    'GreaterGreater;': '‚™¢',
    'hookrightarrow;': '‚Ü™',
    'HorizontalLine;': '‚îÄ',
    'InvisibleComma;': '‚Å£',
    'InvisibleTimes;': '‚Å¢',
    'LeftDownVector;': '‚áÉ',
    'leftleftarrows;': '‚áá',
    'LeftRightArrow;': '‚Üî',
    'Leftrightarrow;': '‚áî',
    'leftrightarrow;': '‚Üî',
    'leftthreetimes;': '‚ãã',
    'LessSlantEqual;': '‚©Ω',
    'LongRightArrow;': '‚ü∂',
    'Longrightarrow;': '‚üπ',
    'longrightarrow;': '‚ü∂',
    'looparrowright;': '‚Ü¨',
    'LowerLeftArrow;': '‚Üô',
    'NestedLessLess;': '‚â™',
    'NotGreaterLess;': '‚âπ',
    'NotLessGreater;': '‚â∏',
    'NotSubsetEqual;': '‚äà',
    'NotVerticalBar;': '‚à§',
    'nshortparallel;': '‚à¶',
    'ntriangleright;': '‚ã´',
    'OpenCurlyQuote;': '‚Äò',
    'ReverseElement;': '‚àã',
    'rightarrowtail;': '‚Ü£',
    'rightharpoonup;': '‚áÄ',
    'RightTeeVector;': '‚•õ',
    'RightVectorBar;': '‚•ì',
    'ShortDownArrow;': '‚Üì',
    'ShortLeftArrow;': '‚Üê',
    'SquareSuperset;': '‚äê',
    'TildeFullEqual;': '‚âÖ',
    'trianglelefteq;': '‚ä¥',
    'upharpoonright;': '‚Üæ',
    'UpperLeftArrow;': '‚Üñ',
    'ZeroWidthSpace;': '‚Äã',
    'bigtriangledown;': '‚ñΩ',
    'circlearrowleft;': '‚Ü∫',
    'CloseCurlyQuote;': '‚Äô',
    'ContourIntegral;': '‚àÆ',
    'curvearrowright;': '‚Ü∑',
    'DoubleDownArrow;': '‚áì',
    'DoubleLeftArrow;': '‚áê',
    'downharpoonleft;': '‚áÉ',
    'DownRightVector;': '‚áÅ',
    'leftharpoondown;': '‚ÜΩ',
    'leftrightarrows;': '‚áÜ',
    'LeftRightVector;': '‚•é',
    'LeftTriangleBar;': '‚ßè',
    'LeftUpTeeVector;': '‚•†',
    'LeftUpVectorBar;': '‚•ò',
    'LowerRightArrow;': '‚Üò',
    'nLeftrightarrow;': '‚áé',
    'nleftrightarrow;': '‚ÜÆ',
    'NotGreaterEqual;': '‚â±',
    'NotGreaterTilde;': '‚âµ',
    'NotHumpDownHump;': '‚âéÃ∏',
    'NotLeftTriangle;': '‚ã™',
    'NotSquareSubset;': '‚äèÃ∏',
    'ntrianglelefteq;': '‚ã¨',
    'OverParenthesis;': '‚èú',
    'RightDownVector;': '‚áÇ',
    'rightleftarrows;': '‚áÑ',
    'rightsquigarrow;': '‚Üù',
    'rightthreetimes;': '‚ãå',
    'ShortRightArrow;': '‚Üí',
    'straightepsilon;': 'œµ',
    'trianglerighteq;': '‚äµ',
    'UpperRightArrow;': '‚Üó',
    'vartriangleleft;': '‚ä≤',
    'circlearrowright;': '‚Üª',
    'DiacriticalAcute;': '¬¥',
    'DiacriticalGrave;': '`',
    'DiacriticalTilde;': 'Àú',
    'DoubleRightArrow;': '‚áí',
    'DownArrowUpArrow;': '‚áµ',
    'downharpoonright;': '‚áÇ',
    'EmptySmallSquare;': '‚óª',
    'GreaterEqualLess;': '‚ãõ',
    'GreaterFullEqual;': '‚âß',
    'LeftAngleBracket;': '‚ü®',
    'LeftUpDownVector;': '‚•ë',
    'LessEqualGreater;': '‚ãö',
    'NonBreakingSpace;': ' ',
    'NotPrecedesEqual;': '‚™ØÃ∏',
    'NotRightTriangle;': '‚ã´',
    'NotSucceedsEqual;': '‚™∞Ã∏',
    'NotSucceedsTilde;': '‚âøÃ∏',
    'NotSupersetEqual;': '‚äâ',
    'ntrianglerighteq;': '‚ã≠',
    'rightharpoondown;': '‚áÅ',
    'rightrightarrows;': '‚áâ',
    'RightTriangleBar;': '‚ßê',
    'RightUpTeeVector;': '‚•ú',
    'RightUpVectorBar;': '‚•î',
    'twoheadleftarrow;': '‚Üû',
    'UnderParenthesis;': '‚èù',
    'UpArrowDownArrow;': '‚áÖ',
    'vartriangleright;': '‚ä≥',
    'blacktriangledown;': '‚ñæ',
    'blacktriangleleft;': '‚óÇ',
    'DoubleUpDownArrow;': '‚áï',
    'DoubleVerticalBar;': '‚à•',
    'DownLeftTeeVector;': '‚•û',
    'DownLeftVectorBar;': '‚•ñ',
    'FilledSmallSquare;': '‚óº',
    'GreaterSlantEqual;': '‚©æ',
    'LeftDoubleBracket;': '‚ü¶',
    'LeftDownTeeVector;': '‚•°',
    'LeftDownVectorBar;': '‚•ô',
    'leftrightharpoons;': '‚áã',
    'LeftTriangleEqual;': '‚ä¥',
    'NegativeThinSpace;': '‚Äã',
    'NotGreaterGreater;': '‚â´Ã∏',
    'NotLessSlantEqual;': '‚©ΩÃ∏',
    'NotNestedLessLess;': '‚™°Ã∏',
    'NotReverseElement;': '‚àå',
    'NotSquareSuperset;': '‚äêÃ∏',
    'NotTildeFullEqual;': '‚âá',
    'RightAngleBracket;': '‚ü©',
    'rightleftharpoons;': '‚áå',
    'RightUpDownVector;': '‚•è',
    'SquareSubsetEqual;': '‚äë',
    'twoheadrightarrow;': '‚Ü†',
    'VerticalSeparator;': '‚ùò',
    'blacktriangleright;': '‚ñ∏',
    'DownRightTeeVector;': '‚•ü',
    'DownRightVectorBar;': '‚•ó',
    'LongLeftRightArrow;': '‚ü∑',
    'Longleftrightarrow;': '‚ü∫',
    'longleftrightarrow;': '‚ü∑',
    'NegativeThickSpace;': '‚Äã',
    'NotLeftTriangleBar;': '‚ßèÃ∏',
    'PrecedesSlantEqual;': '‚âº',
    'ReverseEquilibrium;': '‚áã',
    'RightDoubleBracket;': '‚üß',
    'RightDownTeeVector;': '‚•ù',
    'RightDownVectorBar;': '‚•ï',
    'RightTriangleEqual;': '‚äµ',
    'SquareIntersection;': '‚äì',
    'SucceedsSlantEqual;': '‚âΩ',
    'DoubleLongLeftArrow;': '‚ü∏',
    'DownLeftRightVector;': '‚•ê',
    'LeftArrowRightArrow;': '‚áÜ',
    'leftrightsquigarrow;': '‚Ü≠',
    'NegativeMediumSpace;': '‚Äã',
    'NotGreaterFullEqual;': '‚âßÃ∏',
    'NotRightTriangleBar;': '‚ßêÃ∏',
    'RightArrowLeftArrow;': '‚áÑ',
    'SquareSupersetEqual;': '‚äí',
    'CapitalDifferentialD;': '‚ÖÖ',
    'DoubleLeftRightArrow;': '‚áî',
    'DoubleLongRightArrow;': '‚üπ',
    'EmptyVerySmallSquare;': '‚ñ´',
    'NestedGreaterGreater;': '‚â´',
    'NotDoubleVerticalBar;': '‚à¶',
    'NotGreaterSlantEqual;': '‚©æÃ∏',
    'NotLeftTriangleEqual;': '‚ã¨',
    'NotSquareSubsetEqual;': '‚ã¢',
    'OpenCurlyDoubleQuote;': '‚Äú',
    'ReverseUpEquilibrium;': '‚•Ø',
    'CloseCurlyDoubleQuote;': '‚Äù',
    'DoubleContourIntegral;': '‚àØ',
    'FilledVerySmallSquare;': '‚ñ™',
    'NegativeVeryThinSpace;': '‚Äã',
    'NotPrecedesSlantEqual;': '‚ã†',
    'NotRightTriangleEqual;': '‚ã≠',
    'NotSucceedsSlantEqual;': '‚ã°',
    'DiacriticalDoubleAcute;': 'Àù',
    'NotSquareSupersetEqual;': '‚ã£',
    'NotNestedGreaterGreater;': '‚™¢Ã∏',
    'ClockwiseContourIntegral;': '‚à≤',
    'DoubleLongLeftRightArrow;': '‚ü∫',
    'CounterClockwiseContourIntegral;': '‚à≥',
};

const maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0);
const decodeHtml = (rawText, asAttr) => {
    var _a, _b;
    let offset = 0;
    const end = rawText.length;
    let decodedText = '';
    function advance(length) {
        offset += length;
        rawText = rawText.slice(length);
    }
    while (offset < end) {
        const head = /&(?:#x?)?/i.exec(rawText);
        if (head == null || offset + head.index >= end) {
            const remaining = end - offset;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
        }
        // Advance to the "&".
        decodedText += rawText.slice(0, head.index);
        advance(head.index);
        if (head[0] === '&') {
            // Named character reference.
            let name = '';
            let value;
            if (rawText[1] != null && /[0-9a-z]/i.test(rawText[1])) {
                for (let length = maxCRNameLength; value != null && length > 0; --length) {
                    name = rawText.substr(1, length);
                    value = namedCharacterReferences[name];
                }
                if (value != null) {
                    const semi = name.endsWith(';');
                    if (asAttr &&
                        !semi &&
                        /[=a-z0-9]/i.test((_a = rawText[name.length + 1]) !== null && _a !== void 0 ? _a : '')) {
                        decodedText += '&' + name;
                        advance(1 + name.length);
                    }
                    else {
                        decodedText += value;
                        advance(1 + name.length);
                    }
                }
                else {
                    decodedText += '&' + name;
                    advance(1 + name.length);
                }
            }
            else {
                decodedText += '&';
                advance(1);
            }
        }
        else {
            // Numeric character reference.
            const hex = head[0] === '&#x';
            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern.exec(rawText);
            if (body == null) {
                if (head[0] != null) {
                    decodedText = `${decodedText}${head[0]}`;
                    advance(head[0].length);
                }
            }
            else if (body[1] != null) {
                // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
                let cp = Number.parseInt(body[1], hex ? 16 : 10);
                if (cp === 0) {
                    cp = 0xfffd;
                }
                else if (cp > 0x10ffff) {
                    cp = 0xfffd;
                }
                else if (cp >= 0xd800 && cp <= 0xdfff) {
                    cp = 0xfffd;
                }
                else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) ;
                else if ((cp >= 0x01 && cp <= 0x08) ||
                    cp === 0x0b ||
                    (cp >= 0x0d && cp <= 0x1f) ||
                    (cp >= 0x7f && cp <= 0x9f)) {
                    cp = (_b = CCR_REPLACEMENTS[cp]) !== null && _b !== void 0 ? _b : cp;
                }
                decodedText += String.fromCodePoint(cp);
                if (body[0] != null)
                    advance(body[0].length);
            }
        }
    }
    return decodedText;
};
// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
    0x80: 0x20ac,
    0x82: 0x201a,
    0x83: 0x0192,
    0x84: 0x201e,
    0x85: 0x2026,
    0x86: 0x2020,
    0x87: 0x2021,
    0x88: 0x02c6,
    0x89: 0x2030,
    0x8a: 0x0160,
    0x8b: 0x2039,
    0x8c: 0x0152,
    0x8e: 0x017d,
    0x91: 0x2018,
    0x92: 0x2019,
    0x93: 0x201c,
    0x94: 0x201d,
    0x95: 0x2022,
    0x96: 0x2013,
    0x97: 0x2014,
    0x98: 0x02dc,
    0x99: 0x2122,
    0x9a: 0x0161,
    0x9b: 0x203a,
    0x9c: 0x0153,
    0x9e: 0x017e,
    0x9f: 0x0178,
};

const RAW_TEXT_TAGS = new Set(['style', 'iframe', 'script', 'noscript']);
const isRawTextContainer = (tagName) => RAW_TEXT_TAGS.has(tagName);
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = new Set(('html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot').split(','));
const isHTMLTag = (tagName) => HTML_TAGS.has(tagName);
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = new Set(('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view').split(','));
const isSVGTag = (tagName) => SVG_TAGS.has(tagName);
const VOID_TAGS = new Set('area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'.split(','));
const isVoidTag = (tagName) => VOID_TAGS.has(tagName);
const parserOptions = {
    isVoidTag,
    isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
    isPreTag: (tag) => tag === 'pre',
    decodeEntities: decodeHtml,
    isBuiltInComponent: () => { },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent != null ? parent.ns : 0 /* HTML */;
        if (parent != null && ns === 2 /* MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* SVG */;
                }
                if (parent.props.some((a) => a.type === 6 /* ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* HTML */;
            }
        }
        else if (parent != null && ns === 1 /* SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* HTML */;
            }
        }
        if (ns === 0 /* HTML */) {
            if (tag === 'svg') {
                return 1 /* SVG */;
            }
            if (tag === 'math') {
                return 2 /* MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* RAWTEXT */;
            }
        }
        return 0 /* DATA */;
    },
};

function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation(Object.assign({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function createLoc(loc, offset, length) {
    if (loc == null)
        return;
    const source = loc.source.substr(offset, length);
    const start = advancePositionWithClone(loc.start, loc.source.substr(0, offset));
    const end = advancePositionWithClone(start, source);
    return { source, start, end };
}

function createExpressionTracker(addIdentifer) {
    return (node, context) => {
        const localIdentifiers = new Set();
        if (isInterpolationNode(node)) {
            if (isSimpleExpressionNode(node.content) &&
                !node.content.isStatic &&
                node.content.content.trim() !== '') {
                trackIdentifiers(node.content.content, context, node.content.loc.start, addIdentifer);
            }
        }
        else if (isElementNode(node)) {
            node.props.forEach((dir) => {
                if (isDirectiveNode(dir)) {
                    if (isSimpleExpressionNode(dir.arg) &&
                        !dir.arg.isStatic &&
                        dir.arg.content.trim() !== '') {
                        trackIdentifiers(dir.arg.content, context, dir.arg.loc.start, addIdentifer);
                    }
                    const slot = findDir(node, 'slot');
                    if (slot != null) {
                        if (isSimpleExpressionNode(slot.exp) &&
                            !slot.exp.isStatic &&
                            slot.exp.content.trim() !== '') {
                            trackIdentifiers(slot.exp.content, context, slot.exp.loc.start, (identifier) => {
                                localIdentifiers.add(identifier);
                                context.addIdentifiers(identifier);
                            }, dir.name === 'slot');
                        }
                    }
                    switch (dir.name) {
                        case 'for':
                        case 'slot':
                            break;
                        case 'on':
                            if (isSimpleExpressionNode(dir.exp) &&
                                !dir.exp.isStatic &&
                                dir.exp.content.trim() !== '') {
                                context.addIdentifiers('$event');
                                trackIdentifiers(dir.exp.content, context, dir.exp.loc.start, addIdentifer, false, true);
                                context.removeIdentifiers('$event');
                            }
                            break;
                        default: {
                            if (isSimpleExpressionNode(dir.exp) &&
                                dir.exp.content.trim() !== '') {
                                trackIdentifiers(dir.exp.content, context, dir.exp.loc.start, addIdentifer);
                            }
                        }
                    }
                }
            });
        }
        return () => {
            localIdentifiers.forEach((identifier) => context.removeIdentifiers(identifier));
        };
    };
}
const KNOWN_IDENTIFIERS = new Set(('Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl').split(','));
function isKnownIdentifier(value) {
    return KNOWN_IDENTIFIERS.has(value) || /^(true|false|null|this)$/.test(value);
}
function trackIdentifiers(rawExp, context, start, addIdentifer, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false) {
    var _a, _b;
    rawExp = rawExp
        .trim()
        // Handle common incomplete expressions
        .replace(/(\.|\[\]?)$/, '');
    if (rawExp.trim() === '')
        return;
    if (isSimpleIdentifier(rawExp)) {
        if (!asParams &&
            ((_a = context.identifiers[rawExp]) !== null && _a !== void 0 ? _a : 0) === 0 &&
            !isKnownIdentifier(rawExp)) {
            addIdentifer(rawExp);
        }
        return;
    }
    const source = asRawStatements
        ? ` ${rawExp} `
        : `(${rawExp})${asParams ? `=>{}` : ``}`;
    try {
        const ast = parse$1(source, {
            plugins: [
                'bigInt',
                'optionalChaining',
                'nullishCoalescingOperator',
                'typescript',
            ],
            // @ts-expect-error
            errorRecovery: true,
        });
        const knownIds = { ...context.identifiers };
        traverse(ast, {
            enter(node, ancestors) {
                var _a, _b;
                const scope = new Set();
                const parent = (_a = ancestors[ancestors.length - 1]) === null || _a === void 0 ? void 0 : _a.node;
                if (isIdentifier(node)) {
                    if (((_b = knownIds[node.name]) !== null && _b !== void 0 ? _b : 0) === 0) {
                        if (shouldTrack$1(node, parent)) {
                            addIdentifer(node.name);
                        }
                    }
                }
                else if (isFunction(node)) {
                    node.params.forEach((param) => traverseFast(param, (node, ancestors) => {
                        var _a;
                        const parent = (_a = ancestors[ancestors.length - 1]) === null || _a === void 0 ? void 0 : _a.node;
                        if (parent != null &&
                            isIdentifier(node) &&
                            !isStaticProperty(parent) &&
                            !(isAssignmentPattern(parent) && parent.right === node)) {
                            const id = node.name;
                            if (!scope.has(id)) {
                                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                if (id in knownIds)
                                    ++knownIds[id];
                                else
                                    knownIds[id] = 1;
                            }
                            scope.add(id);
                        }
                    }));
                }
                // @ts-expect-error
                node.scope = scope;
            },
            exit(node) {
                // @ts-expect-error
                const scope = node.scope;
                scope === null || scope === void 0 ? void 0 : scope.forEach((id) => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    --knownIds[id];
                });
            },
        });
    }
    catch (error) {
        const RE = /\b[a-z$_][a-z0-9$_]*\b/gi;
        let match = null;
        do {
            match = RE.exec(source);
            if ((match === null || match === void 0 ? void 0 : match[0]) != null)
                addIdentifer(match[0]);
        } while (match != null);
        const pos = (_b = error.pos) !== null && _b !== void 0 ? _b : 0;
        context.onError({
            name: error.code,
            message: `Failed to analyze expression. Error: ${String(error.message)}`,
            code: 1000,
            loc: {
                source: rawExp,
                start: advancePositionWithClone(start, rawExp, pos - 1),
                end: advancePositionWithClone(start, rawExp, pos),
            },
        });
    }
}
function isStaticProperty(node) {
    return isObjectMember(node) && !node.computed;
}
function isStaticPropertyKey(node, parent) {
    return isStaticProperty(parent) && parent.key === node;
}
function shouldTrack$1(identifier, parent) {
    if (parent == null)
        return true;
    if (!(isFunction(parent) &&
        // not id of a FunctionDeclaration
        (parent.id === identifier ||
            // not a params of a function
            parent.params.includes(identifier))) &&
        // not a key of Property
        !isStaticPropertyKey(identifier, parent) &&
        // not a property of a MemberExpression
        !((isMemberExpression(parent) || isOptionalMemberExpression(parent)) &&
            parent.property === identifier &&
            !parent.computed) &&
        // not in an Array destructure pattern
        !isArrayPattern(parent) &&
        // skip whitelisted globals
        !isKnownIdentifier(identifier.name) &&
        // special case for webpack compilation
        identifier.name !== `require` &&
        // is a special keyword but parsed as identifier
        identifier.name !== `arguments`) {
        return true;
    }
    return false;
}

function createElementTransform(options, expressions) {
    let isImportAdded = false;
    let dynamicComponentCounter = 0;
    const globalsExpressions = [];
    const addHoistScope = () => {
        globalsExpressions.push(expressions.slice());
        expressions.length = 0;
    };
    const removeHoistScope = () => {
        const exps = globalsExpressions.pop();
        if (Array.isArray(exps)) {
            expressions.length = 0;
            expressions.push(...exps);
        }
    };
    const hoist = (exp) => {
        const name = `_DyComp${dynamicComponentCounter++}`.padEnd('component'.length, '_');
        expressions.push(createCompoundExpression([`const `, name, ' = ', exp, ';']));
        return name;
    };
    return (node, context) => {
        var _a, _b;
        if (!isImportAdded) {
            context.imports.push({
                exp: '_Ctx',
                path: getInternalPath(options),
            });
            isImportAdded = true;
        }
        if (isTextNode(node)) {
            markNonElementNode(node);
        }
        if (!isElementNode(node))
            return;
        let resolvedComponentName;
        const slotDir = findDir(node, 'slot');
        const hasScope = isComponentNode(node) || slotDir != null;
        if (hasScope)
            addHoistScope();
        if (isComponentNode(node)) {
            if (!['component', 'slot'].includes(node.tag)) {
                const name = pascalCase(node.tag);
                const component = (_a = options.components[name]) !== null && _a !== void 0 ? _a : options.components[node.tag];
                if (((_b = context.identifiers[name]) !== null && _b !== void 0 ? _b : 0) <= 0) {
                    if (component != null) {
                        context.imports.push({
                            exp: component.named === true
                                ? `{ ${component.name != null && component.name !== name
                                    ? component.name + ' as '
                                    : ''}${name} }`
                                : name,
                            path: component.path,
                        });
                        context.addIdentifiers(name);
                        resolvedComponentName = name;
                    }
                }
            }
        }
        return () => {
            var _a, _b;
            const exprs = expressions.slice();
            if (hasScope) {
                removeHoistScope();
                if (slotDir != null) {
                    if (slotDir.exp == null)
                        slotDir.exp = createSimpleExpression('{}', false);
                    slotDir.exp.exprs = exprs;
                }
            }
            if (node.tag === 'slot') {
                const slotName = findProp(node, 'name');
                const props = node.props.filter((prop) => prop !== slotName &&
                    (isAttributeNode(prop) || prop.name === 'bind'));
                const args = createCompoundExpression(props.length === 0
                    ? []
                    : props.length === 1 &&
                        isDirectiveNode(props[0]) &&
                        props[0].arg == null
                        ? [props[0].exp]
                        : flatten([
                            '{',
                            flatten(props.map((prop) => {
                                var _a;
                                if (isAttributeNode(prop)) {
                                    return generateAttribute(prop, node, ':');
                                }
                                else if (prop.name === 'bind') {
                                    if (isSimpleExpressionNode(prop.arg)) {
                                        return [
                                            '[',
                                            prop.arg.isStatic
                                                ? prop.arg
                                                : createSimpleExpression(prop.arg.content, prop.arg.isStatic, createLoc(prop.arg.loc, 1, prop.arg.content.length)),
                                            ']:',
                                            (_a = prop.exp) !== null && _a !== void 0 ? _a : 'true',
                                            ',',
                                        ];
                                    }
                                    else if (prop.exp != null) {
                                        return ['...(', prop.exp, '),'];
                                    }
                                }
                                return [];
                            })),
                            '}',
                        ]));
                node.codegenNode = createCompoundExpression(flatten([
                    context.helper(RENDER_SLOT),
                    '(',
                    '_ctx.$slots',
                    ',',
                    isAttributeNode(slotName)
                        ? createSimpleExpression((_b = (_a = slotName.value) === null || _a === void 0 ? void 0 : _a.content) !== null && _b !== void 0 ? _b : 'default', true, slotName.loc)
                        : isDirectiveNode(slotName)
                            ? slotName.exp
                            : createSimpleExpression('default', true),
                    ',',
                    args,
                    ')',
                    node.children.length > 0
                        ? flatten([' ?? (<>', generateChildNodes(node.children), '</>)'])
                        : [],
                ]));
                return;
            }
            let isHoistedComponentExpression = false;
            let name = resolvedComponentName !== null && resolvedComponentName !== void 0 ? resolvedComponentName : node.tag;
            let startTag = createSimpleExpression(name, false, createLoc(node.loc, node.loc.source.indexOf(node.tag), node.tag.length));
            if (node.tag === 'component') {
                const isProp = findProp(node, 'is');
                if (isAttributeNode(isProp) && isProp.value != null) {
                    isHoistedComponentExpression = true;
                    name = hoist(createSimpleExpression(`${JSON.stringify(isProp.value.content)} as const`, false, isProp.value.loc));
                    startTag = createSimpleExpression(name, false, startTag.loc);
                }
                else if (isDirectiveNode(isProp) &&
                    isSimpleExpressionNode(isProp.exp)) {
                    isHoistedComponentExpression = true;
                    name = hoist(isProp.exp);
                    startTag = createSimpleExpression(name, false, startTag.loc);
                }
                else {
                    name = '';
                    startTag = createSimpleExpression('', false);
                }
            }
            const attributes = generateJSXAttributes(node);
            if (node.isSelfClosing) {
                node.codegenNode = createCompoundExpression([
                    '<',
                    startTag,
                    ' ',
                    ...attributes,
                    ' />',
                ]);
                markElementNode(node.codegenNode);
            }
            else {
                const children = generateChildren(node, context, isHoistedComponentExpression || resolvedComponentName != null, exprs);
                node.codegenNode = createCompoundExpression([
                    '<',
                    startTag,
                    ' ',
                    ...attributes,
                    ' >',
                    ...children,
                    '</',
                    name,
                    '>',
                ]);
                markElementNode(node.codegenNode);
            }
        };
    };
}
function markElementNode(node) {
    node._isElementNode = true;
}
function markNonElementNode(node) {
    node._isElementNode = false;
}
function isMarkedElementNode(node) {
    return (node === null || node === void 0 ? void 0 : node._isElementNode) === true;
}
function getInternalPath(options) {
    var _a;
    return `./${(_a = options.filename.split(/[/\\]/).pop()) !== null && _a !== void 0 ? _a : options.filename}?internal`;
}
const ControlDirectiveNameRE = /^(if|for|else-if|else|slot)$/;
function generateJSXAttributes(node, _context) {
    const result = [];
    const alreadyProcessed = new Set();
    const ignore = node.tag === 'component' ? findProp(node, 'is') : undefined;
    node.props.forEach((dir) => {
        if (dir === ignore)
            return;
        if (isAttributeNode(dir)) {
            result.push(...generateAttribute(dir));
        }
        else if (ControlDirectiveNameRE.test(dir.name) ||
            alreadyProcessed.has(dir)) ;
        else {
            switch (dir.name) {
                case 'bind':
                    result.push(...generateVBind(dir));
                    break;
                case 'on':
                    result.push(...generateVOn(dir));
                    break;
                case 'model':
                    result.push(...generateVModel(dir, node));
                    break;
                default:
                    {
                        const code = generateCustomDirective(dir, node, alreadyProcessed);
                        result.push(...code);
                    }
                    break;
            }
        }
    });
    return result;
}
function generateCustomDirective(dir, node, alreadyProcessed) {
    const code = [];
    const dirs = node.props.filter((prop) => isDirectiveNode(prop) && prop.name === dir.name);
    dirs.forEach((dir) => alreadyProcessed.add(dir));
    code.push(` v-${dir.name}={`);
    const isMultiValue = dirs.length > 1;
    if (isMultiValue)
        code.push('[');
    dirs.forEach((dir) => {
        var _a, _b;
        code.push('{');
        code.push('arg:', (_a = dir.arg) !== null && _a !== void 0 ? _a : 'undefined', ',');
        code.push('exp:', (_b = dir.exp) !== null && _b !== void 0 ? _b : 'undefined', ',');
        // TODO: Maybe array?
        code.push('modifiers: {');
        dir.modifiers.forEach((modifier) => {
            code.push(modifier, ':true,');
        });
        code.push('}');
        code.push('}');
        if (isMultiValue)
            code.push(',');
    });
    if (isMultiValue)
        code.push(']');
    code.push('}');
    return code;
}
function generateVModel(dir, node) {
    var _a;
    const code = [];
    const exp = (_a = dir.exp) !== null && _a !== void 0 ? _a : 'null';
    const isNativeInput = /^(input|textarea|select)$/.test(node.tag);
    if (isNativeInput && dir.arg == null) {
        const isCheckboxOrRadio = node.props.some((prop) => isAttributeNode(prop) &&
            (prop.name === 'radio' || prop.name === 'checkbox'));
        const type = `Event & {target:${getHTMLElementType(node.tag)}}`;
        code.push(` ${isCheckboxOrRadio ? 'checked' : 'value'}={`, exp, '}  ');
        code.push(`onChange={($event) => (`, exp, ' = ', dir.modifiers.includes('number')
            ? `Number(($event as ${type}).target.value)`
            : `($event as ${type}).target.value`, ')}');
    }
    else {
        code.push(' ');
        if (isSimpleExpressionNode(dir.arg)) {
            if (dir.arg.isStatic) {
                code.push(dir.arg, '={', exp, '}');
            }
            else {
                code.push('{...({[', dir.arg, ']: ', exp, '})}');
            }
        }
        else {
            code.push('modelValue={', exp, '}');
        }
        code.push(' ');
        const arg = isSimpleExpressionNode(dir.arg)
            ? dir.arg.isStatic
                ? ["'", 'onUpdate:' + dir.arg.content, "'"]
                : [`['onUpdate:' + `, dir.arg, `]`]
            : [`'onUpdate:modelValue'`];
        code.push(`{...({`, ...arg, ': $event => ', exp, ' = $event', '})}');
        if (isSimpleExpressionNode(dir.arg))
            dir.arg.isStatic = false;
    }
    return code;
}
function generateAttribute(attr, _node, sep = '=') {
    const code = [];
    if (sep === '=' && (attr.name === 'class' || attr.name === 'style')) {
        return code;
    }
    else {
        code.push(' ', createSimpleExpression(attr.name, false, createLoc(attr.loc, 0, attr.name.length)));
        if (attr.value != null) {
            code.push(sep, createSimpleExpression(attr.value.loc.source, false, attr.value.loc));
        }
        else if (sep === ':') {
            code.push(sep, 'true');
        }
        if (sep === ':')
            code.push(',');
        return code;
    }
}
const InlineVOnHandlerRE = /\bfunction\b|\b=>\b/;
function generateVOn(dir, _node) {
    const code = [];
    const exp = isSimpleExpressionNode(dir.exp)
        ? isSimpleIdentifier(dir.exp.content.trim()) ||
            InlineVOnHandlerRE.test(dir.exp.content)
            ? [dir.exp]
            : dir.exp.content.includes('$event')
                ? ['$event =>', dir.exp]
                : ['() => ', dir.exp]
        : ['() => {}'];
    code.push(' ');
    if (isSimpleExpressionNode(dir.arg)) {
        if (dir.arg.isStatic) {
            if (dir.arg.content.includes(':')) {
                code.push('{...({"', createSimpleExpression(getEventName(dir.arg.content), false, dir.arg.loc), '":', ...exp, '})}');
            }
            else {
                code.push(createSimpleExpression(getEventName(dir.arg.content), false, dir.arg.loc), '={', ...exp, '}');
            }
        }
        else {
            code.push('{...({[', dir.arg, ']: ', ...exp, '})}');
        }
    }
    else if (dir.exp != null) {
        code.push('{...(', dir.exp, ')}');
    }
    return code;
}
function getEventName(dir) {
    var _a;
    if (dir.includes(':')) {
        const parts = dir.split(':');
        return `${camelCase(`on-${(_a = parts[0]) !== null && _a !== void 0 ? _a : ''}`)}:${parts.slice(1).join(':')}`;
    }
    return camelCase(`on-${dir}`);
}
function generateVBind(dir, _node) {
    const code = [];
    if (isSimpleExpressionNode(dir.arg)) {
        if (dir.arg.isStatic || dir.arg.content === 'key') {
            dir.arg.isStatic = false;
            code.push(' ', dir.arg);
            if (dir.exp != null)
                code.push('={', dir.exp, '}');
        }
        else {
            code.push(' {...({[', createSimpleExpression(dir.arg.content, dir.arg.isStatic, createLoc(dir.arg.loc, 1, dir.arg.content.length)), ']: ');
            if (dir.exp != null)
                code.push(dir.exp);
            else
                code.push('true');
            code.push('})}');
        }
    }
    else if (dir.exp != null) {
        code.push(' {...(', dir.exp, ')}');
    }
    return code;
}
function generateChildren(node, context, isResolvedComponent, expressions) {
    if (isResolvedComponent) {
        const { slots } = buildSlots(node, context, (props, children, _loc) => {
            var _a, _b;
            if (((_a = props) === null || _a === void 0 ? void 0 : _a.exprs) != null) {
                expressions = (_b = props) === null || _b === void 0 ? void 0 : _b.exprs;
            }
            const nodes = generateChildNodes(children);
            const returns = createCompoundExpression(nodes.length > 0 ? ['(<>', ...nodes, '</>)'] : ['null']);
            const fn = createFunctionExpression(props, undefined, true);
            if (expressions.length > 0) {
                fn.body = createBlockStatement([
                    ...expressions,
                    createCompoundExpression(['\nreturn ', returns]),
                ]);
            }
            else {
                fn.returns = returns;
            }
            return fn;
        });
        context.helpers.delete(WITH_CTX);
        if (isDynamicSlotsExpression(slots)) {
            slots.arguments[0].properties = slots.arguments[0].properties.filter((property) => !(isSimpleExpressionNode(property.key) && property.key.content === '_'));
        }
        else {
            slots.properties = slots.properties.filter((property) => !(isSimpleExpressionNode(property.key) && property.key.content === '_'));
        }
        return [createCompoundExpression(['{', slots, '}'])];
    }
    else {
        return generateChildNodes(node.children);
    }
}
function generateChildNodes(nodes) {
    return flatten(nodes.map((node) => {
        if (isTextNode(node)) {
            return createCompoundExpression([
                '{',
                JSON.stringify(node.content),
                '}\n',
            ]);
        }
        else if (isMarkedElementNode(node.codegenNode)) {
            return createCompoundExpression([node, '\n']);
        }
        else {
            return createCompoundExpression(['{', node, '}\n']);
        }
    }));
}
function isDynamicSlotsExpression(node) {
    return node.type === 14;
}
function getHTMLElementType(tag) {
    switch (tag) {
        case 'input':
            return 'HTMLInputElement';
        case 'textarea':
            return 'HTMLTextAreaElement';
        case 'select':
            return 'HTMLSelectElement';
        default:
            return 'HTMLElement';
    }
}

const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
function createTransformFor(addIdentifer, expressions) {
    const globalsExpressions = [];
    const addHoistScope = () => {
        globalsExpressions.push(expressions.slice());
        expressions.length = 0;
    };
    const removeHoistScope = () => {
        const exps = globalsExpressions.pop();
        if (Array.isArray(exps)) {
            expressions.length = 0;
            expressions.push(...exps);
        }
    };
    return createStructuralDirectiveTransform(/^for$/, (node, dir, context) => {
        let exp;
        if (isSimpleExpressionNode(dir.exp)) {
            const parseResult = forAliasRE.exec(dir.exp.content);
            if ((parseResult === null || parseResult === void 0 ? void 0 : parseResult[2]) != null) {
                exp = createSimpleExpression(parseResult[2], false, createLoc(dir.exp.loc, dir.exp.content.indexOf(parseResult[2]), parseResult[2].length));
                trackIdentifiers(exp.content, context, exp.loc.start, addIdentifer);
            }
        }
        return processFor(node, dir, context, (forNode) => {
            const renderExp = createCallExpression(context.helper(RENDER_LIST), [
                exp,
            ]);
            forNode.codegenNode = createCompoundExpression([renderExp]);
            addHoistScope();
            return () => {
                const childBlock = forNode.children.length === 0
                    ? createCompoundExpression(['null'])
                    : createCompoundExpression([
                        '<>',
                        ...generateChildNodes(forNode.children),
                        '</>',
                    ]);
                const fn = createFunctionExpression(createForLoopParams(forNode.parseResult), undefined, true /* force newline */);
                if (expressions.length > 0) {
                    fn.body = createBlockStatement([
                        ...expressions,
                        createCompoundExpression(['\nreturn ', childBlock]),
                    ]);
                }
                else {
                    fn.returns = childBlock;
                }
                renderExp.arguments.push(fn);
                removeHoistScope();
            };
        });
    });
}

// eslint-disable-next-line @typescript-eslint/triple-slash-reference
class Scope {
    constructor(parent = null) {
        this.parent = parent;
        this.bindings = {};
    }
    get identifiers() {
        return Array.from(Object.keys(this.bindings));
    }
    get globals() {
        return this.identifiers.filter((identifier) => this.getBinding(identifier) === null);
    }
    getBinding(identifier) {
        var _a;
        if (identifier in this.bindings)
            return (_a = this.bindings[identifier]) !== null && _a !== void 0 ? _a : null;
        if (this.parent != null) {
            return (this.bindings[identifier] = this.parent.getBinding(identifier));
        }
        else {
            this.bindings[identifier] = null;
        }
        return null;
    }
    setBinding(identifer, node) {
        this.bindings[identifer] = node;
    }
}
function withScope(ast) {
    ast.scope = new Scope(null);
    traverse$1(ast, (node, ancestors) => {
        var _a, _b, _c;
        const parent = ((_b = (_a = ancestors[ancestors.length - 1]) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : ast);
        const scope = (node.scope = (_c = node.scope) !== null && _c !== void 0 ? _c : new Scope(parent.scope));
        if (isSimpleExpressionNode(node) && !node.isStatic) {
            if (parent != null ||
                !(isDirectiveNode(parent) &&
                    ['slot', 'for'].includes(parent.name) &&
                    parent.exp === node)) {
                getIdentifiers(node.content).forEach((identifier) => scope.getBinding(identifier));
            }
        }
        else if (isElementNode(node)) {
            node.props.forEach((prop) => {
                var _a;
                if (isDirectiveNode(prop)) {
                    const directiveScope = (prop.scope = (_a = prop.scope) !== null && _a !== void 0 ? _a : new Scope(scope));
                    if (prop.name === 'slot') {
                        if (isSimpleExpressionNode(prop.exp)) {
                            const localScope = (prop.exp.scope = new Scope(directiveScope));
                            const content = prop.exp.content.trim();
                            getIdentifiers(`(${content}) => {}`).forEach((identifier) => {
                                scope.setBinding(identifier, node);
                                localScope.getBinding(identifier);
                            });
                        }
                    }
                    else if (prop.name === 'for') {
                        if (isSimpleExpressionNode(prop.exp)) {
                            const localScope = (prop.exp.scope = new Scope(directiveScope));
                            const match = forAliasRE.exec(prop.exp.content);
                            if (match != null) {
                                const [, LHS, RHS] = match;
                                if (RHS != null) {
                                    getIdentifiers(RHS).forEach((identifier) => {
                                        localScope.getBinding(identifier);
                                    });
                                    getIdentifiers(`${LHS !== null && LHS !== void 0 ? LHS : '()'} => {}`).forEach((identifier) => {
                                        scope.setBinding(identifier, node);
                                        localScope.getBinding(identifier);
                                    });
                                }
                            }
                        }
                    }
                }
            });
        }
    });
    return ast;
}
/**
 * @internal
 */
function getTopLevelIdentifiers(source, ignoreImportsFrom) {
    const identifiers = new Set();
    const components = new Set();
    const directives = new Set();
    let propsIdentifier;
    let emitIdentifier;
    let definePropsIdentifierFn;
    let defineEmitIdentifierFn;
    const ignoredSources = new Set(ignoreImportsFrom);
    try {
        const ast = parseUsingBabel(source, true);
        const getIdentifiers = (node) => {
            if (isIdentifier(node))
                return [node.name];
            else if (isMemberExpression(node)) {
                if (isIdentifier(node.property)) {
                    return [node.property.name];
                }
                else if (isExpression(node.property)) {
                    return [];
                }
                else if (isPrivateName(node.property)) {
                    return [node.property.id.name];
                }
                else {
                    return [];
                }
            }
            else if (isRestElement(node)) {
                return getIdentifiers(node.argument);
            }
            else if (isAssignmentPattern(node)) {
                return getIdentifiers(node.left);
            }
            else if (isArrayPattern(node)) {
                return flatten(node.elements
                    .filter((element) => element != null)
                    .map((element) => getIdentifiers(element)));
            }
            else if (isObjectPattern(node)) {
                return flatten(node.properties.map((property) => {
                    if (isRestElement(property) || isIdentifier(property)) {
                        return getIdentifiers(property);
                    }
                    else {
                        return [];
                    }
                }));
            }
            else {
                return [];
            }
        };
        if (isFile(ast)) {
            ast.program.body.forEach((node) => {
                if (!isDeclaration(node))
                    return;
                if (isVariableDeclaration(node)) {
                    node.declarations.forEach((declaration) => {
                        getIdentifiers(declaration.id).forEach((name) => identifiers.add(name));
                        if (isIdentifier(declaration.id) &&
                            isCallExpression(declaration.init)) {
                            if (isIdentifier(declaration.init.callee)) {
                                if (declaration.init.callee.name === definePropsIdentifierFn) {
                                    propsIdentifier = declaration.id.name;
                                }
                                else if (declaration.init.callee.name === defineEmitIdentifierFn) {
                                    emitIdentifier = declaration.id.name;
                                }
                            }
                        }
                    });
                }
                else if (isFunctionDeclaration(node)) {
                    if (node.id != null)
                        identifiers.add(node.id.name);
                }
                else if (isImportDeclaration(node)) {
                    const isVue = node.source.value === 'vue';
                    node.specifiers.forEach((specifier) => {
                        if (isVue && isImportSpecifier(specifier)) {
                            const name = isIdentifier(specifier.imported)
                                ? specifier.imported.name
                                : specifier.imported.value;
                            if (name === 'defineProps') {
                                definePropsIdentifierFn = specifier.local.name;
                                return; // -
                            }
                            else if (name === 'defineEmit') {
                                defineEmitIdentifierFn = specifier.local.name;
                                return; // -
                            }
                        }
                        if (!ignoredSources.has(node.source.value)) {
                            identifiers.add(specifier.local.name);
                            if (isCamelCase(specifier.local.name)) {
                                directives.add(specifier.local.name);
                            }
                            else if (isPascalCase(specifier.local.name)) {
                                components.add(specifier.local.name);
                            }
                        }
                    });
                }
                else if (isClassDeclaration(node)) {
                    identifiers.add(node.id.name);
                }
                else if (isDeclareClass(node)) {
                    identifiers.add(node.id.name);
                }
                else if (isDeclareFunction(node)) {
                    identifiers.add(node.id.name);
                }
                else if (isDeclareVariable(node)) {
                    identifiers.add(node.id.name);
                }
                else if (isEnumDeclaration(node)) {
                    identifiers.add(node.id.name);
                }
            });
        }
    }
    catch {
        // FIXME: Handle errors
    }
    return {
        identifiers,
        components,
        directives,
        emitIdentifier,
        propsIdentifier,
    };
}
function getIdentifiers(source) {
    source = source
        .trim()
        // Common errors when user is typing.
        .replace(/(\.|\[\]?)$/, '');
    if (isSimpleIdentifier(source.trim()))
        return new Set([source]);
    // TODO: Handle incomplete expressions
    try {
        const ast = parseUsingBabel(source, false);
        const identifers = new Set();
        traverse(ast, (node, ancestors) => {
            if (isIdentifier(node)) {
                if (ancestors.length > 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    if (shouldTrack(node, ancestors[ancestors.length - 1].node)) {
                        identifers.add(node.name);
                    }
                }
                else {
                    identifers.add(node.name);
                }
            }
        });
        return identifers;
    }
    catch {
        return new Set([]);
    }
}
function parseUsingBabel(source, withTS = false) {
    try {
        return parse$1(source, {
            plugins: withTS
                ? ['bigInt', 'optionalChaining', 'typescript']
                : ['bigInt', 'optionalChaining'],
            // @ts-expect-error
            errorRecovery: true,
        });
    }
    catch {
        return parseExpression(source, {
            plugins: withTS
                ? ['bigInt', 'optionalChaining', 'typescript']
                : ['bigInt', 'optionalChaining'],
            // @ts-expect-error
            errorRecovery: true,
        });
    }
}
function shouldTrack(identifier, parent) {
    if (!(isFunction(parent) &&
        // not id of a FunctionDeclaration
        parent.id === identifier) &&
        // not a key of Property
        !isStaticPropertyKey(identifier, parent) &&
        // not a property of a MemberExpression
        !((isMemberExpression(parent) || isOptionalMemberExpression(parent)) &&
            parent.property === identifier &&
            !parent.computed) &&
        // skip whitelisted globals
        !isKnownIdentifier(identifier.name) &&
        // special case for webpack compilation
        identifier.name !== `require` &&
        // is a special keyword but parsed as identifier
        identifier.name !== `arguments`) {
        return true;
    }
    return false;
}

function createTransformIf(addIdentifer) {
    return createStructuralDirectiveTransform(/^(if|else-if|else)$/, (node, dir, context) => {
        const exp = dir.exp;
        const content = exp === null || exp === void 0 ? void 0 : exp.content;
        if (isSimpleExpressionNode(dir.exp)) {
            trackIdentifiers(dir.exp.content, context, dir.exp.loc.start, addIdentifer);
        }
        return processIf(node, dir, context, (ifNode, branch, _isRoot) => {
            return () => {
                let hasElse = false;
                if (dir.name !== 'else') {
                    branch.condition = createSimpleExpression$1(content == null || content.trim() === '' ? 'false' : content, false, exp === null || exp === void 0 ? void 0 : exp.loc);
                }
                const expressions = [
                    ...flatten(ifNode.branches.map((branch) => {
                        hasElse = hasElse || branch.condition == null;
                        return branch.condition != null
                            ? [
                                '(',
                                branch.condition,
                                ') ? (',
                                ...normalizeChildren(branch.children),
                                ') :',
                            ]
                            : ['(', ...normalizeChildren(branch.children), ')'];
                    })),
                    `${hasElse ? '' : 'null'}`,
                ];
                ifNode.codegenNode = createCompoundExpression(expressions);
            };
        });
    });
}
function normalizeChildren(children) {
    return children.length === 0
        ? ['null']
        : children.length === 1
            ? children
            : ['<>', ...children, '</>'];
}

function createInterpolationTransform(_options) {
    return function transform(node, context) {
        if (isInterpolationNode(node)) {
            context.replaceNode(createCompoundExpression([node.content]));
        }
    };
}

function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
const components = {};
function compile(template, options) {
    const ast = parse(template, options);
    const astCopy = clone(ast);
    const expressions = [];
    const config = {
        ...parserOptions,
        ...options,
        components: {
            ...components,
            ...options.components,
            [getComponentName(options.filename)]: {
                path: `./${Path.posix.basename(options.filename)}`,
            },
        },
    };
    const identifiers = new Set();
    const addIdentifier = (id) => {
        if (id.trim() !== '') {
            identifiers.add(id.trim());
        }
    };
    const errors = [];
    const hoists = [];
    transform(ast, {
        ...options,
        prefixIdentifiers: true,
        hoistStatic: false,
        transformHoist: null,
        ssr: false,
        cacheHandlers: false,
        scopeId: null,
        nodeTransforms: [
            // Collect Expressions
            (node) => {
                if (isInterpolationNode(node)) {
                    expressions.push([
                        node.content.loc.start.offset,
                        node.content.loc.source.length,
                    ]);
                }
                else if (isElementNode(node)) {
                    node.props.forEach((prop) => {
                        if (isDirectiveNode(prop)) {
                            if (prop.exp != null) {
                                expressions.push([
                                    prop.exp.loc.start.offset,
                                    prop.exp.loc.source.length,
                                ]);
                            }
                            if (isSimpleExpressionNode(prop.arg) && !prop.arg.isStatic) {
                                expressions.push([
                                    prop.arg.loc.start.offset + 1,
                                    prop.arg.loc.source.length - 2,
                                ]);
                            }
                        }
                    });
                }
            },
            // Drop Comments
            (node, context) => {
                if (isCommentNode(node)) {
                    context.replaceNode(createCompoundExpression(['/* ', node.content, ' */']));
                }
                else if (isElementNode(node) && node.tag.includes('<')) {
                    node.tag = node.tag.replace(/[<]/g, ' ');
                }
            },
            createTransformFor(addIdentifier, hoists),
            createTransformIf(addIdentifier),
            createExpressionTracker(addIdentifier),
            createElementTransform(config, hoists),
            createInterpolationTransform(),
        ],
        onError(error) {
            errors.push(error);
        },
    });
    const hasVFor = ast.helpers.includes(RENDER_LIST);
    const hasVSlot = ast.helpers.includes(RENDER_SLOT);
    [
        OPEN_BLOCK,
        CREATE_BLOCK,
        CREATE_VNODE,
        FRAGMENT,
        RENDER_LIST,
        RENDER_SLOT,
    ].forEach((helper) => {
        const index = ast.helpers.indexOf(helper);
        if (index >= 0)
            ast.helpers.splice(index, 1);
    });
    if (ast.children.length > 0) {
        ast.codegenNode = createCompoundExpression([
            '<>',
            ...generateChildNodes(ast.children),
            '</>/*@@vue:end*/',
        ]);
    }
    else {
        ast.codegenNode = createCompoundExpression([
            '/*@@vue:start*/null/*@@vue:end*/',
        ]);
    }
    const mappings = [];
    let isStartInjected = false;
    const result = generate(ast, {
        ...options,
        sourceMap: true,
        mode: 'module',
        onContextCreated(context) {
            const push = context.push;
            context.push = (code, node) => {
                if (code.trim().startsWith('export')) {
                    push([
                        `type I<T> = T`,
                        `type ${getComponentName(options.filename)} = I<InstanceType<typeof _Ctx>>`,
                        hasVFor
                            ? `import { _renderList } from '__vuedx_runtime__render__'`
                            : null,
                        hasVSlot
                            ? `import { _renderSlot } from '__vuedx_runtime__render__'`
                            : null,
                        `declare const __completionsTrigger: ${getComponentName(options.filename)}`,
                        '__completionsTrigger./*@@vue:completions*/$props',
                        'const __completionsTag = /*@@vue:completionsTag*/<></>',
                        '',
                    ]
                        .filter((value) => value != null)
                        .join('\n'));
                }
                if ((node === null || node === void 0 ? void 0 : node.loc) != null &&
                    node.loc.start.offset !== 0 &&
                    node.loc.end.offset !== 0) {
                    mappings.push([
                        context.offset,
                        code.length,
                        node.loc.start.offset,
                        node.loc.source.length,
                        0,
                    ]);
                }
                if (code === 'return ') {
                    if (!isStartInjected) {
                        isStartInjected = true;
                        push(`/*@@vue:start*/`);
                        context.newline();
                        hoists.forEach((hoist) => {
                            hoist.children.forEach((child) => {
                                if (isSimpleExpressionNode(child)) {
                                    context.push(child.content, child);
                                }
                                else if (typeof child === 'string') {
                                    push(child);
                                }
                            });
                            context.newline();
                        });
                        push(code);
                    }
                    else {
                        push(code);
                    }
                }
                else if (code.startsWith('function render(_ctx')) {
                    push(`function render(${identifiers.size > 0
                        ? `{/*@@vue:identifiers-start*/${Array.from(identifiers).join(', ')}/*@@vue:identifiers-end*/,..._ctx}`
                        : '_ctx'}: ${getComponentName(options.filename)}) {`);
                }
                else {
                    push(code, node);
                }
            };
        },
    });
    return {
        ...result,
        ast: withScope(astCopy),
        mappings,
        expressions,
        errors,
    };
}
function parse(template, options) {
    return baseParse(template, {
        ...parserOptions,
        ...options,
    });
}

export { compile, getTopLevelIdentifiers, parse };
//# sourceMappingURL=index.mjs.map
