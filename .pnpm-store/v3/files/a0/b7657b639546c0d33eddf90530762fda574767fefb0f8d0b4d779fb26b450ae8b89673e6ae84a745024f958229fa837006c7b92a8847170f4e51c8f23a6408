import { findDir, isSimpleIdentifier, createCompoundExpression, createSimpleExpression, findProp, RENDER_SLOT, buildSlots, createFunctionExpression, createBlockStatement, WITH_CTX, createStructuralDirectiveTransform, processFor, createCallExpression, RENDER_LIST, createForLoopParams, processIf, baseParse, transform, OPEN_BLOCK, CREATE_BLOCK, CREATE_VNODE, FRAGMENT, generate } from '@vue/compiler-core/dist/compiler-core.cjs.js';
import { flatten, pascalCase, camelCase, isCamelCase, isPascalCase, getComponentName } from '@vuedx/shared';
import { isInterpolationNode, isSimpleExpressionNode, isElementNode, isDirectiveNode, isTextNode, isComponentNode, isAttributeNode, traverse as traverse$1, createSimpleExpression as createSimpleExpression$1, isCommentNode } from '@vuedx/template-ast-types';
import * as Path from 'path';
import { parse as parse$1, parseExpression } from '@babel/parser';
import { traverse, isIdentifier, isFunction, traverseFast, isObjectMember, isAssignmentPattern, isMemberExpression, isOptionalMemberExpression, isArrayPattern, isExpression, isPrivateName, isRestElement, isObjectPattern, isFile, isDeclaration, isVariableDeclaration, isCallExpression, isFunctionDeclaration, isImportDeclaration, isImportSpecifier, isClassDeclaration, isDeclareClass, isDeclareFunction, isDeclareVariable, isEnumDeclaration } from '@babel/types';

const namedCharacterReferences = {
    GT: '>',
    gt: '>',
    LT: '<',
    lt: '<',
    'ac;': 'âˆ¾',
    'af;': 'â¡',
    AMP: '&',
    amp: '&',
    'ap;': 'â‰ˆ',
    'DD;': 'â……',
    'dd;': 'â…†',
    deg: 'Â°',
    'ee;': 'â…‡',
    'eg;': 'âªš',
    'el;': 'âª™',
    ETH: 'Ã',
    eth: 'Ã°',
    'gE;': 'â‰§',
    'ge;': 'â‰¥',
    'Gg;': 'â‹™',
    'gg;': 'â‰«',
    'gl;': 'â‰·',
    'GT;': '>',
    'Gt;': 'â‰«',
    'gt;': '>',
    'ic;': 'â£',
    'ii;': 'â…ˆ',
    'Im;': 'â„‘',
    'in;': 'âˆˆ',
    'it;': 'â¢',
    'lE;': 'â‰¦',
    'le;': 'â‰¤',
    'lg;': 'â‰¶',
    'Ll;': 'â‹˜',
    'll;': 'â‰ª',
    'LT;': '<',
    'Lt;': 'â‰ª',
    'lt;': '<',
    'mp;': 'âˆ“',
    'Mu;': 'Îœ',
    'mu;': 'Î¼',
    'ne;': 'â‰ ',
    'ni;': 'âˆ‹',
    not: 'Â¬',
    'Nu;': 'Î',
    'nu;': 'Î½',
    'Or;': 'â©”',
    'or;': 'âˆ¨',
    'oS;': 'â“ˆ',
    'Pi;': 'Î ',
    'pi;': 'Ï€',
    'pm;': 'Â±',
    'Pr;': 'âª»',
    'pr;': 'â‰º',
    'Re;': 'â„œ',
    REG: 'Â®',
    reg: 'Â®',
    'rx;': 'â„',
    'Sc;': 'âª¼',
    'sc;': 'â‰»',
    shy: 'Â­',
    uml: 'Â¨',
    'wp;': 'â„˜',
    'wr;': 'â‰€',
    'Xi;': 'Î',
    'xi;': 'Î¾',
    yen: 'Â¥',
    'acd;': 'âˆ¿',
    'acE;': 'âˆ¾Ì³',
    'Acy;': 'Ğ',
    'acy;': 'Ğ°',
    'Afr;': 'ğ”„',
    'afr;': 'ğ”',
    'AMP;': '&',
    'amp;': '&',
    'And;': 'â©“',
    'and;': 'âˆ§',
    'ang;': 'âˆ ',
    'apE;': 'â©°',
    'ape;': 'â‰Š',
    'ast;': '*',
    Auml: 'Ã„',
    auml: 'Ã¤',
    'Bcy;': 'Ğ‘',
    'bcy;': 'Ğ±',
    'Bfr;': 'ğ”…',
    'bfr;': 'ğ”Ÿ',
    'bne;': '=âƒ¥',
    'bot;': 'âŠ¥',
    'Cap;': 'â‹’',
    'cap;': 'âˆ©',
    cent: 'Â¢',
    'Cfr;': 'â„­',
    'cfr;': 'ğ” ',
    'Chi;': 'Î§',
    'chi;': 'Ï‡',
    'cir;': 'â—‹',
    COPY: 'Â©',
    copy: 'Â©',
    'Cup;': 'â‹“',
    'cup;': 'âˆª',
    'Dcy;': 'Ğ”',
    'dcy;': 'Ğ´',
    'deg;': 'Â°',
    'Del;': 'âˆ‡',
    'Dfr;': 'ğ”‡',
    'dfr;': 'ğ”¡',
    'die;': 'Â¨',
    'div;': 'Ã·',
    'Dot;': 'Â¨',
    'dot;': 'Ë™',
    'Ecy;': 'Ğ­',
    'ecy;': 'Ñ',
    'Efr;': 'ğ”ˆ',
    'efr;': 'ğ”¢',
    'egs;': 'âª–',
    'ell;': 'â„“',
    'els;': 'âª•',
    'ENG;': 'ÅŠ',
    'eng;': 'Å‹',
    'Eta;': 'Î—',
    'eta;': 'Î·',
    'ETH;': 'Ã',
    'eth;': 'Ã°',
    Euml: 'Ã‹',
    euml: 'Ã«',
    'Fcy;': 'Ğ¤',
    'fcy;': 'Ñ„',
    'Ffr;': 'ğ”‰',
    'ffr;': 'ğ”£',
    'gap;': 'âª†',
    'Gcy;': 'Ğ“',
    'gcy;': 'Ğ³',
    'gEl;': 'âªŒ',
    'gel;': 'â‹›',
    'geq;': 'â‰¥',
    'ges;': 'â©¾',
    'Gfr;': 'ğ”Š',
    'gfr;': 'ğ”¤',
    'ggg;': 'â‹™',
    'gla;': 'âª¥',
    'glE;': 'âª’',
    'glj;': 'âª¤',
    'gnE;': 'â‰©',
    'gne;': 'âªˆ',
    'Hat;': '^',
    'Hfr;': 'â„Œ',
    'hfr;': 'ğ”¥',
    'Icy;': 'Ğ˜',
    'icy;': 'Ğ¸',
    'iff;': 'â‡”',
    'Ifr;': 'â„‘',
    'ifr;': 'ğ”¦',
    'Int;': 'âˆ¬',
    'int;': 'âˆ«',
    Iuml: 'Ã',
    iuml: 'Ã¯',
    'Jcy;': 'Ğ™',
    'jcy;': 'Ğ¹',
    'Jfr;': 'ğ”',
    'jfr;': 'ğ”§',
    'Kcy;': 'Ğš',
    'kcy;': 'Ğº',
    'Kfr;': 'ğ”',
    'kfr;': 'ğ”¨',
    'lap;': 'âª…',
    'lat;': 'âª«',
    'Lcy;': 'Ğ›',
    'lcy;': 'Ğ»',
    'lEg;': 'âª‹',
    'leg;': 'â‹š',
    'leq;': 'â‰¤',
    'les;': 'â©½',
    'Lfr;': 'ğ”',
    'lfr;': 'ğ”©',
    'lgE;': 'âª‘',
    'lnE;': 'â‰¨',
    'lne;': 'âª‡',
    'loz;': 'â—Š',
    'lrm;': 'â€',
    'Lsh;': 'â†°',
    'lsh;': 'â†°',
    macr: 'Â¯',
    'Map;': 'â¤…',
    'map;': 'â†¦',
    'Mcy;': 'Ğœ',
    'mcy;': 'Ğ¼',
    'Mfr;': 'ğ”',
    'mfr;': 'ğ”ª',
    'mho;': 'â„§',
    'mid;': 'âˆ£',
    'nap;': 'â‰‰',
    nbsp: ' ',
    'Ncy;': 'Ğ',
    'ncy;': 'Ğ½',
    'Nfr;': 'ğ”‘',
    'nfr;': 'ğ”«',
    'ngE;': 'â‰§Ì¸',
    'nge;': 'â‰±',
    'nGg;': 'â‹™Ì¸',
    'nGt;': 'â‰«âƒ’',
    'ngt;': 'â‰¯',
    'nis;': 'â‹¼',
    'niv;': 'âˆ‹',
    'nlE;': 'â‰¦Ì¸',
    'nle;': 'â‰°',
    'nLl;': 'â‹˜Ì¸',
    'nLt;': 'â‰ªâƒ’',
    'nlt;': 'â‰®',
    'Not;': 'â«¬',
    'not;': 'Â¬',
    'npr;': 'âŠ€',
    'nsc;': 'âŠ',
    'num;': '#',
    'Ocy;': 'Ğ',
    'ocy;': 'Ğ¾',
    'Ofr;': 'ğ”’',
    'ofr;': 'ğ”¬',
    'ogt;': 'â§',
    'ohm;': 'Î©',
    'olt;': 'â§€',
    'ord;': 'â©',
    ordf: 'Âª',
    ordm: 'Âº',
    'orv;': 'â©›',
    Ouml: 'Ã–',
    ouml: 'Ã¶',
    'par;': 'âˆ¥',
    para: 'Â¶',
    'Pcy;': 'ĞŸ',
    'pcy;': 'Ğ¿',
    'Pfr;': 'ğ”“',
    'pfr;': 'ğ”­',
    'Phi;': 'Î¦',
    'phi;': 'Ï†',
    'piv;': 'Ï–',
    'prE;': 'âª³',
    'pre;': 'âª¯',
    'Psi;': 'Î¨',
    'psi;': 'Ïˆ',
    'Qfr;': 'ğ””',
    'qfr;': 'ğ”®',
    QUOT: '"',
    quot: '"',
    'Rcy;': 'Ğ ',
    'rcy;': 'Ñ€',
    'REG;': 'Â®',
    'reg;': 'Â®',
    'Rfr;': 'â„œ',
    'rfr;': 'ğ”¯',
    'Rho;': 'Î¡',
    'rho;': 'Ï',
    'rlm;': 'â€',
    'Rsh;': 'â†±',
    'rsh;': 'â†±',
    'scE;': 'âª´',
    'sce;': 'âª°',
    'Scy;': 'Ğ¡',
    'scy;': 'Ñ',
    sect: 'Â§',
    'Sfr;': 'ğ”–',
    'sfr;': 'ğ”°',
    'shy;': 'Â­',
    'sim;': 'âˆ¼',
    'smt;': 'âªª',
    'sol;': '/',
    'squ;': 'â–¡',
    'Sub;': 'â‹',
    'sub;': 'âŠ‚',
    'Sum;': 'âˆ‘',
    'sum;': 'âˆ‘',
    'Sup;': 'â‹‘',
    'sup;': 'âŠƒ',
    sup1: 'Â¹',
    sup2: 'Â²',
    sup3: 'Â³',
    'Tab;': '\t',
    'Tau;': 'Î¤',
    'tau;': 'Ï„',
    'Tcy;': 'Ğ¢',
    'tcy;': 'Ñ‚',
    'Tfr;': 'ğ”—',
    'tfr;': 'ğ”±',
    'top;': 'âŠ¤',
    'Ucy;': 'Ğ£',
    'ucy;': 'Ñƒ',
    'Ufr;': 'ğ”˜',
    'ufr;': 'ğ”²',
    'uml;': 'Â¨',
    Uuml: 'Ãœ',
    uuml: 'Ã¼',
    'Vcy;': 'Ğ’',
    'vcy;': 'Ğ²',
    'Vee;': 'â‹',
    'vee;': 'âˆ¨',
    'Vfr;': 'ğ”™',
    'vfr;': 'ğ”³',
    'Wfr;': 'ğ”š',
    'wfr;': 'ğ”´',
    'Xfr;': 'ğ”›',
    'xfr;': 'ğ”µ',
    'Ycy;': 'Ğ«',
    'ycy;': 'Ñ‹',
    'yen;': 'Â¥',
    'Yfr;': 'ğ”œ',
    'yfr;': 'ğ”¶',
    yuml: 'Ã¿',
    'Zcy;': 'Ğ—',
    'zcy;': 'Ğ·',
    'Zfr;': 'â„¨',
    'zfr;': 'ğ”·',
    'zwj;': 'â€',
    Acirc: 'Ã‚',
    acirc: 'Ã¢',
    acute: 'Â´',
    AElig: 'Ã†',
    aelig: 'Ã¦',
    'andd;': 'â©œ',
    'andv;': 'â©š',
    'ange;': 'â¦¤',
    'Aopf;': 'ğ”¸',
    'aopf;': 'ğ•’',
    'apid;': 'â‰‹',
    'apos;': "'",
    Aring: 'Ã…',
    aring: 'Ã¥',
    'Ascr;': 'ğ’œ',
    'ascr;': 'ğ’¶',
    'Auml;': 'Ã„',
    'auml;': 'Ã¤',
    'Barv;': 'â«§',
    'bbrk;': 'âµ',
    'Beta;': 'Î’',
    'beta;': 'Î²',
    'beth;': 'â„¶',
    'bNot;': 'â«­',
    'bnot;': 'âŒ',
    'Bopf;': 'ğ”¹',
    'bopf;': 'ğ•“',
    'boxH;': 'â•',
    'boxh;': 'â”€',
    'boxV;': 'â•‘',
    'boxv;': 'â”‚',
    'Bscr;': 'â„¬',
    'bscr;': 'ğ’·',
    'bsim;': 'âˆ½',
    'bsol;': '\\',
    'bull;': 'â€¢',
    'bump;': 'â‰',
    'caps;': 'âˆ©ï¸€',
    'Cdot;': 'ÄŠ',
    'cdot;': 'Ä‹',
    cedil: 'Â¸',
    'cent;': 'Â¢',
    'CHcy;': 'Ğ§',
    'chcy;': 'Ñ‡',
    'circ;': 'Ë†',
    'cirE;': 'â§ƒ',
    'cire;': 'â‰—',
    'comp;': 'âˆ',
    'cong;': 'â‰…',
    'Copf;': 'â„‚',
    'copf;': 'ğ•”',
    'COPY;': 'Â©',
    'copy;': 'Â©',
    'Cscr;': 'ğ’',
    'cscr;': 'ğ’¸',
    'csub;': 'â«',
    'csup;': 'â«',
    'cups;': 'âˆªï¸€',
    'Darr;': 'â†¡',
    'dArr;': 'â‡“',
    'darr;': 'â†“',
    'dash;': 'â€',
    'dHar;': 'â¥¥',
    'diam;': 'â‹„',
    'DJcy;': 'Ğ‚',
    'djcy;': 'Ñ’',
    'Dopf;': 'ğ”»',
    'dopf;': 'ğ••',
    'Dscr;': 'ğ’Ÿ',
    'dscr;': 'ğ’¹',
    'DScy;': 'Ğ…',
    'dscy;': 'Ñ•',
    'dsol;': 'â§¶',
    'dtri;': 'â–¿',
    'DZcy;': 'Ğ',
    'dzcy;': 'ÑŸ',
    'ecir;': 'â‰–',
    Ecirc: 'ÃŠ',
    ecirc: 'Ãª',
    'Edot;': 'Ä–',
    'eDot;': 'â‰‘',
    'edot;': 'Ä—',
    'emsp;': 'â€ƒ',
    'ensp;': 'â€‚',
    'Eopf;': 'ğ”¼',
    'eopf;': 'ğ•–',
    'epar;': 'â‹•',
    'epsi;': 'Îµ',
    'Escr;': 'â„°',
    'escr;': 'â„¯',
    'Esim;': 'â©³',
    'esim;': 'â‰‚',
    'Euml;': 'Ã‹',
    'euml;': 'Ã«',
    'euro;': 'â‚¬',
    'excl;': '!',
    'flat;': 'â™­',
    'fnof;': 'Æ’',
    'Fopf;': 'ğ”½',
    'fopf;': 'ğ•—',
    'fork;': 'â‹”',
    'Fscr;': 'â„±',
    'fscr;': 'ğ’»',
    'Gdot;': 'Ä ',
    'gdot;': 'Ä¡',
    'geqq;': 'â‰§',
    'gesl;': 'â‹›ï¸€',
    'GJcy;': 'Ğƒ',
    'gjcy;': 'Ñ“',
    'gnap;': 'âªŠ',
    'gneq;': 'âªˆ',
    'Gopf;': 'ğ”¾',
    'gopf;': 'ğ•˜',
    'Gscr;': 'ğ’¢',
    'gscr;': 'â„Š',
    'gsim;': 'â‰³',
    'gtcc;': 'âª§',
    'gvnE;': 'â‰©ï¸€',
    'half;': 'Â½',
    'hArr;': 'â‡”',
    'harr;': 'â†”',
    'hbar;': 'â„',
    'Hopf;': 'â„',
    'hopf;': 'ğ•™',
    'Hscr;': 'â„‹',
    'hscr;': 'ğ’½',
    Icirc: 'Ã',
    icirc: 'Ã®',
    'Idot;': 'Ä°',
    'IEcy;': 'Ğ•',
    'iecy;': 'Ğµ',
    iexcl: 'Â¡',
    'imof;': 'âŠ·',
    'IOcy;': 'Ğ',
    'iocy;': 'Ñ‘',
    'Iopf;': 'ğ•€',
    'iopf;': 'ğ•š',
    'Iota;': 'Î™',
    'iota;': 'Î¹',
    'Iscr;': 'â„',
    'iscr;': 'ğ’¾',
    'isin;': 'âˆˆ',
    'Iuml;': 'Ã',
    'iuml;': 'Ã¯',
    'Jopf;': 'ğ•',
    'jopf;': 'ğ•›',
    'Jscr;': 'ğ’¥',
    'jscr;': 'ğ’¿',
    'KHcy;': 'Ğ¥',
    'khcy;': 'Ñ…',
    'KJcy;': 'ĞŒ',
    'kjcy;': 'Ñœ',
    'Kopf;': 'ğ•‚',
    'kopf;': 'ğ•œ',
    'Kscr;': 'ğ’¦',
    'kscr;': 'ğ“€',
    'Lang;': 'âŸª',
    'lang;': 'âŸ¨',
    laquo: 'Â«',
    'Larr;': 'â†',
    'lArr;': 'â‡',
    'larr;': 'â†',
    'late;': 'âª­',
    'lcub;': '{',
    'ldca;': 'â¤¶',
    'ldsh;': 'â†²',
    'leqq;': 'â‰¦',
    'lesg;': 'â‹šï¸€',
    'lHar;': 'â¥¢',
    'LJcy;': 'Ğ‰',
    'ljcy;': 'Ñ™',
    'lnap;': 'âª‰',
    'lneq;': 'âª‡',
    'Lopf;': 'ğ•ƒ',
    'lopf;': 'ğ•',
    'lozf;': 'â§«',
    'lpar;': '(',
    'Lscr;': 'â„’',
    'lscr;': 'ğ“',
    'lsim;': 'â‰²',
    'lsqb;': '[',
    'ltcc;': 'âª¦',
    'ltri;': 'â—ƒ',
    'lvnE;': 'â‰¨ï¸€',
    'macr;': 'Â¯',
    'male;': 'â™‚',
    'malt;': 'âœ ',
    micro: 'Âµ',
    'mlcp;': 'â«›',
    'mldr;': 'â€¦',
    'Mopf;': 'ğ•„',
    'mopf;': 'ğ•',
    'Mscr;': 'â„³',
    'mscr;': 'ğ“‚',
    'nang;': 'âˆ âƒ’',
    'napE;': 'â©°Ì¸',
    'nbsp;': ' ',
    'ncap;': 'â©ƒ',
    'ncup;': 'â©‚',
    'ngeq;': 'â‰±',
    'nges;': 'â©¾Ì¸',
    'ngtr;': 'â‰¯',
    'nGtv;': 'â‰«Ì¸',
    'nisd;': 'â‹º',
    'NJcy;': 'ĞŠ',
    'njcy;': 'Ñš',
    'nldr;': 'â€¥',
    'nleq;': 'â‰°',
    'nles;': 'â©½Ì¸',
    'nLtv;': 'â‰ªÌ¸',
    'nmid;': 'âˆ¤',
    'Nopf;': 'â„•',
    'nopf;': 'ğ•Ÿ',
    'npar;': 'âˆ¦',
    'npre;': 'âª¯Ì¸',
    'nsce;': 'âª°Ì¸',
    'Nscr;': 'ğ’©',
    'nscr;': 'ğ“ƒ',
    'nsim;': 'â‰',
    'nsub;': 'âŠ„',
    'nsup;': 'âŠ…',
    'ntgl;': 'â‰¹',
    'ntlg;': 'â‰¸',
    'nvap;': 'â‰âƒ’',
    'nvge;': 'â‰¥âƒ’',
    'nvgt;': '>âƒ’',
    'nvle;': 'â‰¤âƒ’',
    'nvlt;': '<âƒ’',
    'oast;': 'âŠ›',
    'ocir;': 'âŠš',
    Ocirc: 'Ã”',
    ocirc: 'Ã´',
    'odiv;': 'â¨¸',
    'odot;': 'âŠ™',
    'ogon;': 'Ë›',
    'oint;': 'âˆ®',
    'omid;': 'â¦¶',
    'Oopf;': 'ğ•†',
    'oopf;': 'ğ• ',
    'opar;': 'â¦·',
    'ordf;': 'Âª',
    'ordm;': 'Âº',
    'oror;': 'â©–',
    'Oscr;': 'ğ’ª',
    'oscr;': 'â„´',
    'osol;': 'âŠ˜',
    'Ouml;': 'Ã–',
    'ouml;': 'Ã¶',
    'para;': 'Â¶',
    'part;': 'âˆ‚',
    'perp;': 'âŠ¥',
    'phiv;': 'Ï•',
    'plus;': '+',
    'Popf;': 'â„™',
    'popf;': 'ğ•¡',
    pound: 'Â£',
    'prap;': 'âª·',
    'prec;': 'â‰º',
    'prnE;': 'âªµ',
    'prod;': 'âˆ',
    'prop;': 'âˆ',
    'Pscr;': 'ğ’«',
    'pscr;': 'ğ“…',
    'qint;': 'â¨Œ',
    'Qopf;': 'â„š',
    'qopf;': 'ğ•¢',
    'Qscr;': 'ğ’¬',
    'qscr;': 'ğ“†',
    'QUOT;': '"',
    'quot;': '"',
    'race;': 'âˆ½Ì±',
    'Rang;': 'âŸ«',
    'rang;': 'âŸ©',
    raquo: 'Â»',
    'Rarr;': 'â† ',
    'rArr;': 'â‡’',
    'rarr;': 'â†’',
    'rcub;': '}',
    'rdca;': 'â¤·',
    'rdsh;': 'â†³',
    'real;': 'â„œ',
    'rect;': 'â–­',
    'rHar;': 'â¥¤',
    'rhov;': 'Ï±',
    'ring;': 'Ëš',
    'Ropf;': 'â„',
    'ropf;': 'ğ•£',
    'rpar;': ')',
    'Rscr;': 'â„›',
    'rscr;': 'ğ“‡',
    'rsqb;': ']',
    'rtri;': 'â–¹',
    'scap;': 'âª¸',
    'scnE;': 'âª¶',
    'sdot;': 'â‹…',
    'sect;': 'Â§',
    'semi;': ';',
    'sext;': 'âœ¶',
    'SHcy;': 'Ğ¨',
    'shcy;': 'Ñˆ',
    'sime;': 'â‰ƒ',
    'simg;': 'âª',
    'siml;': 'âª',
    'smid;': 'âˆ£',
    'smte;': 'âª¬',
    'solb;': 'â§„',
    'Sopf;': 'ğ•Š',
    'sopf;': 'ğ•¤',
    'spar;': 'âˆ¥',
    'Sqrt;': 'âˆš',
    'squf;': 'â–ª',
    'Sscr;': 'ğ’®',
    'sscr;': 'ğ“ˆ',
    'Star;': 'â‹†',
    'star;': 'â˜†',
    'subE;': 'â«…',
    'sube;': 'âŠ†',
    'succ;': 'â‰»',
    'sung;': 'â™ª',
    'sup1;': 'Â¹',
    'sup2;': 'Â²',
    'sup3;': 'Â³',
    'supE;': 'â«†',
    'supe;': 'âŠ‡',
    szlig: 'ÃŸ',
    'tbrk;': 'â´',
    'tdot;': 'âƒ›',
    THORN: 'Ã',
    thorn: 'Ã¾',
    times: 'Ã—',
    'tint;': 'âˆ­',
    'toea;': 'â¤¨',
    'Topf;': 'ğ•‹',
    'topf;': 'ğ•¥',
    'tosa;': 'â¤©',
    'trie;': 'â‰œ',
    'Tscr;': 'ğ’¯',
    'tscr;': 'ğ“‰',
    'TScy;': 'Ğ¦',
    'tscy;': 'Ñ†',
    'Uarr;': 'â†Ÿ',
    'uArr;': 'â‡‘',
    'uarr;': 'â†‘',
    Ucirc: 'Ã›',
    ucirc: 'Ã»',
    'uHar;': 'â¥£',
    'Uopf;': 'ğ•Œ',
    'uopf;': 'ğ•¦',
    'Upsi;': 'Ï’',
    'upsi;': 'Ï…',
    'Uscr;': 'ğ’°',
    'uscr;': 'ğ“Š',
    'utri;': 'â–µ',
    'Uuml;': 'Ãœ',
    'uuml;': 'Ã¼',
    'vArr;': 'â‡•',
    'varr;': 'â†•',
    'Vbar;': 'â««',
    'vBar;': 'â«¨',
    'Vert;': 'â€–',
    'vert;': '|',
    'Vopf;': 'ğ•',
    'vopf;': 'ğ•§',
    'Vscr;': 'ğ’±',
    'vscr;': 'ğ“‹',
    'Wopf;': 'ğ•',
    'wopf;': 'ğ•¨',
    'Wscr;': 'ğ’²',
    'wscr;': 'ğ“Œ',
    'xcap;': 'â‹‚',
    'xcup;': 'â‹ƒ',
    'xmap;': 'âŸ¼',
    'xnis;': 'â‹»',
    'Xopf;': 'ğ•',
    'xopf;': 'ğ•©',
    'Xscr;': 'ğ’³',
    'xscr;': 'ğ“',
    'xvee;': 'â‹',
    'YAcy;': 'Ğ¯',
    'yacy;': 'Ñ',
    'YIcy;': 'Ğ‡',
    'yicy;': 'Ñ—',
    'Yopf;': 'ğ•',
    'yopf;': 'ğ•ª',
    'Yscr;': 'ğ’´',
    'yscr;': 'ğ“',
    'YUcy;': 'Ğ®',
    'yucy;': 'Ñ',
    'Yuml;': 'Å¸',
    'yuml;': 'Ã¿',
    'Zdot;': 'Å»',
    'zdot;': 'Å¼',
    'Zeta;': 'Î–',
    'zeta;': 'Î¶',
    'ZHcy;': 'Ğ–',
    'zhcy;': 'Ğ¶',
    'Zopf;': 'â„¤',
    'zopf;': 'ğ•«',
    'Zscr;': 'ğ’µ',
    'zscr;': 'ğ“',
    'zwnj;': 'â€Œ',
    Aacute: 'Ã',
    aacute: 'Ã¡',
    'Acirc;': 'Ã‚',
    'acirc;': 'Ã¢',
    'acute;': 'Â´',
    'AElig;': 'Ã†',
    'aelig;': 'Ã¦',
    Agrave: 'Ã€',
    agrave: 'Ã ',
    'aleph;': 'â„µ',
    'Alpha;': 'Î‘',
    'alpha;': 'Î±',
    'Amacr;': 'Ä€',
    'amacr;': 'Ä',
    'amalg;': 'â¨¿',
    'angle;': 'âˆ ',
    'angrt;': 'âˆŸ',
    'angst;': 'Ã…',
    'Aogon;': 'Ä„',
    'aogon;': 'Ä…',
    'Aring;': 'Ã…',
    'aring;': 'Ã¥',
    'asymp;': 'â‰ˆ',
    Atilde: 'Ãƒ',
    atilde: 'Ã£',
    'awint;': 'â¨‘',
    'bcong;': 'â‰Œ',
    'bdquo;': 'â€',
    'bepsi;': 'Ï¶',
    'blank;': 'â£',
    'blk12;': 'â–’',
    'blk14;': 'â–‘',
    'blk34;': 'â–“',
    'block;': 'â–ˆ',
    'boxDL;': 'â•—',
    'boxDl;': 'â•–',
    'boxdL;': 'â••',
    'boxdl;': 'â”',
    'boxDR;': 'â•”',
    'boxDr;': 'â•“',
    'boxdR;': 'â•’',
    'boxdr;': 'â”Œ',
    'boxHD;': 'â•¦',
    'boxHd;': 'â•¤',
    'boxhD;': 'â•¥',
    'boxhd;': 'â”¬',
    'boxHU;': 'â•©',
    'boxHu;': 'â•§',
    'boxhU;': 'â•¨',
    'boxhu;': 'â”´',
    'boxUL;': 'â•',
    'boxUl;': 'â•œ',
    'boxuL;': 'â•›',
    'boxul;': 'â”˜',
    'boxUR;': 'â•š',
    'boxUr;': 'â•™',
    'boxuR;': 'â•˜',
    'boxur;': 'â””',
    'boxVH;': 'â•¬',
    'boxVh;': 'â•«',
    'boxvH;': 'â•ª',
    'boxvh;': 'â”¼',
    'boxVL;': 'â•£',
    'boxVl;': 'â•¢',
    'boxvL;': 'â•¡',
    'boxvl;': 'â”¤',
    'boxVR;': 'â• ',
    'boxVr;': 'â•Ÿ',
    'boxvR;': 'â•',
    'boxvr;': 'â”œ',
    'Breve;': 'Ë˜',
    'breve;': 'Ë˜',
    brvbar: 'Â¦',
    'bsemi;': 'â',
    'bsime;': 'â‹',
    'bsolb;': 'â§…',
    'bumpE;': 'âª®',
    'bumpe;': 'â‰',
    'caret;': 'â',
    'caron;': 'Ë‡',
    'ccaps;': 'â©',
    Ccedil: 'Ã‡',
    ccedil: 'Ã§',
    'Ccirc;': 'Äˆ',
    'ccirc;': 'Ä‰',
    'ccups;': 'â©Œ',
    'cedil;': 'Â¸',
    'check;': 'âœ“',
    'clubs;': 'â™£',
    'Colon;': 'âˆ·',
    'colon;': ':',
    'comma;': ',',
    'crarr;': 'â†µ',
    'Cross;': 'â¨¯',
    'cross;': 'âœ—',
    'csube;': 'â«‘',
    'csupe;': 'â«’',
    'ctdot;': 'â‹¯',
    'cuepr;': 'â‹',
    'cuesc;': 'â‹Ÿ',
    'cupor;': 'â©…',
    curren: 'Â¤',
    'cuvee;': 'â‹',
    'cuwed;': 'â‹',
    'cwint;': 'âˆ±',
    'Dashv;': 'â«¤',
    'dashv;': 'âŠ£',
    'dblac;': 'Ë',
    'ddarr;': 'â‡Š',
    'Delta;': 'Î”',
    'delta;': 'Î´',
    'dharl;': 'â‡ƒ',
    'dharr;': 'â‡‚',
    'diams;': 'â™¦',
    'disin;': 'â‹²',
    divide: 'Ã·',
    'doteq;': 'â‰',
    'dtdot;': 'â‹±',
    'dtrif;': 'â–¾',
    'duarr;': 'â‡µ',
    'duhar;': 'â¥¯',
    Eacute: 'Ã‰',
    eacute: 'Ã©',
    'Ecirc;': 'ÃŠ',
    'ecirc;': 'Ãª',
    'eDDot;': 'â©·',
    'efDot;': 'â‰’',
    Egrave: 'Ãˆ',
    egrave: 'Ã¨',
    'Emacr;': 'Ä’',
    'emacr;': 'Ä“',
    'empty;': 'âˆ…',
    'Eogon;': 'Ä˜',
    'eogon;': 'Ä™',
    'eplus;': 'â©±',
    'epsiv;': 'Ïµ',
    'eqsim;': 'â‰‚',
    'Equal;': 'â©µ',
    'equiv;': 'â‰¡',
    'erarr;': 'â¥±',
    'erDot;': 'â‰“',
    'esdot;': 'â‰',
    'exist;': 'âˆƒ',
    'fflig;': 'ï¬€',
    'filig;': 'ï¬',
    'fjlig;': 'fj',
    'fllig;': 'ï¬‚',
    'fltns;': 'â–±',
    'forkv;': 'â«™',
    frac12: 'Â½',
    frac14: 'Â¼',
    frac34: 'Â¾',
    'frasl;': 'â„',
    'frown;': 'âŒ¢',
    'Gamma;': 'Î“',
    'gamma;': 'Î³',
    'Gcirc;': 'Äœ',
    'gcirc;': 'Ä',
    'gescc;': 'âª©',
    'gimel;': 'â„·',
    'gneqq;': 'â‰©',
    'gnsim;': 'â‹§',
    'grave;': '`',
    'gsime;': 'âª',
    'gsiml;': 'âª',
    'gtcir;': 'â©º',
    'gtdot;': 'â‹—',
    'Hacek;': 'Ë‡',
    'harrw;': 'â†­',
    'Hcirc;': 'Ä¤',
    'hcirc;': 'Ä¥',
    'hoarr;': 'â‡¿',
    Iacute: 'Ã',
    iacute: 'Ã­',
    'Icirc;': 'Ã',
    'icirc;': 'Ã®',
    'iexcl;': 'Â¡',
    Igrave: 'ÃŒ',
    igrave: 'Ã¬',
    'iiint;': 'âˆ­',
    'iiota;': 'â„©',
    'IJlig;': 'Ä²',
    'ijlig;': 'Ä³',
    'Imacr;': 'Äª',
    'imacr;': 'Ä«',
    'image;': 'â„‘',
    'imath;': 'Ä±',
    'imped;': 'Æµ',
    'infin;': 'âˆ',
    'Iogon;': 'Ä®',
    'iogon;': 'Ä¯',
    'iprod;': 'â¨¼',
    iquest: 'Â¿',
    'isinE;': 'â‹¹',
    'isins;': 'â‹´',
    'isinv;': 'âˆˆ',
    'Iukcy;': 'Ğ†',
    'iukcy;': 'Ñ–',
    'Jcirc;': 'Ä´',
    'jcirc;': 'Äµ',
    'jmath;': 'È·',
    'Jukcy;': 'Ğ„',
    'jukcy;': 'Ñ”',
    'Kappa;': 'Îš',
    'kappa;': 'Îº',
    'lAarr;': 'â‡š',
    'langd;': 'â¦‘',
    'laquo;': 'Â«',
    'larrb;': 'â‡¤',
    'lates;': 'âª­ï¸€',
    'lBarr;': 'â¤',
    'lbarr;': 'â¤Œ',
    'lbbrk;': 'â²',
    'lbrke;': 'â¦‹',
    'lceil;': 'âŒˆ',
    'ldquo;': 'â€œ',
    'lescc;': 'âª¨',
    'lhard;': 'â†½',
    'lharu;': 'â†¼',
    'lhblk;': 'â–„',
    'llarr;': 'â‡‡',
    'lltri;': 'â—º',
    'lneqq;': 'â‰¨',
    'lnsim;': 'â‹¦',
    'loang;': 'âŸ¬',
    'loarr;': 'â‡½',
    'lobrk;': 'âŸ¦',
    'lopar;': 'â¦…',
    'lrarr;': 'â‡†',
    'lrhar;': 'â‡‹',
    'lrtri;': 'âŠ¿',
    'lsime;': 'âª',
    'lsimg;': 'âª',
    'lsquo;': 'â€˜',
    'ltcir;': 'â©¹',
    'ltdot;': 'â‹–',
    'ltrie;': 'âŠ´',
    'ltrif;': 'â—‚',
    'mdash;': 'â€”',
    'mDDot;': 'âˆº',
    'micro;': 'Âµ',
    middot: 'Â·',
    'minus;': 'âˆ’',
    'mumap;': 'âŠ¸',
    'nabla;': 'âˆ‡',
    'napid;': 'â‰‹Ì¸',
    'napos;': 'Å‰',
    'natur;': 'â™®',
    'nbump;': 'â‰Ì¸',
    'ncong;': 'â‰‡',
    'ndash;': 'â€“',
    'neArr;': 'â‡—',
    'nearr;': 'â†—',
    'nedot;': 'â‰Ì¸',
    'nesim;': 'â‰‚Ì¸',
    'ngeqq;': 'â‰§Ì¸',
    'ngsim;': 'â‰µ',
    'nhArr;': 'â‡',
    'nharr;': 'â†®',
    'nhpar;': 'â«²',
    'nlArr;': 'â‡',
    'nlarr;': 'â†š',
    'nleqq;': 'â‰¦Ì¸',
    'nless;': 'â‰®',
    'nlsim;': 'â‰´',
    'nltri;': 'â‹ª',
    'notin;': 'âˆ‰',
    'notni;': 'âˆŒ',
    'npart;': 'âˆ‚Ì¸',
    'nprec;': 'âŠ€',
    'nrArr;': 'â‡',
    'nrarr;': 'â†›',
    'nrtri;': 'â‹«',
    'nsime;': 'â‰„',
    'nsmid;': 'âˆ¤',
    'nspar;': 'âˆ¦',
    'nsubE;': 'â«…Ì¸',
    'nsube;': 'âŠˆ',
    'nsucc;': 'âŠ',
    'nsupE;': 'â«†Ì¸',
    'nsupe;': 'âŠ‰',
    Ntilde: 'Ã‘',
    ntilde: 'Ã±',
    'numsp;': 'â€‡',
    'nvsim;': 'âˆ¼âƒ’',
    'nwArr;': 'â‡–',
    'nwarr;': 'â†–',
    Oacute: 'Ã“',
    oacute: 'Ã³',
    'Ocirc;': 'Ã”',
    'ocirc;': 'Ã´',
    'odash;': 'âŠ',
    'OElig;': 'Å’',
    'oelig;': 'Å“',
    'ofcir;': 'â¦¿',
    Ograve: 'Ã’',
    ograve: 'Ã²',
    'ohbar;': 'â¦µ',
    'olarr;': 'â†º',
    'olcir;': 'â¦¾',
    'oline;': 'â€¾',
    'Omacr;': 'ÅŒ',
    'omacr;': 'Å',
    'Omega;': 'Î©',
    'omega;': 'Ï‰',
    'operp;': 'â¦¹',
    'oplus;': 'âŠ•',
    'orarr;': 'â†»',
    'order;': 'â„´',
    Oslash: 'Ã˜',
    oslash: 'Ã¸',
    Otilde: 'Ã•',
    otilde: 'Ãµ',
    'ovbar;': 'âŒ½',
    'parsl;': 'â«½',
    'phone;': 'â˜',
    'plusb;': 'âŠ',
    'pluse;': 'â©²',
    plusmn: 'Â±',
    'pound;': 'Â£',
    'prcue;': 'â‰¼',
    'Prime;': 'â€³',
    'prime;': 'â€²',
    'prnap;': 'âª¹',
    'prsim;': 'â‰¾',
    'quest;': '?',
    'rAarr;': 'â‡›',
    'radic;': 'âˆš',
    'rangd;': 'â¦’',
    'range;': 'â¦¥',
    'raquo;': 'Â»',
    'rarrb;': 'â‡¥',
    'rarrc;': 'â¤³',
    'rarrw;': 'â†',
    'ratio;': 'âˆ¶',
    'RBarr;': 'â¤',
    'rBarr;': 'â¤',
    'rbarr;': 'â¤',
    'rbbrk;': 'â³',
    'rbrke;': 'â¦Œ',
    'rceil;': 'âŒ‰',
    'rdquo;': 'â€',
    'reals;': 'â„',
    'rhard;': 'â‡',
    'rharu;': 'â‡€',
    'rlarr;': 'â‡„',
    'rlhar;': 'â‡Œ',
    'rnmid;': 'â«®',
    'roang;': 'âŸ­',
    'roarr;': 'â‡¾',
    'robrk;': 'âŸ§',
    'ropar;': 'â¦†',
    'rrarr;': 'â‡‰',
    'rsquo;': 'â€™',
    'rtrie;': 'âŠµ',
    'rtrif;': 'â–¸',
    'sbquo;': 'â€š',
    'sccue;': 'â‰½',
    'Scirc;': 'Åœ',
    'scirc;': 'Å',
    'scnap;': 'âªº',
    'scsim;': 'â‰¿',
    'sdotb;': 'âŠ¡',
    'sdote;': 'â©¦',
    'seArr;': 'â‡˜',
    'searr;': 'â†˜',
    'setmn;': 'âˆ–',
    'sharp;': 'â™¯',
    'Sigma;': 'Î£',
    'sigma;': 'Ïƒ',
    'simeq;': 'â‰ƒ',
    'simgE;': 'âª ',
    'simlE;': 'âªŸ',
    'simne;': 'â‰†',
    'slarr;': 'â†',
    'smile;': 'âŒ£',
    'smtes;': 'âª¬ï¸€',
    'sqcap;': 'âŠ“',
    'sqcup;': 'âŠ”',
    'sqsub;': 'âŠ',
    'sqsup;': 'âŠ',
    'srarr;': 'â†’',
    'starf;': 'â˜…',
    'strns;': 'Â¯',
    'subnE;': 'â«‹',
    'subne;': 'âŠŠ',
    'supnE;': 'â«Œ',
    'supne;': 'âŠ‹',
    'swArr;': 'â‡™',
    'swarr;': 'â†™',
    'szlig;': 'ÃŸ',
    'Theta;': 'Î˜',
    'theta;': 'Î¸',
    'thkap;': 'â‰ˆ',
    'THORN;': 'Ã',
    'thorn;': 'Ã¾',
    'Tilde;': 'âˆ¼',
    'tilde;': 'Ëœ',
    'times;': 'Ã—',
    'TRADE;': 'â„¢',
    'trade;': 'â„¢',
    'trisb;': 'â§',
    'TSHcy;': 'Ğ‹',
    'tshcy;': 'Ñ›',
    'twixt;': 'â‰¬',
    Uacute: 'Ãš',
    uacute: 'Ãº',
    'Ubrcy;': 'Ğ',
    'ubrcy;': 'Ñ',
    'Ucirc;': 'Ã›',
    'ucirc;': 'Ã»',
    'udarr;': 'â‡…',
    'udhar;': 'â¥®',
    Ugrave: 'Ã™',
    ugrave: 'Ã¹',
    'uharl;': 'â†¿',
    'uharr;': 'â†¾',
    'uhblk;': 'â–€',
    'ultri;': 'â—¸',
    'Umacr;': 'Åª',
    'umacr;': 'Å«',
    'Union;': 'â‹ƒ',
    'Uogon;': 'Å²',
    'uogon;': 'Å³',
    'uplus;': 'âŠ',
    'upsih;': 'Ï’',
    'UpTee;': 'âŠ¥',
    'Uring;': 'Å®',
    'uring;': 'Å¯',
    'urtri;': 'â—¹',
    'utdot;': 'â‹°',
    'utrif;': 'â–´',
    'uuarr;': 'â‡ˆ',
    'varpi;': 'Ï–',
    'vBarv;': 'â«©',
    'VDash;': 'âŠ«',
    'Vdash;': 'âŠ©',
    'vDash;': 'âŠ¨',
    'vdash;': 'âŠ¢',
    'veeeq;': 'â‰š',
    'vltri;': 'âŠ²',
    'vnsub;': 'âŠ‚âƒ’',
    'vnsup;': 'âŠƒâƒ’',
    'vprop;': 'âˆ',
    'vrtri;': 'âŠ³',
    'Wcirc;': 'Å´',
    'wcirc;': 'Åµ',
    'Wedge;': 'â‹€',
    'wedge;': 'âˆ§',
    'xcirc;': 'â—¯',
    'xdtri;': 'â–½',
    'xhArr;': 'âŸº',
    'xharr;': 'âŸ·',
    'xlArr;': 'âŸ¸',
    'xlarr;': 'âŸµ',
    'xodot;': 'â¨€',
    'xrArr;': 'âŸ¹',
    'xrarr;': 'âŸ¶',
    'xutri;': 'â–³',
    Yacute: 'Ã',
    yacute: 'Ã½',
    'Ycirc;': 'Å¶',
    'ycirc;': 'Å·',
    'Aacute;': 'Ã',
    'aacute;': 'Ã¡',
    'Abreve;': 'Ä‚',
    'abreve;': 'Äƒ',
    'Agrave;': 'Ã€',
    'agrave;': 'Ã ',
    'andand;': 'â©•',
    'angmsd;': 'âˆ¡',
    'angsph;': 'âˆ¢',
    'apacir;': 'â©¯',
    'approx;': 'â‰ˆ',
    'Assign;': 'â‰”',
    'Atilde;': 'Ãƒ',
    'atilde;': 'Ã£',
    'barvee;': 'âŠ½',
    'Barwed;': 'âŒ†',
    'barwed;': 'âŒ…',
    'becaus;': 'âˆµ',
    'bernou;': 'â„¬',
    'bigcap;': 'â‹‚',
    'bigcup;': 'â‹ƒ',
    'bigvee;': 'â‹',
    'bkarow;': 'â¤',
    'bottom;': 'âŠ¥',
    'bowtie;': 'â‹ˆ',
    'boxbox;': 'â§‰',
    'bprime;': 'â€µ',
    'brvbar;': 'Â¦',
    'bullet;': 'â€¢',
    'Bumpeq;': 'â‰',
    'bumpeq;': 'â‰',
    'Cacute;': 'Ä†',
    'cacute;': 'Ä‡',
    'capand;': 'â©„',
    'capcap;': 'â©‹',
    'capcup;': 'â©‡',
    'capdot;': 'â©€',
    'Ccaron;': 'ÄŒ',
    'ccaron;': 'Ä',
    'Ccedil;': 'Ã‡',
    'ccedil;': 'Ã§',
    'circeq;': 'â‰—',
    'cirmid;': 'â«¯',
    'Colone;': 'â©´',
    'colone;': 'â‰”',
    'commat;': '@',
    'compfn;': 'âˆ˜',
    'Conint;': 'âˆ¯',
    'conint;': 'âˆ®',
    'coprod;': 'âˆ',
    'copysr;': 'â„—',
    'cularr;': 'â†¶',
    'CupCap;': 'â‰',
    'cupcap;': 'â©†',
    'cupcup;': 'â©Š',
    'cupdot;': 'âŠ',
    'curarr;': 'â†·',
    'curren;': 'Â¤',
    'cylcty;': 'âŒ­',
    'Dagger;': 'â€¡',
    'dagger;': 'â€ ',
    'daleth;': 'â„¸',
    'Dcaron;': 'Ä',
    'dcaron;': 'Ä',
    'dfisht;': 'â¥¿',
    'divide;': 'Ã·',
    'divonx;': 'â‹‡',
    'dlcorn;': 'âŒ',
    'dlcrop;': 'âŒ',
    'dollar;': '$',
    'DotDot;': 'âƒœ',
    'drcorn;': 'âŒŸ',
    'drcrop;': 'âŒŒ',
    'Dstrok;': 'Ä',
    'dstrok;': 'Ä‘',
    'Eacute;': 'Ã‰',
    'eacute;': 'Ã©',
    'easter;': 'â©®',
    'Ecaron;': 'Äš',
    'ecaron;': 'Ä›',
    'ecolon;': 'â‰•',
    'Egrave;': 'Ãˆ',
    'egrave;': 'Ã¨',
    'egsdot;': 'âª˜',
    'elsdot;': 'âª—',
    'emptyv;': 'âˆ…',
    'emsp13;': 'â€„',
    'emsp14;': 'â€…',
    'eparsl;': 'â§£',
    'eqcirc;': 'â‰–',
    'equals;': '=',
    'equest;': 'â‰Ÿ',
    'Exists;': 'âˆƒ',
    'female;': 'â™€',
    'ffilig;': 'ï¬ƒ',
    'ffllig;': 'ï¬„',
    'ForAll;': 'âˆ€',
    'forall;': 'âˆ€',
    'frac12;': 'Â½',
    'frac13;': 'â…“',
    'frac14;': 'Â¼',
    'frac15;': 'â…•',
    'frac16;': 'â…™',
    'frac18;': 'â…›',
    'frac23;': 'â…”',
    'frac25;': 'â…–',
    'frac34;': 'Â¾',
    'frac35;': 'â…—',
    'frac38;': 'â…œ',
    'frac45;': 'â…˜',
    'frac56;': 'â…š',
    'frac58;': 'â…',
    'frac78;': 'â…',
    'gacute;': 'Çµ',
    'Gammad;': 'Ïœ',
    'gammad;': 'Ï',
    'Gbreve;': 'Ä',
    'gbreve;': 'ÄŸ',
    'Gcedil;': 'Ä¢',
    'gesdot;': 'âª€',
    'gesles;': 'âª”',
    'gtlPar;': 'â¦•',
    'gtrarr;': 'â¥¸',
    'gtrdot;': 'â‹—',
    'gtrsim;': 'â‰³',
    'hairsp;': 'â€Š',
    'hamilt;': 'â„‹',
    'HARDcy;': 'Ğª',
    'hardcy;': 'ÑŠ',
    'hearts;': 'â™¥',
    'hellip;': 'â€¦',
    'hercon;': 'âŠ¹',
    'homtht;': 'âˆ»',
    'horbar;': 'â€•',
    'hslash;': 'â„',
    'Hstrok;': 'Ä¦',
    'hstrok;': 'Ä§',
    'hybull;': 'âƒ',
    'hyphen;': 'â€',
    'Iacute;': 'Ã',
    'iacute;': 'Ã­',
    'Igrave;': 'ÃŒ',
    'igrave;': 'Ã¬',
    'iiiint;': 'â¨Œ',
    'iinfin;': 'â§œ',
    'incare;': 'â„…',
    'inodot;': 'Ä±',
    'intcal;': 'âŠº',
    'iquest;': 'Â¿',
    'isinsv;': 'â‹³',
    'Itilde;': 'Ä¨',
    'itilde;': 'Ä©',
    'Jsercy;': 'Ğˆ',
    'jsercy;': 'Ñ˜',
    'kappav;': 'Ï°',
    'Kcedil;': 'Ä¶',
    'kcedil;': 'Ä·',
    'kgreen;': 'Ä¸',
    'Lacute;': 'Ä¹',
    'lacute;': 'Äº',
    'lagran;': 'â„’',
    'Lambda;': 'Î›',
    'lambda;': 'Î»',
    'langle;': 'âŸ¨',
    'larrfs;': 'â¤',
    'larrhk;': 'â†©',
    'larrlp;': 'â†«',
    'larrpl;': 'â¤¹',
    'larrtl;': 'â†¢',
    'lAtail;': 'â¤›',
    'latail;': 'â¤™',
    'lbrace;': '{',
    'lbrack;': '[',
    'Lcaron;': 'Ä½',
    'lcaron;': 'Ä¾',
    'Lcedil;': 'Ä»',
    'lcedil;': 'Ä¼',
    'ldquor;': 'â€',
    'lesdot;': 'â©¿',
    'lesges;': 'âª“',
    'lfisht;': 'â¥¼',
    'lfloor;': 'âŒŠ',
    'lharul;': 'â¥ª',
    'llhard;': 'â¥«',
    'Lmidot;': 'Ä¿',
    'lmidot;': 'Å€',
    'lmoust;': 'â°',
    'loplus;': 'â¨­',
    'lowast;': 'âˆ—',
    'lowbar;': '_',
    'lparlt;': 'â¦“',
    'lrhard;': 'â¥­',
    'lsaquo;': 'â€¹',
    'lsquor;': 'â€š',
    'Lstrok;': 'Å',
    'lstrok;': 'Å‚',
    'lthree;': 'â‹‹',
    'ltimes;': 'â‹‰',
    'ltlarr;': 'â¥¶',
    'ltrPar;': 'â¦–',
    'mapsto;': 'â†¦',
    'marker;': 'â–®',
    'mcomma;': 'â¨©',
    'midast;': '*',
    'midcir;': 'â«°',
    'middot;': 'Â·',
    'minusb;': 'âŠŸ',
    'minusd;': 'âˆ¸',
    'mnplus;': 'âˆ“',
    'models;': 'âŠ§',
    'mstpos;': 'âˆ¾',
    'Nacute;': 'Åƒ',
    'nacute;': 'Å„',
    'nbumpe;': 'â‰Ì¸',
    'Ncaron;': 'Å‡',
    'ncaron;': 'Åˆ',
    'Ncedil;': 'Å…',
    'ncedil;': 'Å†',
    'nearhk;': 'â¤¤',
    'nequiv;': 'â‰¢',
    'nesear;': 'â¤¨',
    'nexist;': 'âˆ„',
    'nltrie;': 'â‹¬',
    'notinE;': 'â‹¹Ì¸',
    'nparsl;': 'â«½âƒ¥',
    'nprcue;': 'â‹ ',
    'nrarrc;': 'â¤³Ì¸',
    'nrarrw;': 'â†Ì¸',
    'nrtrie;': 'â‹­',
    'nsccue;': 'â‹¡',
    'nsimeq;': 'â‰„',
    'Ntilde;': 'Ã‘',
    'ntilde;': 'Ã±',
    'numero;': 'â„–',
    'nVDash;': 'âŠ¯',
    'nVdash;': 'âŠ®',
    'nvDash;': 'âŠ­',
    'nvdash;': 'âŠ¬',
    'nvHarr;': 'â¤„',
    'nvlArr;': 'â¤‚',
    'nvrArr;': 'â¤ƒ',
    'nwarhk;': 'â¤£',
    'nwnear;': 'â¤§',
    'Oacute;': 'Ã“',
    'oacute;': 'Ã³',
    'Odblac;': 'Å',
    'odblac;': 'Å‘',
    'odsold;': 'â¦¼',
    'Ograve;': 'Ã’',
    'ograve;': 'Ã²',
    'ominus;': 'âŠ–',
    'origof;': 'âŠ¶',
    'Oslash;': 'Ã˜',
    'oslash;': 'Ã¸',
    'Otilde;': 'Ã•',
    'otilde;': 'Ãµ',
    'Otimes;': 'â¨·',
    'otimes;': 'âŠ—',
    'parsim;': 'â«³',
    'percnt;': '%',
    'period;': '.',
    'permil;': 'â€°',
    'phmmat;': 'â„³',
    'planck;': 'â„',
    'plankv;': 'â„',
    'plusdo;': 'âˆ”',
    'plusdu;': 'â¨¥',
    'plusmn;': 'Â±',
    'preceq;': 'âª¯',
    'primes;': 'â„™',
    'prnsim;': 'â‹¨',
    'propto;': 'âˆ',
    'prurel;': 'âŠ°',
    'puncsp;': 'â€ˆ',
    'qprime;': 'â—',
    'Racute;': 'Å”',
    'racute;': 'Å•',
    'rangle;': 'âŸ©',
    'rarrap;': 'â¥µ',
    'rarrfs;': 'â¤',
    'rarrhk;': 'â†ª',
    'rarrlp;': 'â†¬',
    'rarrpl;': 'â¥…',
    'Rarrtl;': 'â¤–',
    'rarrtl;': 'â†£',
    'rAtail;': 'â¤œ',
    'ratail;': 'â¤š',
    'rbrace;': '}',
    'rbrack;': ']',
    'Rcaron;': 'Å˜',
    'rcaron;': 'Å™',
    'Rcedil;': 'Å–',
    'rcedil;': 'Å—',
    'rdquor;': 'â€',
    'rfisht;': 'â¥½',
    'rfloor;': 'âŒ‹',
    'rharul;': 'â¥¬',
    'rmoust;': 'â±',
    'roplus;': 'â¨®',
    'rpargt;': 'â¦”',
    'rsaquo;': 'â€º',
    'rsquor;': 'â€™',
    'rthree;': 'â‹Œ',
    'rtimes;': 'â‹Š',
    'Sacute;': 'Åš',
    'sacute;': 'Å›',
    'Scaron;': 'Å ',
    'scaron;': 'Å¡',
    'Scedil;': 'Å',
    'scedil;': 'ÅŸ',
    'scnsim;': 'â‹©',
    'searhk;': 'â¤¥',
    'seswar;': 'â¤©',
    'sfrown;': 'âŒ¢',
    'SHCHcy;': 'Ğ©',
    'shchcy;': 'Ñ‰',
    'sigmaf;': 'Ï‚',
    'sigmav;': 'Ï‚',
    'simdot;': 'â©ª',
    'smashp;': 'â¨³',
    'SOFTcy;': 'Ğ¬',
    'softcy;': 'ÑŒ',
    'solbar;': 'âŒ¿',
    'spades;': 'â™ ',
    'sqcaps;': 'âŠ“ï¸€',
    'sqcups;': 'âŠ”ï¸€',
    'sqsube;': 'âŠ‘',
    'sqsupe;': 'âŠ’',
    'Square;': 'â–¡',
    'square;': 'â–¡',
    'squarf;': 'â–ª',
    'ssetmn;': 'âˆ–',
    'ssmile;': 'âŒ£',
    'sstarf;': 'â‹†',
    'subdot;': 'âª½',
    'Subset;': 'â‹',
    'subset;': 'âŠ‚',
    'subsim;': 'â«‡',
    'subsub;': 'â«•',
    'subsup;': 'â«“',
    'succeq;': 'âª°',
    'supdot;': 'âª¾',
    'Supset;': 'â‹‘',
    'supset;': 'âŠƒ',
    'supsim;': 'â«ˆ',
    'supsub;': 'â«”',
    'supsup;': 'â«–',
    'swarhk;': 'â¤¦',
    'swnwar;': 'â¤ª',
    'target;': 'âŒ–',
    'Tcaron;': 'Å¤',
    'tcaron;': 'Å¥',
    'Tcedil;': 'Å¢',
    'tcedil;': 'Å£',
    'telrec;': 'âŒ•',
    'there4;': 'âˆ´',
    'thetav;': 'Ï‘',
    'thinsp;': 'â€‰',
    'thksim;': 'âˆ¼',
    'timesb;': 'âŠ ',
    'timesd;': 'â¨°',
    'topbot;': 'âŒ¶',
    'topcir;': 'â«±',
    'tprime;': 'â€´',
    'tridot;': 'â—¬',
    'Tstrok;': 'Å¦',
    'tstrok;': 'Å§',
    'Uacute;': 'Ãš',
    'uacute;': 'Ãº',
    'Ubreve;': 'Å¬',
    'ubreve;': 'Å­',
    'Udblac;': 'Å°',
    'udblac;': 'Å±',
    'ufisht;': 'â¥¾',
    'Ugrave;': 'Ã™',
    'ugrave;': 'Ã¹',
    'ulcorn;': 'âŒœ',
    'ulcrop;': 'âŒ',
    'urcorn;': 'âŒ',
    'urcrop;': 'âŒ',
    'Utilde;': 'Å¨',
    'utilde;': 'Å©',
    'vangrt;': 'â¦œ',
    'varphi;': 'Ï•',
    'varrho;': 'Ï±',
    'Vdashl;': 'â«¦',
    'veebar;': 'âŠ»',
    'vellip;': 'â‹®',
    'Verbar;': 'â€–',
    'verbar;': '|',
    'vsubnE;': 'â«‹ï¸€',
    'vsubne;': 'âŠŠï¸€',
    'vsupnE;': 'â«Œï¸€',
    'vsupne;': 'âŠ‹ï¸€',
    'Vvdash;': 'âŠª',
    'wedbar;': 'â©Ÿ',
    'wedgeq;': 'â‰™',
    'weierp;': 'â„˜',
    'wreath;': 'â‰€',
    'xoplus;': 'â¨',
    'xotime;': 'â¨‚',
    'xsqcup;': 'â¨†',
    'xuplus;': 'â¨„',
    'xwedge;': 'â‹€',
    'Yacute;': 'Ã',
    'yacute;': 'Ã½',
    'Zacute;': 'Å¹',
    'zacute;': 'Åº',
    'Zcaron;': 'Å½',
    'zcaron;': 'Å¾',
    'zeetrf;': 'â„¨',
    'alefsym;': 'â„µ',
    'angrtvb;': 'âŠ¾',
    'angzarr;': 'â¼',
    'asympeq;': 'â‰',
    'backsim;': 'âˆ½',
    'Because;': 'âˆµ',
    'because;': 'âˆµ',
    'bemptyv;': 'â¦°',
    'between;': 'â‰¬',
    'bigcirc;': 'â—¯',
    'bigodot;': 'â¨€',
    'bigstar;': 'â˜…',
    'bnequiv;': 'â‰¡âƒ¥',
    'boxplus;': 'âŠ',
    'Cayleys;': 'â„­',
    'Cconint;': 'âˆ°',
    'ccupssm;': 'â©',
    'Cedilla;': 'Â¸',
    'cemptyv;': 'â¦²',
    'cirscir;': 'â§‚',
    'coloneq;': 'â‰”',
    'congdot;': 'â©­',
    'cudarrl;': 'â¤¸',
    'cudarrr;': 'â¤µ',
    'cularrp;': 'â¤½',
    'curarrm;': 'â¤¼',
    'dbkarow;': 'â¤',
    'ddagger;': 'â€¡',
    'ddotseq;': 'â©·',
    'demptyv;': 'â¦±',
    'Diamond;': 'â‹„',
    'diamond;': 'â‹„',
    'digamma;': 'Ï',
    'dotplus;': 'âˆ”',
    'DownTee;': 'âŠ¤',
    'dwangle;': 'â¦¦',
    'Element;': 'âˆˆ',
    'Epsilon;': 'Î•',
    'epsilon;': 'Îµ',
    'eqcolon;': 'â‰•',
    'equivDD;': 'â©¸',
    'gesdoto;': 'âª‚',
    'gtquest;': 'â©¼',
    'gtrless;': 'â‰·',
    'harrcir;': 'â¥ˆ',
    'Implies;': 'â‡’',
    'intprod;': 'â¨¼',
    'isindot;': 'â‹µ',
    'larrbfs;': 'â¤Ÿ',
    'larrsim;': 'â¥³',
    'lbrksld;': 'â¦',
    'lbrkslu;': 'â¦',
    'ldrdhar;': 'â¥§',
    'LeftTee;': 'âŠ£',
    'lesdoto;': 'âª',
    'lessdot;': 'â‹–',
    'lessgtr;': 'â‰¶',
    'lesssim;': 'â‰²',
    'lotimes;': 'â¨´',
    'lozenge;': 'â—Š',
    'ltquest;': 'â©»',
    'luruhar;': 'â¥¦',
    'maltese;': 'âœ ',
    'minusdu;': 'â¨ª',
    'napprox;': 'â‰‰',
    'natural;': 'â™®',
    'nearrow;': 'â†—',
    'NewLine;': '\n',
    'nexists;': 'âˆ„',
    'NoBreak;': 'â ',
    'notinva;': 'âˆ‰',
    'notinvb;': 'â‹·',
    'notinvc;': 'â‹¶',
    'NotLess;': 'â‰®',
    'notniva;': 'âˆŒ',
    'notnivb;': 'â‹¾',
    'notnivc;': 'â‹½',
    'npolint;': 'â¨”',
    'npreceq;': 'âª¯Ì¸',
    'nsqsube;': 'â‹¢',
    'nsqsupe;': 'â‹£',
    'nsubset;': 'âŠ‚âƒ’',
    'nsucceq;': 'âª°Ì¸',
    'nsupset;': 'âŠƒâƒ’',
    'nvinfin;': 'â§',
    'nvltrie;': 'âŠ´âƒ’',
    'nvrtrie;': 'âŠµâƒ’',
    'nwarrow;': 'â†–',
    'olcross;': 'â¦»',
    'Omicron;': 'ÎŸ',
    'omicron;': 'Î¿',
    'orderof;': 'â„´',
    'orslope;': 'â©—',
    'OverBar;': 'â€¾',
    'pertenk;': 'â€±',
    'planckh;': 'â„',
    'pluscir;': 'â¨¢',
    'plussim;': 'â¨¦',
    'plustwo;': 'â¨§',
    'precsim;': 'â‰¾',
    'Product;': 'âˆ',
    'quatint;': 'â¨–',
    'questeq;': 'â‰Ÿ',
    'rarrbfs;': 'â¤ ',
    'rarrsim;': 'â¥´',
    'rbrksld;': 'â¦',
    'rbrkslu;': 'â¦',
    'rdldhar;': 'â¥©',
    'realine;': 'â„›',
    'rotimes;': 'â¨µ',
    'ruluhar;': 'â¥¨',
    'searrow;': 'â†˜',
    'simplus;': 'â¨¤',
    'simrarr;': 'â¥²',
    'subedot;': 'â«ƒ',
    'submult;': 'â«',
    'subplus;': 'âª¿',
    'subrarr;': 'â¥¹',
    'succsim;': 'â‰¿',
    'supdsub;': 'â«˜',
    'supedot;': 'â«„',
    'suphsol;': 'âŸ‰',
    'suphsub;': 'â«—',
    'suplarr;': 'â¥»',
    'supmult;': 'â«‚',
    'supplus;': 'â«€',
    'swarrow;': 'â†™',
    'topfork;': 'â«š',
    'triplus;': 'â¨¹',
    'tritime;': 'â¨»',
    'UpArrow;': 'â†‘',
    'Uparrow;': 'â‡‘',
    'uparrow;': 'â†‘',
    'Upsilon;': 'Î¥',
    'upsilon;': 'Ï…',
    'uwangle;': 'â¦§',
    'vzigzag;': 'â¦š',
    'zigrarr;': 'â‡',
    'andslope;': 'â©˜',
    'angmsdaa;': 'â¦¨',
    'angmsdab;': 'â¦©',
    'angmsdac;': 'â¦ª',
    'angmsdad;': 'â¦«',
    'angmsdae;': 'â¦¬',
    'angmsdaf;': 'â¦­',
    'angmsdag;': 'â¦®',
    'angmsdah;': 'â¦¯',
    'angrtvbd;': 'â¦',
    'approxeq;': 'â‰Š',
    'awconint;': 'âˆ³',
    'backcong;': 'â‰Œ',
    'barwedge;': 'âŒ…',
    'bbrktbrk;': 'â¶',
    'bigoplus;': 'â¨',
    'bigsqcup;': 'â¨†',
    'biguplus;': 'â¨„',
    'bigwedge;': 'â‹€',
    'boxminus;': 'âŠŸ',
    'boxtimes;': 'âŠ ',
    'bsolhsub;': 'âŸˆ',
    'capbrcup;': 'â©‰',
    'circledR;': 'Â®',
    'circledS;': 'â“ˆ',
    'cirfnint;': 'â¨',
    'clubsuit;': 'â™£',
    'cupbrcap;': 'â©ˆ',
    'curlyvee;': 'â‹',
    'cwconint;': 'âˆ²',
    'DDotrahd;': 'â¤‘',
    'doteqdot;': 'â‰‘',
    'DotEqual;': 'â‰',
    'dotminus;': 'âˆ¸',
    'drbkarow;': 'â¤',
    'dzigrarr;': 'âŸ¿',
    'elinters;': 'â§',
    'emptyset;': 'âˆ…',
    'eqvparsl;': 'â§¥',
    'fpartint;': 'â¨',
    'geqslant;': 'â©¾',
    'gesdotol;': 'âª„',
    'gnapprox;': 'âªŠ',
    'hksearow;': 'â¤¥',
    'hkswarow;': 'â¤¦',
    'imagline;': 'â„',
    'imagpart;': 'â„‘',
    'infintie;': 'â§',
    'integers;': 'â„¤',
    'Integral;': 'âˆ«',
    'intercal;': 'âŠº',
    'intlarhk;': 'â¨—',
    'laemptyv;': 'â¦´',
    'ldrushar;': 'â¥‹',
    'leqslant;': 'â©½',
    'lesdotor;': 'âªƒ',
    'LessLess;': 'âª¡',
    'llcorner;': 'âŒ',
    'lnapprox;': 'âª‰',
    'lrcorner;': 'âŒŸ',
    'lurdshar;': 'â¥Š',
    'mapstoup;': 'â†¥',
    'multimap;': 'âŠ¸',
    'naturals;': 'â„•',
    'ncongdot;': 'â©­Ì¸',
    'NotEqual;': 'â‰ ',
    'notindot;': 'â‹µÌ¸',
    'NotTilde;': 'â‰',
    'otimesas;': 'â¨¶',
    'parallel;': 'âˆ¥',
    'PartialD;': 'âˆ‚',
    'plusacir;': 'â¨£',
    'pointint;': 'â¨•',
    'Precedes;': 'â‰º',
    'precneqq;': 'âªµ',
    'precnsim;': 'â‹¨',
    'profalar;': 'âŒ®',
    'profline;': 'âŒ’',
    'profsurf;': 'âŒ“',
    'raemptyv;': 'â¦³',
    'realpart;': 'â„œ',
    'RightTee;': 'âŠ¢',
    'rppolint;': 'â¨’',
    'rtriltri;': 'â§',
    'scpolint;': 'â¨“',
    'setminus;': 'âˆ–',
    'shortmid;': 'âˆ£',
    'smeparsl;': 'â§¤',
    'sqsubset;': 'âŠ',
    'sqsupset;': 'âŠ',
    'subseteq;': 'âŠ†',
    'Succeeds;': 'â‰»',
    'succneqq;': 'âª¶',
    'succnsim;': 'â‹©',
    'SuchThat;': 'âˆ‹',
    'Superset;': 'âŠƒ',
    'supseteq;': 'âŠ‡',
    'thetasym;': 'Ï‘',
    'thicksim;': 'âˆ¼',
    'timesbar;': 'â¨±',
    'triangle;': 'â–µ',
    'triminus;': 'â¨º',
    'trpezium;': 'â¢',
    'Uarrocir;': 'â¥‰',
    'ulcorner;': 'âŒœ',
    'UnderBar;': '_',
    'urcorner;': 'âŒ',
    'varkappa;': 'Ï°',
    'varsigma;': 'Ï‚',
    'vartheta;': 'Ï‘',
    'backprime;': 'â€µ',
    'backsimeq;': 'â‹',
    'Backslash;': 'âˆ–',
    'bigotimes;': 'â¨‚',
    'CenterDot;': 'Â·',
    'centerdot;': 'Â·',
    'checkmark;': 'âœ“',
    'CircleDot;': 'âŠ™',
    'complexes;': 'â„‚',
    'Congruent;': 'â‰¡',
    'Coproduct;': 'âˆ',
    'dotsquare;': 'âŠ¡',
    'DoubleDot;': 'Â¨',
    'DownArrow;': 'â†“',
    'Downarrow;': 'â‡“',
    'downarrow;': 'â†“',
    'DownBreve;': 'Ì‘',
    'gtrapprox;': 'âª†',
    'gtreqless;': 'â‹›',
    'gvertneqq;': 'â‰©ï¸€',
    'heartsuit;': 'â™¥',
    'HumpEqual;': 'â‰',
    'LeftArrow;': 'â†',
    'Leftarrow;': 'â‡',
    'leftarrow;': 'â†',
    'LeftFloor;': 'âŒŠ',
    'lesseqgtr;': 'â‹š',
    'LessTilde;': 'â‰²',
    'lvertneqq;': 'â‰¨ï¸€',
    'Mellintrf;': 'â„³',
    'MinusPlus;': 'âˆ“',
    'ngeqslant;': 'â©¾Ì¸',
    'nleqslant;': 'â©½Ì¸',
    'NotCupCap;': 'â‰­',
    'NotExists;': 'âˆ„',
    'NotSubset;': 'âŠ‚âƒ’',
    'nparallel;': 'âˆ¦',
    'nshortmid;': 'âˆ¤',
    'nsubseteq;': 'âŠˆ',
    'nsupseteq;': 'âŠ‰',
    'OverBrace;': 'â',
    'pitchfork;': 'â‹”',
    'PlusMinus;': 'Â±',
    'rationals;': 'â„š',
    'spadesuit;': 'â™ ',
    'subseteqq;': 'â«…',
    'subsetneq;': 'âŠŠ',
    'supseteqq;': 'â«†',
    'supsetneq;': 'âŠ‹',
    'Therefore;': 'âˆ´',
    'therefore;': 'âˆ´',
    'ThinSpace;': 'â€‰',
    'triangleq;': 'â‰œ',
    'TripleDot;': 'âƒ›',
    'UnionPlus;': 'âŠ',
    'varpropto;': 'âˆ',
    'Bernoullis;': 'â„¬',
    'circledast;': 'âŠ›',
    'CirclePlus;': 'âŠ•',
    'complement;': 'âˆ',
    'curlywedge;': 'â‹',
    'eqslantgtr;': 'âª–',
    'EqualTilde;': 'â‰‚',
    'Fouriertrf;': 'â„±',
    'gtreqqless;': 'âªŒ',
    'ImaginaryI;': 'â…ˆ',
    'Laplacetrf;': 'â„’',
    'LeftVector;': 'â†¼',
    'lessapprox;': 'âª…',
    'lesseqqgtr;': 'âª‹',
    'Lleftarrow;': 'â‡š',
    'lmoustache;': 'â°',
    'longmapsto;': 'âŸ¼',
    'mapstodown;': 'â†§',
    'mapstoleft;': 'â†¤',
    'nLeftarrow;': 'â‡',
    'nleftarrow;': 'â†š',
    'NotElement;': 'âˆ‰',
    'NotGreater;': 'â‰¯',
    'nsubseteqq;': 'â«…Ì¸',
    'nsupseteqq;': 'â«†Ì¸',
    'precapprox;': 'âª·',
    'Proportion;': 'âˆ·',
    'RightArrow;': 'â†’',
    'Rightarrow;': 'â‡’',
    'rightarrow;': 'â†’',
    'RightFloor;': 'âŒ‹',
    'rmoustache;': 'â±',
    'sqsubseteq;': 'âŠ‘',
    'sqsupseteq;': 'âŠ’',
    'subsetneqq;': 'â«‹',
    'succapprox;': 'âª¸',
    'supsetneqq;': 'â«Œ',
    'ThickSpace;': 'âŸâ€Š',
    'TildeEqual;': 'â‰ƒ',
    'TildeTilde;': 'â‰ˆ',
    'UnderBrace;': 'âŸ',
    'UpArrowBar;': 'â¤’',
    'UpTeeArrow;': 'â†¥',
    'upuparrows;': 'â‡ˆ',
    'varepsilon;': 'Ïµ',
    'varnothing;': 'âˆ…',
    'backepsilon;': 'Ï¶',
    'blacksquare;': 'â–ª',
    'circledcirc;': 'âŠš',
    'circleddash;': 'âŠ',
    'CircleMinus;': 'âŠ–',
    'CircleTimes;': 'âŠ—',
    'curlyeqprec;': 'â‹',
    'curlyeqsucc;': 'â‹Ÿ',
    'diamondsuit;': 'â™¦',
    'eqslantless;': 'âª•',
    'Equilibrium;': 'â‡Œ',
    'expectation;': 'â„°',
    'GreaterLess;': 'â‰·',
    'LeftCeiling;': 'âŒˆ',
    'LessGreater;': 'â‰¶',
    'MediumSpace;': 'âŸ',
    'NotLessLess;': 'â‰ªÌ¸',
    'NotPrecedes;': 'âŠ€',
    'NotSucceeds;': 'âŠ',
    'NotSuperset;': 'âŠƒâƒ’',
    'nRightarrow;': 'â‡',
    'nrightarrow;': 'â†›',
    'OverBracket;': 'â´',
    'preccurlyeq;': 'â‰¼',
    'precnapprox;': 'âª¹',
    'quaternions;': 'â„',
    'RightVector;': 'â‡€',
    'Rrightarrow;': 'â‡›',
    'RuleDelayed;': 'â§´',
    'SmallCircle;': 'âˆ˜',
    'SquareUnion;': 'âŠ”',
    'straightphi;': 'Ï•',
    'SubsetEqual;': 'âŠ†',
    'succcurlyeq;': 'â‰½',
    'succnapprox;': 'âªº',
    'thickapprox;': 'â‰ˆ',
    'UpDownArrow;': 'â†•',
    'Updownarrow;': 'â‡•',
    'updownarrow;': 'â†•',
    'VerticalBar;': 'âˆ£',
    'blacklozenge;': 'â§«',
    'DownArrowBar;': 'â¤“',
    'DownTeeArrow;': 'â†§',
    'ExponentialE;': 'â…‡',
    'exponentiale;': 'â…‡',
    'GreaterEqual;': 'â‰¥',
    'GreaterTilde;': 'â‰³',
    'HilbertSpace;': 'â„‹',
    'HumpDownHump;': 'â‰',
    'Intersection;': 'â‹‚',
    'LeftArrowBar;': 'â‡¤',
    'LeftTeeArrow;': 'â†¤',
    'LeftTriangle;': 'âŠ²',
    'LeftUpVector;': 'â†¿',
    'NotCongruent;': 'â‰¢',
    'NotHumpEqual;': 'â‰Ì¸',
    'NotLessEqual;': 'â‰°',
    'NotLessTilde;': 'â‰´',
    'Proportional;': 'âˆ',
    'RightCeiling;': 'âŒ‰',
    'risingdotseq;': 'â‰“',
    'RoundImplies;': 'â¥°',
    'ShortUpArrow;': 'â†‘',
    'SquareSubset;': 'âŠ',
    'triangledown;': 'â–¿',
    'triangleleft;': 'â—ƒ',
    'UnderBracket;': 'âµ',
    'varsubsetneq;': 'âŠŠï¸€',
    'varsupsetneq;': 'âŠ‹ï¸€',
    'VerticalLine;': '|',
    'ApplyFunction;': 'â¡',
    'bigtriangleup;': 'â–³',
    'blacktriangle;': 'â–´',
    'DifferentialD;': 'â…†',
    'divideontimes;': 'â‹‡',
    'DoubleLeftTee;': 'â«¤',
    'DoubleUpArrow;': 'â‡‘',
    'fallingdotseq;': 'â‰’',
    'hookleftarrow;': 'â†©',
    'leftarrowtail;': 'â†¢',
    'leftharpoonup;': 'â†¼',
    'LeftTeeVector;': 'â¥š',
    'LeftVectorBar;': 'â¥’',
    'LessFullEqual;': 'â‰¦',
    'LongLeftArrow;': 'âŸµ',
    'Longleftarrow;': 'âŸ¸',
    'longleftarrow;': 'âŸµ',
    'looparrowleft;': 'â†«',
    'measuredangle;': 'âˆ¡',
    'NotEqualTilde;': 'â‰‚Ì¸',
    'NotTildeEqual;': 'â‰„',
    'NotTildeTilde;': 'â‰‰',
    'ntriangleleft;': 'â‹ª',
    'Poincareplane;': 'â„Œ',
    'PrecedesEqual;': 'âª¯',
    'PrecedesTilde;': 'â‰¾',
    'RightArrowBar;': 'â‡¥',
    'RightTeeArrow;': 'â†¦',
    'RightTriangle;': 'âŠ³',
    'RightUpVector;': 'â†¾',
    'shortparallel;': 'âˆ¥',
    'smallsetminus;': 'âˆ–',
    'SucceedsEqual;': 'âª°',
    'SucceedsTilde;': 'â‰¿',
    'SupersetEqual;': 'âŠ‡',
    'triangleright;': 'â–¹',
    'UpEquilibrium;': 'â¥®',
    'upharpoonleft;': 'â†¿',
    'varsubsetneqq;': 'â«‹ï¸€',
    'varsupsetneqq;': 'â«Œï¸€',
    'VerticalTilde;': 'â‰€',
    'VeryThinSpace;': 'â€Š',
    'curvearrowleft;': 'â†¶',
    'DiacriticalDot;': 'Ë™',
    'doublebarwedge;': 'âŒ†',
    'DoubleRightTee;': 'âŠ¨',
    'downdownarrows;': 'â‡Š',
    'DownLeftVector;': 'â†½',
    'GreaterGreater;': 'âª¢',
    'hookrightarrow;': 'â†ª',
    'HorizontalLine;': 'â”€',
    'InvisibleComma;': 'â£',
    'InvisibleTimes;': 'â¢',
    'LeftDownVector;': 'â‡ƒ',
    'leftleftarrows;': 'â‡‡',
    'LeftRightArrow;': 'â†”',
    'Leftrightarrow;': 'â‡”',
    'leftrightarrow;': 'â†”',
    'leftthreetimes;': 'â‹‹',
    'LessSlantEqual;': 'â©½',
    'LongRightArrow;': 'âŸ¶',
    'Longrightarrow;': 'âŸ¹',
    'longrightarrow;': 'âŸ¶',
    'looparrowright;': 'â†¬',
    'LowerLeftArrow;': 'â†™',
    'NestedLessLess;': 'â‰ª',
    'NotGreaterLess;': 'â‰¹',
    'NotLessGreater;': 'â‰¸',
    'NotSubsetEqual;': 'âŠˆ',
    'NotVerticalBar;': 'âˆ¤',
    'nshortparallel;': 'âˆ¦',
    'ntriangleright;': 'â‹«',
    'OpenCurlyQuote;': 'â€˜',
    'ReverseElement;': 'âˆ‹',
    'rightarrowtail;': 'â†£',
    'rightharpoonup;': 'â‡€',
    'RightTeeVector;': 'â¥›',
    'RightVectorBar;': 'â¥“',
    'ShortDownArrow;': 'â†“',
    'ShortLeftArrow;': 'â†',
    'SquareSuperset;': 'âŠ',
    'TildeFullEqual;': 'â‰…',
    'trianglelefteq;': 'âŠ´',
    'upharpoonright;': 'â†¾',
    'UpperLeftArrow;': 'â†–',
    'ZeroWidthSpace;': 'â€‹',
    'bigtriangledown;': 'â–½',
    'circlearrowleft;': 'â†º',
    'CloseCurlyQuote;': 'â€™',
    'ContourIntegral;': 'âˆ®',
    'curvearrowright;': 'â†·',
    'DoubleDownArrow;': 'â‡“',
    'DoubleLeftArrow;': 'â‡',
    'downharpoonleft;': 'â‡ƒ',
    'DownRightVector;': 'â‡',
    'leftharpoondown;': 'â†½',
    'leftrightarrows;': 'â‡†',
    'LeftRightVector;': 'â¥',
    'LeftTriangleBar;': 'â§',
    'LeftUpTeeVector;': 'â¥ ',
    'LeftUpVectorBar;': 'â¥˜',
    'LowerRightArrow;': 'â†˜',
    'nLeftrightarrow;': 'â‡',
    'nleftrightarrow;': 'â†®',
    'NotGreaterEqual;': 'â‰±',
    'NotGreaterTilde;': 'â‰µ',
    'NotHumpDownHump;': 'â‰Ì¸',
    'NotLeftTriangle;': 'â‹ª',
    'NotSquareSubset;': 'âŠÌ¸',
    'ntrianglelefteq;': 'â‹¬',
    'OverParenthesis;': 'âœ',
    'RightDownVector;': 'â‡‚',
    'rightleftarrows;': 'â‡„',
    'rightsquigarrow;': 'â†',
    'rightthreetimes;': 'â‹Œ',
    'ShortRightArrow;': 'â†’',
    'straightepsilon;': 'Ïµ',
    'trianglerighteq;': 'âŠµ',
    'UpperRightArrow;': 'â†—',
    'vartriangleleft;': 'âŠ²',
    'circlearrowright;': 'â†»',
    'DiacriticalAcute;': 'Â´',
    'DiacriticalGrave;': '`',
    'DiacriticalTilde;': 'Ëœ',
    'DoubleRightArrow;': 'â‡’',
    'DownArrowUpArrow;': 'â‡µ',
    'downharpoonright;': 'â‡‚',
    'EmptySmallSquare;': 'â—»',
    'GreaterEqualLess;': 'â‹›',
    'GreaterFullEqual;': 'â‰§',
    'LeftAngleBracket;': 'âŸ¨',
    'LeftUpDownVector;': 'â¥‘',
    'LessEqualGreater;': 'â‹š',
    'NonBreakingSpace;': ' ',
    'NotPrecedesEqual;': 'âª¯Ì¸',
    'NotRightTriangle;': 'â‹«',
    'NotSucceedsEqual;': 'âª°Ì¸',
    'NotSucceedsTilde;': 'â‰¿Ì¸',
    'NotSupersetEqual;': 'âŠ‰',
    'ntrianglerighteq;': 'â‹­',
    'rightharpoondown;': 'â‡',
    'rightrightarrows;': 'â‡‰',
    'RightTriangleBar;': 'â§',
    'RightUpTeeVector;': 'â¥œ',
    'RightUpVectorBar;': 'â¥”',
    'twoheadleftarrow;': 'â†',
    'UnderParenthesis;': 'â',
    'UpArrowDownArrow;': 'â‡…',
    'vartriangleright;': 'âŠ³',
    'blacktriangledown;': 'â–¾',
    'blacktriangleleft;': 'â—‚',
    'DoubleUpDownArrow;': 'â‡•',
    'DoubleVerticalBar;': 'âˆ¥',
    'DownLeftTeeVector;': 'â¥',
    'DownLeftVectorBar;': 'â¥–',
    'FilledSmallSquare;': 'â—¼',
    'GreaterSlantEqual;': 'â©¾',
    'LeftDoubleBracket;': 'âŸ¦',
    'LeftDownTeeVector;': 'â¥¡',
    'LeftDownVectorBar;': 'â¥™',
    'leftrightharpoons;': 'â‡‹',
    'LeftTriangleEqual;': 'âŠ´',
    'NegativeThinSpace;': 'â€‹',
    'NotGreaterGreater;': 'â‰«Ì¸',
    'NotLessSlantEqual;': 'â©½Ì¸',
    'NotNestedLessLess;': 'âª¡Ì¸',
    'NotReverseElement;': 'âˆŒ',
    'NotSquareSuperset;': 'âŠÌ¸',
    'NotTildeFullEqual;': 'â‰‡',
    'RightAngleBracket;': 'âŸ©',
    'rightleftharpoons;': 'â‡Œ',
    'RightUpDownVector;': 'â¥',
    'SquareSubsetEqual;': 'âŠ‘',
    'twoheadrightarrow;': 'â† ',
    'VerticalSeparator;': 'â˜',
    'blacktriangleright;': 'â–¸',
    'DownRightTeeVector;': 'â¥Ÿ',
    'DownRightVectorBar;': 'â¥—',
    'LongLeftRightArrow;': 'âŸ·',
    'Longleftrightarrow;': 'âŸº',
    'longleftrightarrow;': 'âŸ·',
    'NegativeThickSpace;': 'â€‹',
    'NotLeftTriangleBar;': 'â§Ì¸',
    'PrecedesSlantEqual;': 'â‰¼',
    'ReverseEquilibrium;': 'â‡‹',
    'RightDoubleBracket;': 'âŸ§',
    'RightDownTeeVector;': 'â¥',
    'RightDownVectorBar;': 'â¥•',
    'RightTriangleEqual;': 'âŠµ',
    'SquareIntersection;': 'âŠ“',
    'SucceedsSlantEqual;': 'â‰½',
    'DoubleLongLeftArrow;': 'âŸ¸',
    'DownLeftRightVector;': 'â¥',
    'LeftArrowRightArrow;': 'â‡†',
    'leftrightsquigarrow;': 'â†­',
    'NegativeMediumSpace;': 'â€‹',
    'NotGreaterFullEqual;': 'â‰§Ì¸',
    'NotRightTriangleBar;': 'â§Ì¸',
    'RightArrowLeftArrow;': 'â‡„',
    'SquareSupersetEqual;': 'âŠ’',
    'CapitalDifferentialD;': 'â……',
    'DoubleLeftRightArrow;': 'â‡”',
    'DoubleLongRightArrow;': 'âŸ¹',
    'EmptyVerySmallSquare;': 'â–«',
    'NestedGreaterGreater;': 'â‰«',
    'NotDoubleVerticalBar;': 'âˆ¦',
    'NotGreaterSlantEqual;': 'â©¾Ì¸',
    'NotLeftTriangleEqual;': 'â‹¬',
    'NotSquareSubsetEqual;': 'â‹¢',
    'OpenCurlyDoubleQuote;': 'â€œ',
    'ReverseUpEquilibrium;': 'â¥¯',
    'CloseCurlyDoubleQuote;': 'â€',
    'DoubleContourIntegral;': 'âˆ¯',
    'FilledVerySmallSquare;': 'â–ª',
    'NegativeVeryThinSpace;': 'â€‹',
    'NotPrecedesSlantEqual;': 'â‹ ',
    'NotRightTriangleEqual;': 'â‹­',
    'NotSucceedsSlantEqual;': 'â‹¡',
    'DiacriticalDoubleAcute;': 'Ë',
    'NotSquareSupersetEqual;': 'â‹£',
    'NotNestedGreaterGreater;': 'âª¢Ì¸',
    'ClockwiseContourIntegral;': 'âˆ²',
    'DoubleLongLeftRightArrow;': 'âŸº',
    'CounterClockwiseContourIntegral;': 'âˆ³',
};

const maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0);
const decodeHtml = (rawText, asAttr) => {
    var _a, _b;
    let offset = 0;
    const end = rawText.length;
    let decodedText = '';
    function advance(length) {
        offset += length;
        rawText = rawText.slice(length);
    }
    while (offset < end) {
        const head = /&(?:#x?)?/i.exec(rawText);
        if (head == null || offset + head.index >= end) {
            const remaining = end - offset;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
        }
        // Advance to the "&".
        decodedText += rawText.slice(0, head.index);
        advance(head.index);
        if (head[0] === '&') {
            // Named character reference.
            let name = '';
            let value;
            if (rawText[1] != null && /[0-9a-z]/i.test(rawText[1])) {
                for (let length = maxCRNameLength; value != null && length > 0; --length) {
                    name = rawText.substr(1, length);
                    value = namedCharacterReferences[name];
                }
                if (value != null) {
                    const semi = name.endsWith(';');
                    if (asAttr &&
                        !semi &&
                        /[=a-z0-9]/i.test((_a = rawText[name.length + 1]) !== null && _a !== void 0 ? _a : '')) {
                        decodedText += '&' + name;
                        advance(1 + name.length);
                    }
                    else {
                        decodedText += value;
                        advance(1 + name.length);
                    }
                }
                else {
                    decodedText += '&' + name;
                    advance(1 + name.length);
                }
            }
            else {
                decodedText += '&';
                advance(1);
            }
        }
        else {
            // Numeric character reference.
            const hex = head[0] === '&#x';
            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern.exec(rawText);
            if (body == null) {
                if (head[0] != null) {
                    decodedText = `${decodedText}${head[0]}`;
                    advance(head[0].length);
                }
            }
            else if (body[1] != null) {
                // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
                let cp = Number.parseInt(body[1], hex ? 16 : 10);
                if (cp === 0) {
                    cp = 0xfffd;
                }
                else if (cp > 0x10ffff) {
                    cp = 0xfffd;
                }
                else if (cp >= 0xd800 && cp <= 0xdfff) {
                    cp = 0xfffd;
                }
                else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) ;
                else if ((cp >= 0x01 && cp <= 0x08) ||
                    cp === 0x0b ||
                    (cp >= 0x0d && cp <= 0x1f) ||
                    (cp >= 0x7f && cp <= 0x9f)) {
                    cp = (_b = CCR_REPLACEMENTS[cp]) !== null && _b !== void 0 ? _b : cp;
                }
                decodedText += String.fromCodePoint(cp);
                if (body[0] != null)
                    advance(body[0].length);
            }
        }
    }
    return decodedText;
};
// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
    0x80: 0x20ac,
    0x82: 0x201a,
    0x83: 0x0192,
    0x84: 0x201e,
    0x85: 0x2026,
    0x86: 0x2020,
    0x87: 0x2021,
    0x88: 0x02c6,
    0x89: 0x2030,
    0x8a: 0x0160,
    0x8b: 0x2039,
    0x8c: 0x0152,
    0x8e: 0x017d,
    0x91: 0x2018,
    0x92: 0x2019,
    0x93: 0x201c,
    0x94: 0x201d,
    0x95: 0x2022,
    0x96: 0x2013,
    0x97: 0x2014,
    0x98: 0x02dc,
    0x99: 0x2122,
    0x9a: 0x0161,
    0x9b: 0x203a,
    0x9c: 0x0153,
    0x9e: 0x017e,
    0x9f: 0x0178,
};

const RAW_TEXT_TAGS = new Set(['style', 'iframe', 'script', 'noscript']);
const isRawTextContainer = (tagName) => RAW_TEXT_TAGS.has(tagName);
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = new Set(('html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot').split(','));
const isHTMLTag = (tagName) => HTML_TAGS.has(tagName);
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = new Set(('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view').split(','));
const isSVGTag = (tagName) => SVG_TAGS.has(tagName);
const VOID_TAGS = new Set('area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'.split(','));
const isVoidTag = (tagName) => VOID_TAGS.has(tagName);
const parserOptions = {
    isVoidTag,
    isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
    isPreTag: (tag) => tag === 'pre',
    decodeEntities: decodeHtml,
    isBuiltInComponent: () => { },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent != null ? parent.ns : 0 /* HTML */;
        if (parent != null && ns === 2 /* MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* SVG */;
                }
                if (parent.props.some((a) => a.type === 6 /* ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* HTML */;
            }
        }
        else if (parent != null && ns === 1 /* SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* HTML */;
            }
        }
        if (ns === 0 /* HTML */) {
            if (tag === 'svg') {
                return 1 /* SVG */;
            }
            if (tag === 'math') {
                return 2 /* MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* RAWTEXT */;
            }
        }
        return 0 /* DATA */;
    },
};

function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation(Object.assign({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function createLoc(loc, offset, length) {
    if (loc == null)
        return;
    const source = loc.source.substr(offset, length);
    const start = advancePositionWithClone(loc.start, loc.source.substr(0, offset));
    const end = advancePositionWithClone(start, source);
    return { source, start, end };
}

function createExpressionTracker(addIdentifer) {
    return (node, context) => {
        const localIdentifiers = new Set();
        if (isInterpolationNode(node)) {
            if (isSimpleExpressionNode(node.content) &&
                !node.content.isStatic &&
                node.content.content.trim() !== '') {
                trackIdentifiers(node.content.content, context, node.content.loc.start, addIdentifer);
            }
        }
        else if (isElementNode(node)) {
            node.props.forEach((dir) => {
                if (isDirectiveNode(dir)) {
                    if (isSimpleExpressionNode(dir.arg) &&
                        !dir.arg.isStatic &&
                        dir.arg.content.trim() !== '') {
                        trackIdentifiers(dir.arg.content, context, dir.arg.loc.start, addIdentifer);
                    }
                    const slot = findDir(node, 'slot');
                    if (slot != null) {
                        if (isSimpleExpressionNode(slot.exp) &&
                            !slot.exp.isStatic &&
                            slot.exp.content.trim() !== '') {
                            trackIdentifiers(slot.exp.content, context, slot.exp.loc.start, (identifier) => {
                                localIdentifiers.add(identifier);
                                context.addIdentifiers(identifier);
                            }, dir.name === 'slot');
                        }
                    }
                    switch (dir.name) {
                        case 'for':
                        case 'slot':
                            break;
                        case 'on':
                            if (isSimpleExpressionNode(dir.exp) &&
                                !dir.exp.isStatic &&
                                dir.exp.content.trim() !== '') {
                                context.addIdentifiers('$event');
                                trackIdentifiers(dir.exp.content, context, dir.exp.loc.start, addIdentifer, false, true);
                                context.removeIdentifiers('$event');
                            }
                            break;
                        default: {
                            if (isSimpleExpressionNode(dir.exp) &&
                                dir.exp.content.trim() !== '') {
                                trackIdentifiers(dir.exp.content, context, dir.exp.loc.start, addIdentifer);
                            }
                        }
                    }
                }
            });
        }
        return () => {
            localIdentifiers.forEach((identifier) => context.removeIdentifiers(identifier));
        };
    };
}
const KNOWN_IDENTIFIERS = new Set(('Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl').split(','));
function isKnownIdentifier(value) {
    return KNOWN_IDENTIFIERS.has(value) || /^(true|false|null|this)$/.test(value);
}
function trackIdentifiers(rawExp, context, start, addIdentifer, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false) {
    var _a, _b;
    rawExp = rawExp
        .trim()
        // Handle common incomplete expressions
        .replace(/(\.|\[\]?)$/, '');
    if (rawExp.trim() === '')
        return;
    if (isSimpleIdentifier(rawExp)) {
        if (!asParams &&
            ((_a = context.identifiers[rawExp]) !== null && _a !== void 0 ? _a : 0) === 0 &&
            !isKnownIdentifier(rawExp)) {
            addIdentifer(rawExp);
        }
        return;
    }
    const source = asRawStatements
        ? ` ${rawExp} `
        : `(${rawExp})${asParams ? `=>{}` : ``}`;
    try {
        const ast = parse$1(source, {
            plugins: [
                'bigInt',
                'optionalChaining',
                'nullishCoalescingOperator',
                'typescript',
            ],
            // @ts-expect-error
            errorRecovery: true,
        });
        const knownIds = { ...context.identifiers };
        traverse(ast, {
            enter(node, ancestors) {
                var _a, _b;
                const scope = new Set();
                const parent = (_a = ancestors[ancestors.length - 1]) === null || _a === void 0 ? void 0 : _a.node;
                if (isIdentifier(node)) {
                    if (((_b = knownIds[node.name]) !== null && _b !== void 0 ? _b : 0) === 0) {
                        if (shouldTrack$1(node, parent)) {
                            addIdentifer(node.name);
                        }
                    }
                }
                else if (isFunction(node)) {
                    node.params.forEach((param) => traverseFast(param, (node, ancestors) => {
                        var _a;
                        const parent = (_a = ancestors[ancestors.length - 1]) === null || _a === void 0 ? void 0 : _a.node;
                        if (parent != null &&
                            isIdentifier(node) &&
                            !isStaticProperty(parent) &&
                            !(isAssignmentPattern(parent) && parent.right === node)) {
                            const id = node.name;
                            if (!scope.has(id)) {
                                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                if (id in knownIds)
                                    ++knownIds[id];
                                else
                                    knownIds[id] = 1;
                            }
                            scope.add(id);
                        }
                    }));
                }
                // @ts-expect-error
                node.scope = scope;
            },
            exit(node) {
                // @ts-expect-error
                const scope = node.scope;
                scope === null || scope === void 0 ? void 0 : scope.forEach((id) => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    --knownIds[id];
                });
            },
        });
    }
    catch (error) {
        const RE = /\b[a-z$_][a-z0-9$_]*\b/gi;
        let match = null;
        do {
            match = RE.exec(source);
            if ((match === null || match === void 0 ? void 0 : match[0]) != null)
                addIdentifer(match[0]);
        } while (match != null);
        const pos = (_b = error.pos) !== null && _b !== void 0 ? _b : 0;
        context.onError({
            name: error.code,
            message: `Failed to analyze expression. Error: ${String(error.message)}`,
            code: 1000,
            loc: {
                source: rawExp,
                start: advancePositionWithClone(start, rawExp, pos - 1),
                end: advancePositionWithClone(start, rawExp, pos),
            },
        });
    }
}
function isStaticProperty(node) {
    return isObjectMember(node) && !node.computed;
}
function isStaticPropertyKey(node, parent) {
    return isStaticProperty(parent) && parent.key === node;
}
function shouldTrack$1(identifier, parent) {
    if (parent == null)
        return true;
    if (!(isFunction(parent) &&
        // not id of a FunctionDeclaration
        (parent.id === identifier ||
            // not a params of a function
            parent.params.includes(identifier))) &&
        // not a key of Property
        !isStaticPropertyKey(identifier, parent) &&
        // not a property of a MemberExpression
        !((isMemberExpression(parent) || isOptionalMemberExpression(parent)) &&
            parent.property === identifier &&
            !parent.computed) &&
        // not in an Array destructure pattern
        !isArrayPattern(parent) &&
        // skip whitelisted globals
        !isKnownIdentifier(identifier.name) &&
        // special case for webpack compilation
        identifier.name !== `require` &&
        // is a special keyword but parsed as identifier
        identifier.name !== `arguments`) {
        return true;
    }
    return false;
}

function createElementTransform(options, expressions) {
    let isImportAdded = false;
    let dynamicComponentCounter = 0;
    const globalsExpressions = [];
    const addHoistScope = () => {
        globalsExpressions.push(expressions.slice());
        expressions.length = 0;
    };
    const removeHoistScope = () => {
        const exps = globalsExpressions.pop();
        if (Array.isArray(exps)) {
            expressions.length = 0;
            expressions.push(...exps);
        }
    };
    const hoist = (exp) => {
        const name = `_DyComp${dynamicComponentCounter++}`.padEnd('component'.length, '_');
        expressions.push(createCompoundExpression([`const `, name, ' = ', exp, ';']));
        return name;
    };
    return (node, context) => {
        var _a, _b;
        if (!isImportAdded) {
            context.imports.push({
                exp: '_Ctx',
                path: getInternalPath(options),
            });
            isImportAdded = true;
        }
        if (isTextNode(node)) {
            markNonElementNode(node);
        }
        if (!isElementNode(node))
            return;
        let resolvedComponentName;
        const slotDir = findDir(node, 'slot');
        const hasScope = isComponentNode(node) || slotDir != null;
        if (hasScope)
            addHoistScope();
        if (isComponentNode(node)) {
            if (!['component', 'slot'].includes(node.tag)) {
                const name = pascalCase(node.tag);
                const component = (_a = options.components[name]) !== null && _a !== void 0 ? _a : options.components[node.tag];
                if (((_b = context.identifiers[name]) !== null && _b !== void 0 ? _b : 0) <= 0) {
                    if (component != null) {
                        context.imports.push({
                            exp: component.named === true
                                ? `{ ${component.name != null && component.name !== name
                                    ? component.name + ' as '
                                    : ''}${name} }`
                                : name,
                            path: component.path,
                        });
                        context.addIdentifiers(name);
                        resolvedComponentName = name;
                    }
                }
            }
        }
        return () => {
            var _a, _b;
            const exprs = expressions.slice();
            if (hasScope) {
                removeHoistScope();
                if (slotDir != null) {
                    if (slotDir.exp == null)
                        slotDir.exp = createSimpleExpression('{}', false);
                    slotDir.exp.exprs = exprs;
                }
            }
            if (node.tag === 'slot') {
                const slotName = findProp(node, 'name');
                const props = node.props.filter((prop) => prop !== slotName &&
                    (isAttributeNode(prop) || prop.name === 'bind'));
                const args = createCompoundExpression(props.length === 0
                    ? []
                    : props.length === 1 &&
                        isDirectiveNode(props[0]) &&
                        props[0].arg == null
                        ? [props[0].exp]
                        : flatten([
                            '{',
                            flatten(props.map((prop) => {
                                var _a;
                                if (isAttributeNode(prop)) {
                                    return generateAttribute(prop, node, ':');
                                }
                                else if (prop.name === 'bind') {
                                    if (isSimpleExpressionNode(prop.arg)) {
                                        return [
                                            '[',
                                            prop.arg.isStatic
                                                ? prop.arg
                                                : createSimpleExpression(prop.arg.content, prop.arg.isStatic, createLoc(prop.arg.loc, 1, prop.arg.content.length)),
                                            ']:',
                                            (_a = prop.exp) !== null && _a !== void 0 ? _a : 'true',
                                            ',',
                                        ];
                                    }
                                    else if (prop.exp != null) {
                                        return ['...(', prop.exp, '),'];
                                    }
                                }
                                return [];
                            })),
                            '}',
                        ]));
                node.codegenNode = createCompoundExpression(flatten([
                    context.helper(RENDER_SLOT),
                    '(',
                    '_ctx.$slots',
                    ',',
                    isAttributeNode(slotName)
                        ? createSimpleExpression((_b = (_a = slotName.value) === null || _a === void 0 ? void 0 : _a.content) !== null && _b !== void 0 ? _b : 'default', true, slotName.loc)
                        : isDirectiveNode(slotName)
                            ? slotName.exp
                            : createSimpleExpression('default', true),
                    ',',
                    args,
                    ')',
                    node.children.length > 0
                        ? flatten([' ?? (<>', generateChildNodes(node.children), '</>)'])
                        : [],
                ]));
                return;
            }
            let isHoistedComponentExpression = false;
            let name = resolvedComponentName !== null && resolvedComponentName !== void 0 ? resolvedComponentName : node.tag;
            let startTag = createSimpleExpression(name, false, createLoc(node.loc, node.loc.source.indexOf(node.tag), node.tag.length));
            if (node.tag === 'component') {
                const isProp = findProp(node, 'is');
                if (isAttributeNode(isProp) && isProp.value != null) {
                    isHoistedComponentExpression = true;
                    name = hoist(createSimpleExpression(`${JSON.stringify(isProp.value.content)} as const`, false, isProp.value.loc));
                    startTag = createSimpleExpression(name, false, startTag.loc);
                }
                else if (isDirectiveNode(isProp) &&
                    isSimpleExpressionNode(isProp.exp)) {
                    isHoistedComponentExpression = true;
                    name = hoist(isProp.exp);
                    startTag = createSimpleExpression(name, false, startTag.loc);
                }
                else {
                    name = '';
                    startTag = createSimpleExpression('', false);
                }
            }
            const attributes = generateJSXAttributes(node);
            if (node.isSelfClosing) {
                node.codegenNode = createCompoundExpression([
                    '<',
                    startTag,
                    ' ',
                    ...attributes,
                    ' />',
                ]);
                markElementNode(node.codegenNode);
            }
            else {
                const children = generateChildren(node, context, isHoistedComponentExpression || resolvedComponentName != null, exprs);
                node.codegenNode = createCompoundExpression([
                    '<',
                    startTag,
                    ' ',
                    ...attributes,
                    ' >',
                    ...children,
                    '</',
                    name,
                    '>',
                ]);
                markElementNode(node.codegenNode);
            }
        };
    };
}
function markElementNode(node) {
    node._isElementNode = true;
}
function markNonElementNode(node) {
    node._isElementNode = false;
}
function isMarkedElementNode(node) {
    return (node === null || node === void 0 ? void 0 : node._isElementNode) === true;
}
function getInternalPath(options) {
    var _a;
    return `./${(_a = options.filename.split(/[/\\]/).pop()) !== null && _a !== void 0 ? _a : options.filename}?internal`;
}
const ControlDirectiveNameRE = /^(if|for|else-if|else|slot)$/;
function generateJSXAttributes(node, _context) {
    const result = [];
    const alreadyProcessed = new Set();
    const ignore = node.tag === 'component' ? findProp(node, 'is') : undefined;
    node.props.forEach((dir) => {
        if (dir === ignore)
            return;
        if (isAttributeNode(dir)) {
            result.push(...generateAttribute(dir));
        }
        else if (ControlDirectiveNameRE.test(dir.name) ||
            alreadyProcessed.has(dir)) ;
        else {
            switch (dir.name) {
                case 'bind':
                    result.push(...generateVBind(dir));
                    break;
                case 'on':
                    result.push(...generateVOn(dir));
                    break;
                case 'model':
                    result.push(...generateVModel(dir, node));
                    break;
                default:
                    {
                        const code = generateCustomDirective(dir, node, alreadyProcessed);
                        result.push(...code);
                    }
                    break;
            }
        }
    });
    return result;
}
function generateCustomDirective(dir, node, alreadyProcessed) {
    const code = [];
    const dirs = node.props.filter((prop) => isDirectiveNode(prop) && prop.name === dir.name);
    dirs.forEach((dir) => alreadyProcessed.add(dir));
    code.push(` v-${dir.name}={`);
    const isMultiValue = dirs.length > 1;
    if (isMultiValue)
        code.push('[');
    dirs.forEach((dir) => {
        var _a, _b;
        code.push('{');
        code.push('arg:', (_a = dir.arg) !== null && _a !== void 0 ? _a : 'undefined', ',');
        code.push('exp:', (_b = dir.exp) !== null && _b !== void 0 ? _b : 'undefined', ',');
        // TODO: Maybe array?
        code.push('modifiers: {');
        dir.modifiers.forEach((modifier) => {
            code.push(modifier, ':true,');
        });
        code.push('}');
        code.push('}');
        if (isMultiValue)
            code.push(',');
    });
    if (isMultiValue)
        code.push(']');
    code.push('}');
    return code;
}
function generateVModel(dir, node) {
    var _a;
    const code = [];
    const exp = (_a = dir.exp) !== null && _a !== void 0 ? _a : 'null';
    const isNativeInput = /^(input|textarea|select)$/.test(node.tag);
    if (isNativeInput && dir.arg == null) {
        const isCheckboxOrRadio = node.props.some((prop) => isAttributeNode(prop) &&
            (prop.name === 'radio' || prop.name === 'checkbox'));
        const type = `Event & {target:${getHTMLElementType(node.tag)}}`;
        code.push(` ${isCheckboxOrRadio ? 'checked' : 'value'}={`, exp, '}  ');
        code.push(`onChange={($event) => (`, exp, ' = ', dir.modifiers.includes('number')
            ? `Number(($event as ${type}).target.value)`
            : `($event as ${type}).target.value`, ')}');
    }
    else {
        code.push(' ');
        if (isSimpleExpressionNode(dir.arg)) {
            if (dir.arg.isStatic) {
                code.push(dir.arg, '={', exp, '}');
            }
            else {
                code.push('{...({[', dir.arg, ']: ', exp, '})}');
            }
        }
        else {
            code.push('modelValue={', exp, '}');
        }
        code.push(' ');
        const arg = isSimpleExpressionNode(dir.arg)
            ? dir.arg.isStatic
                ? ["'", 'onUpdate:' + dir.arg.content, "'"]
                : [`['onUpdate:' + `, dir.arg, `]`]
            : [`'onUpdate:modelValue'`];
        code.push(`{...({`, ...arg, ': $event => ', exp, ' = $event', '})}');
        if (isSimpleExpressionNode(dir.arg))
            dir.arg.isStatic = false;
    }
    return code;
}
function generateAttribute(attr, _node, sep = '=') {
    const code = [];
    if (sep === '=' && (attr.name === 'class' || attr.name === 'style')) {
        return code;
    }
    else {
        code.push(' ', createSimpleExpression(attr.name, false, createLoc(attr.loc, 0, attr.name.length)));
        if (attr.value != null) {
            code.push(sep, createSimpleExpression(attr.value.loc.source, false, attr.value.loc));
        }
        else if (sep === ':') {
            code.push(sep, 'true');
        }
        if (sep === ':')
            code.push(',');
        return code;
    }
}
const InlineVOnHandlerRE = /\bfunction\b|\b=>\b/;
function generateVOn(dir, _node) {
    const code = [];
    const exp = isSimpleExpressionNode(dir.exp)
        ? isSimpleIdentifier(dir.exp.content.trim()) ||
            InlineVOnHandlerRE.test(dir.exp.content)
            ? [dir.exp]
            : dir.exp.content.includes('$event')
                ? ['$event =>', dir.exp]
                : ['() => ', dir.exp]
        : ['() => {}'];
    code.push(' ');
    if (isSimpleExpressionNode(dir.arg)) {
        if (dir.arg.isStatic) {
            if (dir.arg.content.includes(':')) {
                code.push('{...({"', createSimpleExpression(getEventName(dir.arg.content), false, dir.arg.loc), '":', ...exp, '})}');
            }
            else {
                code.push(createSimpleExpression(getEventName(dir.arg.content), false, dir.arg.loc), '={', ...exp, '}');
            }
        }
        else {
            code.push('{...({[', dir.arg, ']: ', ...exp, '})}');
        }
    }
    else if (dir.exp != null) {
        code.push('{...(', dir.exp, ')}');
    }
    return code;
}
function getEventName(dir) {
    var _a;
    if (dir.includes(':')) {
        const parts = dir.split(':');
        return `${camelCase(`on-${(_a = parts[0]) !== null && _a !== void 0 ? _a : ''}`)}:${parts.slice(1).join(':')}`;
    }
    return camelCase(`on-${dir}`);
}
function generateVBind(dir, _node) {
    const code = [];
    if (isSimpleExpressionNode(dir.arg)) {
        if (dir.arg.isStatic || dir.arg.content === 'key') {
            dir.arg.isStatic = false;
            code.push(' ', dir.arg);
            if (dir.exp != null)
                code.push('={', dir.exp, '}');
        }
        else {
            code.push(' {...({[', createSimpleExpression(dir.arg.content, dir.arg.isStatic, createLoc(dir.arg.loc, 1, dir.arg.content.length)), ']: ');
            if (dir.exp != null)
                code.push(dir.exp);
            else
                code.push('true');
            code.push('})}');
        }
    }
    else if (dir.exp != null) {
        code.push(' {...(', dir.exp, ')}');
    }
    return code;
}
function generateChildren(node, context, isResolvedComponent, expressions) {
    if (isResolvedComponent) {
        const { slots } = buildSlots(node, context, (props, children, _loc) => {
            var _a, _b;
            if (((_a = props) === null || _a === void 0 ? void 0 : _a.exprs) != null) {
                expressions = (_b = props) === null || _b === void 0 ? void 0 : _b.exprs;
            }
            const nodes = generateChildNodes(children);
            const returns = createCompoundExpression(nodes.length > 0 ? ['(<>', ...nodes, '</>)'] : ['null']);
            const fn = createFunctionExpression(props, undefined, true);
            if (expressions.length > 0) {
                fn.body = createBlockStatement([
                    ...expressions,
                    createCompoundExpression(['\nreturn ', returns]),
                ]);
            }
            else {
                fn.returns = returns;
            }
            return fn;
        });
        context.helpers.delete(WITH_CTX);
        if (isDynamicSlotsExpression(slots)) {
            slots.arguments[0].properties = slots.arguments[0].properties.filter((property) => !(isSimpleExpressionNode(property.key) && property.key.content === '_'));
        }
        else {
            slots.properties = slots.properties.filter((property) => !(isSimpleExpressionNode(property.key) && property.key.content === '_'));
        }
        return [createCompoundExpression(['{', slots, '}'])];
    }
    else {
        return generateChildNodes(node.children);
    }
}
function generateChildNodes(nodes) {
    return flatten(nodes.map((node) => {
        if (isTextNode(node)) {
            return createCompoundExpression([
                '{',
                JSON.stringify(node.content),
                '}\n',
            ]);
        }
        else if (isMarkedElementNode(node.codegenNode)) {
            return createCompoundExpression([node, '\n']);
        }
        else {
            return createCompoundExpression(['{', node, '}\n']);
        }
    }));
}
function isDynamicSlotsExpression(node) {
    return node.type === 14;
}
function getHTMLElementType(tag) {
    switch (tag) {
        case 'input':
            return 'HTMLInputElement';
        case 'textarea':
            return 'HTMLTextAreaElement';
        case 'select':
            return 'HTMLSelectElement';
        default:
            return 'HTMLElement';
    }
}

const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
function createTransformFor(addIdentifer, expressions) {
    const globalsExpressions = [];
    const addHoistScope = () => {
        globalsExpressions.push(expressions.slice());
        expressions.length = 0;
    };
    const removeHoistScope = () => {
        const exps = globalsExpressions.pop();
        if (Array.isArray(exps)) {
            expressions.length = 0;
            expressions.push(...exps);
        }
    };
    return createStructuralDirectiveTransform(/^for$/, (node, dir, context) => {
        let exp;
        if (isSimpleExpressionNode(dir.exp)) {
            const parseResult = forAliasRE.exec(dir.exp.content);
            if ((parseResult === null || parseResult === void 0 ? void 0 : parseResult[2]) != null) {
                exp = createSimpleExpression(parseResult[2], false, createLoc(dir.exp.loc, dir.exp.content.indexOf(parseResult[2]), parseResult[2].length));
                trackIdentifiers(exp.content, context, exp.loc.start, addIdentifer);
            }
        }
        return processFor(node, dir, context, (forNode) => {
            const renderExp = createCallExpression(context.helper(RENDER_LIST), [
                exp,
            ]);
            forNode.codegenNode = createCompoundExpression([renderExp]);
            addHoistScope();
            return () => {
                const childBlock = forNode.children.length === 0
                    ? createCompoundExpression(['null'])
                    : createCompoundExpression([
                        '<>',
                        ...generateChildNodes(forNode.children),
                        '</>',
                    ]);
                const fn = createFunctionExpression(createForLoopParams(forNode.parseResult), undefined, true /* force newline */);
                if (expressions.length > 0) {
                    fn.body = createBlockStatement([
                        ...expressions,
                        createCompoundExpression(['\nreturn ', childBlock]),
                    ]);
                }
                else {
                    fn.returns = childBlock;
                }
                renderExp.arguments.push(fn);
                removeHoistScope();
            };
        });
    });
}

// eslint-disable-next-line @typescript-eslint/triple-slash-reference
class Scope {
    constructor(parent = null) {
        this.parent = parent;
        this.bindings = {};
    }
    get identifiers() {
        return Array.from(Object.keys(this.bindings));
    }
    get globals() {
        return this.identifiers.filter((identifier) => this.getBinding(identifier) === null);
    }
    getBinding(identifier) {
        var _a;
        if (identifier in this.bindings)
            return (_a = this.bindings[identifier]) !== null && _a !== void 0 ? _a : null;
        if (this.parent != null) {
            return (this.bindings[identifier] = this.parent.getBinding(identifier));
        }
        else {
            this.bindings[identifier] = null;
        }
        return null;
    }
    setBinding(identifer, node) {
        this.bindings[identifer] = node;
    }
}
function withScope(ast) {
    ast.scope = new Scope(null);
    traverse$1(ast, (node, ancestors) => {
        var _a, _b, _c;
        const parent = ((_b = (_a = ancestors[ancestors.length - 1]) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : ast);
        const scope = (node.scope = (_c = node.scope) !== null && _c !== void 0 ? _c : new Scope(parent.scope));
        if (isSimpleExpressionNode(node) && !node.isStatic) {
            if (parent != null ||
                !(isDirectiveNode(parent) &&
                    ['slot', 'for'].includes(parent.name) &&
                    parent.exp === node)) {
                getIdentifiers(node.content).forEach((identifier) => scope.getBinding(identifier));
            }
        }
        else if (isElementNode(node)) {
            node.props.forEach((prop) => {
                var _a;
                if (isDirectiveNode(prop)) {
                    const directiveScope = (prop.scope = (_a = prop.scope) !== null && _a !== void 0 ? _a : new Scope(scope));
                    if (prop.name === 'slot') {
                        if (isSimpleExpressionNode(prop.exp)) {
                            const localScope = (prop.exp.scope = new Scope(directiveScope));
                            const content = prop.exp.content.trim();
                            getIdentifiers(`(${content}) => {}`).forEach((identifier) => {
                                scope.setBinding(identifier, node);
                                localScope.getBinding(identifier);
                            });
                        }
                    }
                    else if (prop.name === 'for') {
                        if (isSimpleExpressionNode(prop.exp)) {
                            const localScope = (prop.exp.scope = new Scope(directiveScope));
                            const match = forAliasRE.exec(prop.exp.content);
                            if (match != null) {
                                const [, LHS, RHS] = match;
                                if (RHS != null) {
                                    getIdentifiers(RHS).forEach((identifier) => {
                                        localScope.getBinding(identifier);
                                    });
                                    getIdentifiers(`${LHS !== null && LHS !== void 0 ? LHS : '()'} => {}`).forEach((identifier) => {
                                        scope.setBinding(identifier, node);
                                        localScope.getBinding(identifier);
                                    });
                                }
                            }
                        }
                    }
                }
            });
        }
    });
    return ast;
}
/**
 * @internal
 */
function getTopLevelIdentifiers(source, ignoreImportsFrom) {
    const identifiers = new Set();
    const components = new Set();
    const directives = new Set();
    let propsIdentifier;
    let emitIdentifier;
    let definePropsIdentifierFn;
    let defineEmitIdentifierFn;
    const ignoredSources = new Set(ignoreImportsFrom);
    try {
        const ast = parseUsingBabel(source, true);
        const getIdentifiers = (node) => {
            if (isIdentifier(node))
                return [node.name];
            else if (isMemberExpression(node)) {
                if (isIdentifier(node.property)) {
                    return [node.property.name];
                }
                else if (isExpression(node.property)) {
                    return [];
                }
                else if (isPrivateName(node.property)) {
                    return [node.property.id.name];
                }
                else {
                    return [];
                }
            }
            else if (isRestElement(node)) {
                return getIdentifiers(node.argument);
            }
            else if (isAssignmentPattern(node)) {
                return getIdentifiers(node.left);
            }
            else if (isArrayPattern(node)) {
                return flatten(node.elements
                    .filter((element) => element != null)
                    .map((element) => getIdentifiers(element)));
            }
            else if (isObjectPattern(node)) {
                return flatten(node.properties.map((property) => {
                    if (isRestElement(property) || isIdentifier(property)) {
                        return getIdentifiers(property);
                    }
                    else {
                        return [];
                    }
                }));
            }
            else {
                return [];
            }
        };
        if (isFile(ast)) {
            ast.program.body.forEach((node) => {
                if (!isDeclaration(node))
                    return;
                if (isVariableDeclaration(node)) {
                    node.declarations.forEach((declaration) => {
                        getIdentifiers(declaration.id).forEach((name) => identifiers.add(name));
                        if (isIdentifier(declaration.id) &&
                            isCallExpression(declaration.init)) {
                            if (isIdentifier(declaration.init.callee)) {
                                if (declaration.init.callee.name === definePropsIdentifierFn) {
                                    propsIdentifier = declaration.id.name;
                                }
                                else if (declaration.init.callee.name === defineEmitIdentifierFn) {
                                    emitIdentifier = declaration.id.name;
                                }
                            }
                        }
                    });
                }
                else if (isFunctionDeclaration(node)) {
                    if (node.id != null)
                        identifiers.add(node.id.name);
                }
                else if (isImportDeclaration(node)) {
                    const isVue = node.source.value === 'vue';
                    node.specifiers.forEach((specifier) => {
                        if (isVue && isImportSpecifier(specifier)) {
                            const name = isIdentifier(specifier.imported)
                                ? specifier.imported.name
                                : specifier.imported.value;
                            if (name === 'defineProps') {
                                definePropsIdentifierFn = specifier.local.name;
                                return; // -
                            }
                            else if (name === 'defineEmit') {
                                defineEmitIdentifierFn = specifier.local.name;
                                return; // -
                            }
                        }
                        if (!ignoredSources.has(node.source.value)) {
                            identifiers.add(specifier.local.name);
                            if (isCamelCase(specifier.local.name)) {
                                directives.add(specifier.local.name);
                            }
                            else if (isPascalCase(specifier.local.name)) {
                                components.add(specifier.local.name);
                            }
                        }
                    });
                }
                else if (isClassDeclaration(node)) {
                    identifiers.add(node.id.name);
                }
                else if (isDeclareClass(node)) {
                    identifiers.add(node.id.name);
                }
                else if (isDeclareFunction(node)) {
                    identifiers.add(node.id.name);
                }
                else if (isDeclareVariable(node)) {
                    identifiers.add(node.id.name);
                }
                else if (isEnumDeclaration(node)) {
                    identifiers.add(node.id.name);
                }
            });
        }
    }
    catch {
        // FIXME: Handle errors
    }
    return {
        identifiers,
        components,
        directives,
        emitIdentifier,
        propsIdentifier,
    };
}
function getIdentifiers(source) {
    source = source
        .trim()
        // Common errors when user is typing.
        .replace(/(\.|\[\]?)$/, '');
    if (isSimpleIdentifier(source.trim()))
        return new Set([source]);
    // TODO: Handle incomplete expressions
    try {
        const ast = parseUsingBabel(source, false);
        const identifers = new Set();
        traverse(ast, (node, ancestors) => {
            if (isIdentifier(node)) {
                if (ancestors.length > 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    if (shouldTrack(node, ancestors[ancestors.length - 1].node)) {
                        identifers.add(node.name);
                    }
                }
                else {
                    identifers.add(node.name);
                }
            }
        });
        return identifers;
    }
    catch {
        return new Set([]);
    }
}
function parseUsingBabel(source, withTS = false) {
    try {
        return parse$1(source, {
            plugins: withTS
                ? ['bigInt', 'optionalChaining', 'typescript']
                : ['bigInt', 'optionalChaining'],
            // @ts-expect-error
            errorRecovery: true,
        });
    }
    catch {
        return parseExpression(source, {
            plugins: withTS
                ? ['bigInt', 'optionalChaining', 'typescript']
                : ['bigInt', 'optionalChaining'],
            // @ts-expect-error
            errorRecovery: true,
        });
    }
}
function shouldTrack(identifier, parent) {
    if (!(isFunction(parent) &&
        // not id of a FunctionDeclaration
        parent.id === identifier) &&
        // not a key of Property
        !isStaticPropertyKey(identifier, parent) &&
        // not a property of a MemberExpression
        !((isMemberExpression(parent) || isOptionalMemberExpression(parent)) &&
            parent.property === identifier &&
            !parent.computed) &&
        // skip whitelisted globals
        !isKnownIdentifier(identifier.name) &&
        // special case for webpack compilation
        identifier.name !== `require` &&
        // is a special keyword but parsed as identifier
        identifier.name !== `arguments`) {
        return true;
    }
    return false;
}

function createTransformIf(addIdentifer) {
    return createStructuralDirectiveTransform(/^(if|else-if|else)$/, (node, dir, context) => {
        const exp = dir.exp;
        const content = exp === null || exp === void 0 ? void 0 : exp.content;
        if (isSimpleExpressionNode(dir.exp)) {
            trackIdentifiers(dir.exp.content, context, dir.exp.loc.start, addIdentifer);
        }
        return processIf(node, dir, context, (ifNode, branch, _isRoot) => {
            return () => {
                let hasElse = false;
                if (dir.name !== 'else') {
                    branch.condition = createSimpleExpression$1(content == null || content.trim() === '' ? 'false' : content, false, exp === null || exp === void 0 ? void 0 : exp.loc);
                }
                const expressions = [
                    ...flatten(ifNode.branches.map((branch) => {
                        hasElse = hasElse || branch.condition == null;
                        return branch.condition != null
                            ? [
                                '(',
                                branch.condition,
                                ') ? (',
                                ...normalizeChildren(branch.children),
                                ') :',
                            ]
                            : ['(', ...normalizeChildren(branch.children), ')'];
                    })),
                    `${hasElse ? '' : 'null'}`,
                ];
                ifNode.codegenNode = createCompoundExpression(expressions);
            };
        });
    });
}
function normalizeChildren(children) {
    return children.length === 0
        ? ['null']
        : children.length === 1
            ? children
            : ['<>', ...children, '</>'];
}

function createInterpolationTransform(_options) {
    return function transform(node, context) {
        if (isInterpolationNode(node)) {
            context.replaceNode(createCompoundExpression([node.content]));
        }
    };
}

function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
const components = {};
function compile(template, options) {
    const ast = parse(template, options);
    const astCopy = clone(ast);
    const expressions = [];
    const config = {
        ...parserOptions,
        ...options,
        components: {
            ...components,
            ...options.components,
            [getComponentName(options.filename)]: {
                path: `./${Path.posix.basename(options.filename)}`,
            },
        },
    };
    const identifiers = new Set();
    const addIdentifier = (id) => {
        if (id.trim() !== '') {
            identifiers.add(id.trim());
        }
    };
    const errors = [];
    const hoists = [];
    transform(ast, {
        ...options,
        prefixIdentifiers: true,
        hoistStatic: false,
        transformHoist: null,
        ssr: false,
        cacheHandlers: false,
        scopeId: null,
        nodeTransforms: [
            // Collect Expressions
            (node) => {
                if (isInterpolationNode(node)) {
                    expressions.push([
                        node.content.loc.start.offset,
                        node.content.loc.source.length,
                    ]);
                }
                else if (isElementNode(node)) {
                    node.props.forEach((prop) => {
                        if (isDirectiveNode(prop)) {
                            if (prop.exp != null) {
                                expressions.push([
                                    prop.exp.loc.start.offset,
                                    prop.exp.loc.source.length,
                                ]);
                            }
                            if (isSimpleExpressionNode(prop.arg) && !prop.arg.isStatic) {
                                expressions.push([
                                    prop.arg.loc.start.offset + 1,
                                    prop.arg.loc.source.length - 2,
                                ]);
                            }
                        }
                    });
                }
            },
            // Drop Comments
            (node, context) => {
                if (isCommentNode(node)) {
                    context.replaceNode(createCompoundExpression(['/* ', node.content, ' */']));
                }
                else if (isElementNode(node) && node.tag.includes('<')) {
                    node.tag = node.tag.replace(/[<]/g, ' ');
                }
            },
            createTransformFor(addIdentifier, hoists),
            createTransformIf(addIdentifier),
            createExpressionTracker(addIdentifier),
            createElementTransform(config, hoists),
            createInterpolationTransform(),
        ],
        onError(error) {
            errors.push(error);
        },
    });
    const hasVFor = ast.helpers.includes(RENDER_LIST);
    const hasVSlot = ast.helpers.includes(RENDER_SLOT);
    [
        OPEN_BLOCK,
        CREATE_BLOCK,
        CREATE_VNODE,
        FRAGMENT,
        RENDER_LIST,
        RENDER_SLOT,
    ].forEach((helper) => {
        const index = ast.helpers.indexOf(helper);
        if (index >= 0)
            ast.helpers.splice(index, 1);
    });
    if (ast.children.length > 0) {
        ast.codegenNode = createCompoundExpression([
            '<>',
            ...generateChildNodes(ast.children),
            '</>/*@@vue:end*/',
        ]);
    }
    else {
        ast.codegenNode = createCompoundExpression([
            '/*@@vue:start*/null/*@@vue:end*/',
        ]);
    }
    const mappings = [];
    let isStartInjected = false;
    const result = generate(ast, {
        ...options,
        sourceMap: true,
        mode: 'module',
        onContextCreated(context) {
            const push = context.push;
            context.push = (code, node) => {
                if (code.trim().startsWith('export')) {
                    push([
                        `type I<T> = T`,
                        `type ${getComponentName(options.filename)} = I<InstanceType<typeof _Ctx>>`,
                        hasVFor
                            ? `import { _renderList } from '__vuedx_runtime__render__'`
                            : null,
                        hasVSlot
                            ? `import { _renderSlot } from '__vuedx_runtime__render__'`
                            : null,
                        `declare const __completionsTrigger: ${getComponentName(options.filename)}`,
                        '__completionsTrigger./*@@vue:completions*/$props',
                        'const __completionsTag = /*@@vue:completionsTag*/<></>',
                        '',
                    ]
                        .filter((value) => value != null)
                        .join('\n'));
                }
                if ((node === null || node === void 0 ? void 0 : node.loc) != null &&
                    node.loc.start.offset !== 0 &&
                    node.loc.end.offset !== 0) {
                    mappings.push([
                        context.offset,
                        code.length,
                        node.loc.start.offset,
                        node.loc.source.length,
                        0,
                    ]);
                }
                if (code === 'return ') {
                    if (!isStartInjected) {
                        isStartInjected = true;
                        push(`/*@@vue:start*/`);
                        context.newline();
                        hoists.forEach((hoist) => {
                            hoist.children.forEach((child) => {
                                if (isSimpleExpressionNode(child)) {
                                    context.push(child.content, child);
                                }
                                else if (typeof child === 'string') {
                                    push(child);
                                }
                            });
                            context.newline();
                        });
                        push(code);
                    }
                    else {
                        push(code);
                    }
                }
                else if (code.startsWith('function render(_ctx')) {
                    push(`function render(${identifiers.size > 0
                        ? `{/*@@vue:identifiers-start*/${Array.from(identifiers).join(', ')}/*@@vue:identifiers-end*/,..._ctx}`
                        : '_ctx'}: ${getComponentName(options.filename)}) {`);
                }
                else {
                    push(code, node);
                }
            };
        },
    });
    return {
        ...result,
        ast: withScope(astCopy),
        mappings,
        expressions,
        errors,
    };
}
function parse(template, options) {
    return baseParse(template, {
        ...parserOptions,
        ...options,
    });
}

export { compile, getTopLevelIdentifiers, parse };
//# sourceMappingURL=index.mjs.map
